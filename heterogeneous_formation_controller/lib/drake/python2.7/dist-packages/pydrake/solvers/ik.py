# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ik')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ik')
    _ik = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ik', [dirname(__file__)])
        except ImportError:
            import _ik
            return _ik
        if fp is not None:
            try:
                _mod = imp.load_module('_ik', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ik = swig_import_helper()
    del swig_import_helper
else:
    import _ik
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ik.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _ik.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ik.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ik.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ik.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ik.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ik.SwigPyIterator_copy(self)

    def next(self):
        return _ik.SwigPyIterator_next(self)

    def __next__(self):
        return _ik.SwigPyIterator___next__(self)

    def previous(self):
        return _ik.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ik.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ik.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ik.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ik.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ik.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ik.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ik.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _ik.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import pydrake.rbtree
import pydrake.autodiffutils
class intVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _ik.intVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ik.intVector___nonzero__(self)

    def __bool__(self):
        return _ik.intVector___bool__(self)

    def __len__(self):
        return _ik.intVector___len__(self)

    def pop(self):
        return _ik.intVector_pop(self)

    def __getslice__(self, i, j):
        return _ik.intVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _ik.intVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _ik.intVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _ik.intVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _ik.intVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _ik.intVector___setitem__(self, *args)

    def append(self, x):
        return _ik.intVector_append(self, x)

    def empty(self):
        return _ik.intVector_empty(self)

    def size(self):
        return _ik.intVector_size(self)

    def swap(self, v):
        return _ik.intVector_swap(self, v)

    def begin(self):
        return _ik.intVector_begin(self)

    def end(self):
        return _ik.intVector_end(self)

    def rbegin(self):
        return _ik.intVector_rbegin(self)

    def rend(self):
        return _ik.intVector_rend(self)

    def clear(self):
        return _ik.intVector_clear(self)

    def get_allocator(self):
        return _ik.intVector_get_allocator(self)

    def pop_back(self):
        return _ik.intVector_pop_back(self)

    def erase(self, *args):
        return _ik.intVector_erase(self, *args)

    def __init__(self, *args):
        this = _ik.new_intVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _ik.intVector_push_back(self, x)

    def front(self):
        return _ik.intVector_front(self)

    def back(self):
        return _ik.intVector_back(self)

    def assign(self, n, x):
        return _ik.intVector_assign(self, n, x)

    def resize(self, *args):
        return _ik.intVector_resize(self, *args)

    def insert(self, *args):
        return _ik.intVector_insert(self, *args)

    def reserve(self, n):
        return _ik.intVector_reserve(self, n)

    def capacity(self):
        return _ik.intVector_capacity(self)
    __swig_destroy__ = _ik.delete_intVector
    __del__ = lambda self: None
intVector_swigregister = _ik.intVector_swigregister
intVector_swigregister(intVector)

class vectorConstraintPtr(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _ik.vectorConstraintPtr_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ik.vectorConstraintPtr___nonzero__(self)

    def __bool__(self):
        return _ik.vectorConstraintPtr___bool__(self)

    def __len__(self):
        return _ik.vectorConstraintPtr___len__(self)

    def pop(self):
        return _ik.vectorConstraintPtr_pop(self)

    def __getslice__(self, i, j):
        return _ik.vectorConstraintPtr___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _ik.vectorConstraintPtr___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _ik.vectorConstraintPtr___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _ik.vectorConstraintPtr___delitem__(self, *args)

    def __getitem__(self, *args):
        return _ik.vectorConstraintPtr___getitem__(self, *args)

    def __setitem__(self, *args):
        return _ik.vectorConstraintPtr___setitem__(self, *args)

    def append(self, x):
        return _ik.vectorConstraintPtr_append(self, x)

    def empty(self):
        return _ik.vectorConstraintPtr_empty(self)

    def size(self):
        return _ik.vectorConstraintPtr_size(self)

    def swap(self, v):
        return _ik.vectorConstraintPtr_swap(self, v)

    def begin(self):
        return _ik.vectorConstraintPtr_begin(self)

    def end(self):
        return _ik.vectorConstraintPtr_end(self)

    def rbegin(self):
        return _ik.vectorConstraintPtr_rbegin(self)

    def rend(self):
        return _ik.vectorConstraintPtr_rend(self)

    def clear(self):
        return _ik.vectorConstraintPtr_clear(self)

    def get_allocator(self):
        return _ik.vectorConstraintPtr_get_allocator(self)

    def pop_back(self):
        return _ik.vectorConstraintPtr_pop_back(self)

    def erase(self, *args):
        return _ik.vectorConstraintPtr_erase(self, *args)

    def __init__(self, *args):
        this = _ik.new_vectorConstraintPtr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _ik.vectorConstraintPtr_push_back(self, x)

    def front(self):
        return _ik.vectorConstraintPtr_front(self)

    def back(self):
        return _ik.vectorConstraintPtr_back(self)

    def assign(self, n, x):
        return _ik.vectorConstraintPtr_assign(self, n, x)

    def resize(self, *args):
        return _ik.vectorConstraintPtr_resize(self, *args)

    def insert(self, *args):
        return _ik.vectorConstraintPtr_insert(self, *args)

    def reserve(self, n):
        return _ik.vectorConstraintPtr_reserve(self, n)

    def capacity(self):
        return _ik.vectorConstraintPtr_capacity(self)
    __swig_destroy__ = _ik.delete_vectorConstraintPtr
    __del__ = lambda self: None
vectorConstraintPtr_swigregister = _ik.vectorConstraintPtr_swigregister
vectorConstraintPtr_swigregister(vectorConstraintPtr)

class IKoptions(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_IKoptions(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_IKoptions
    __del__ = lambda self: None

    def getRobotPtr(self):
        return _ik.IKoptions_getRobotPtr(self)

    def setQ(self, Q):
        return _ik.IKoptions_setQ(self, Q)

    def setQa(self, Qa):
        return _ik.IKoptions_setQa(self, Qa)

    def setQv(self, Qv):
        return _ik.IKoptions_setQv(self, Qv)

    def setDebug(self, flag):
        return _ik.IKoptions_setDebug(self, flag)

    def setSequentialSeedFlag(self, flag):
        return _ik.IKoptions_setSequentialSeedFlag(self, flag)

    def setMajorOptimalityTolerance(self, tol):
        return _ik.IKoptions_setMajorOptimalityTolerance(self, tol)

    def setMajorFeasibilityTolerance(self, tol):
        return _ik.IKoptions_setMajorFeasibilityTolerance(self, tol)

    def setSuperbasicsLimit(self, limit):
        return _ik.IKoptions_setSuperbasicsLimit(self, limit)

    def setMajorIterationsLimit(self, limit):
        return _ik.IKoptions_setMajorIterationsLimit(self, limit)

    def setIterationsLimit(self, limit):
        return _ik.IKoptions_setIterationsLimit(self, limit)

    def setFixInitialState(self, flag):
        return _ik.IKoptions_setFixInitialState(self, flag)

    def setq0(self, lb, ub):
        return _ik.IKoptions_setq0(self, lb, ub)

    def setqd0(self, lb, ub):
        return _ik.IKoptions_setqd0(self, lb, ub)

    def setqdf(self, lb, ub):
        return _ik.IKoptions_setqdf(self, lb, ub)

    def setAdditionaltSamples(self, t_samples):
        return _ik.IKoptions_setAdditionaltSamples(self, t_samples)

    def updateRobot(self, new_robot):
        return _ik.IKoptions_updateRobot(self, new_robot)

    def getQ(self, Q):
        return _ik.IKoptions_getQ(self, Q)

    def getQa(self, Qa):
        return _ik.IKoptions_getQa(self, Qa)

    def getQv(self, Qv):
        return _ik.IKoptions_getQv(self, Qv)

    def getDebug(self):
        return _ik.IKoptions_getDebug(self)

    def getSequentialSeedFlag(self):
        return _ik.IKoptions_getSequentialSeedFlag(self)

    def getMajorOptimalityTolerance(self):
        return _ik.IKoptions_getMajorOptimalityTolerance(self)

    def getMajorFeasibilityTolerance(self):
        return _ik.IKoptions_getMajorFeasibilityTolerance(self)

    def getSuperbasicsLimit(self):
        return _ik.IKoptions_getSuperbasicsLimit(self)

    def getMajorIterationsLimit(self):
        return _ik.IKoptions_getMajorIterationsLimit(self)

    def getIterationsLimit(self):
        return _ik.IKoptions_getIterationsLimit(self)

    def getAdditionaltSamples(self, additional_tSamples):
        return _ik.IKoptions_getAdditionaltSamples(self, additional_tSamples)

    def getFixInitialState(self):
        return _ik.IKoptions_getFixInitialState(self)

    def getq0(self, lb, ub):
        return _ik.IKoptions_getq0(self, lb, ub)

    def getqd0(self, lb, ub):
        return _ik.IKoptions_getqd0(self, lb, ub)

    def getqdf(self, lb, ub):
        return _ik.IKoptions_getqdf(self, lb, ub)
IKoptions_swigregister = _ik.IKoptions_swigregister
IKoptions_swigregister(IKoptions)

class IKResults(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    q_sol = _swig_property(_ik.IKResults_q_sol_get, _ik.IKResults_q_sol_set)
    info = _swig_property(_ik.IKResults_info_get, _ik.IKResults_info_set)
    infeasible_constraints = _swig_property(_ik.IKResults_infeasible_constraints_get, _ik.IKResults_infeasible_constraints_set)

    def __init__(self):
        this = _ik.new_IKResults()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_IKResults
    __del__ = lambda self: None
IKResults_swigregister = _ik.IKResults_swigregister
IKResults_swigregister(IKResults)


def InverseKin(model, q_seed, q_nom, constraint_array, ikoptions):
    return _ik.InverseKin(model, q_seed, q_nom, constraint_array, ikoptions)
InverseKin = _ik.InverseKin

def InverseKinPointwise(model, t, q_seed, q_nom, constraint_array, ikoptions):
    return _ik.InverseKinPointwise(model, t, q_seed, q_nom, constraint_array, ikoptions)
InverseKinPointwise = _ik.InverseKinPointwise

def InverseKinTraj(model, t, q_seed, q_nom, constraint_array, ikoptions):
    return _ik.InverseKinTraj(model, t, q_seed, q_nom, constraint_array, ikoptions)
InverseKinTraj = _ik.InverseKinTraj
class RigidBodyConstraint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    SingleTimeKinematicConstraintCategory = _ik.RigidBodyConstraint_SingleTimeKinematicConstraintCategory
    MultipleTimeKinematicConstraintCategory = _ik.RigidBodyConstraint_MultipleTimeKinematicConstraintCategory
    QuasiStaticConstraintCategory = _ik.RigidBodyConstraint_QuasiStaticConstraintCategory
    PostureConstraintCategory = _ik.RigidBodyConstraint_PostureConstraintCategory
    MultipleTimeLinearPostureConstraintCategory = _ik.RigidBodyConstraint_MultipleTimeLinearPostureConstraintCategory
    SingleTimeLinearPostureConstraintCategory = _ik.RigidBodyConstraint_SingleTimeLinearPostureConstraintCategory
    QuasiStaticConstraintType = _ik.RigidBodyConstraint_QuasiStaticConstraintType
    PostureConstraintType = _ik.RigidBodyConstraint_PostureConstraintType
    SingleTimeLinearPostureConstraintType = _ik.RigidBodyConstraint_SingleTimeLinearPostureConstraintType
    AllBodiesClosestDistanceConstraintType = _ik.RigidBodyConstraint_AllBodiesClosestDistanceConstraintType
    WorldEulerConstraintType = _ik.RigidBodyConstraint_WorldEulerConstraintType
    WorldGazeDirConstraintType = _ik.RigidBodyConstraint_WorldGazeDirConstraintType
    WorldGazeOrientConstraintType = _ik.RigidBodyConstraint_WorldGazeOrientConstraintType
    WorldGazeTargetConstraintType = _ik.RigidBodyConstraint_WorldGazeTargetConstraintType
    RelativeGazeTargetConstraintType = _ik.RigidBodyConstraint_RelativeGazeTargetConstraintType
    WorldCoMConstraintType = _ik.RigidBodyConstraint_WorldCoMConstraintType
    WorldPositionConstraintType = _ik.RigidBodyConstraint_WorldPositionConstraintType
    WorldPositionInFrameConstraintType = _ik.RigidBodyConstraint_WorldPositionInFrameConstraintType
    WorldQuatConstraintType = _ik.RigidBodyConstraint_WorldQuatConstraintType
    Point2PointDistanceConstraintType = _ik.RigidBodyConstraint_Point2PointDistanceConstraintType
    Point2LineSegDistConstraintType = _ik.RigidBodyConstraint_Point2LineSegDistConstraintType
    WorldFixedPositionConstraintType = _ik.RigidBodyConstraint_WorldFixedPositionConstraintType
    WorldFixedOrientConstraintType = _ik.RigidBodyConstraint_WorldFixedOrientConstraintType
    WorldFixedBodyPoseConstraintType = _ik.RigidBodyConstraint_WorldFixedBodyPoseConstraintType
    PostureChangeConstraintType = _ik.RigidBodyConstraint_PostureChangeConstraintType
    RelativePositionConstraintType = _ik.RigidBodyConstraint_RelativePositionConstraintType
    RelativeQuatConstraintType = _ik.RigidBodyConstraint_RelativeQuatConstraintType
    RelativeGazeDirConstraintType = _ik.RigidBodyConstraint_RelativeGazeDirConstraintType
    MinDistanceConstraintType = _ik.RigidBodyConstraint_MinDistanceConstraintType
    GravityCompensationTorqueConstraintType = _ik.RigidBodyConstraint_GravityCompensationTorqueConstraintType

    def getType(self):
        return _ik.RigidBodyConstraint_getType(self)

    def getCategory(self):
        return _ik.RigidBodyConstraint_getCategory(self)

    def getRobotPointer(self):
        return _ik.RigidBodyConstraint_getRobotPointer(self)
    __swig_destroy__ = _ik.delete_RigidBodyConstraint
    __del__ = lambda self: None
RigidBodyConstraint_swigregister = _ik.RigidBodyConstraint_swigregister
RigidBodyConstraint_swigregister(RigidBodyConstraint)
cvar = _ik.cvar

class QuasiStaticConstraint(RigidBodyConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_QuasiStaticConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_QuasiStaticConstraint
    __del__ = lambda self: None

    def isTimeValid(self, t):
        return _ik.QuasiStaticConstraint_isTimeValid(self, t)

    def getNumConstraint(self, t):
        return _ik.QuasiStaticConstraint_getNumConstraint(self, t)

    def eval(self, t, cache, weights, c, dc):
        return _ik.QuasiStaticConstraint_eval(self, t, cache, weights, c, dc)

    def bounds(self, t, lb, ub):
        return _ik.QuasiStaticConstraint_bounds(self, t, lb, ub)

    def name(self, t, name_str):
        return _ik.QuasiStaticConstraint_name(self, t, name_str)

    def isActive(self):
        return _ik.QuasiStaticConstraint_isActive(self)

    def getNumWeights(self):
        return _ik.QuasiStaticConstraint_getNumWeights(self)

    def addContact(self, *args):
        return _ik.QuasiStaticConstraint_addContact(self, *args)

    def setShrinkFactor(self, factor):
        return _ik.QuasiStaticConstraint_setShrinkFactor(self, factor)

    def setActive(self, flag):
        return _ik.QuasiStaticConstraint_setActive(self, flag)

    def updateRobot(self, robot):
        return _ik.QuasiStaticConstraint_updateRobot(self, robot)

    def updateRobotnum(self, model_instance_id_set):
        return _ik.QuasiStaticConstraint_updateRobotnum(self, model_instance_id_set)
QuasiStaticConstraint_swigregister = _ik.QuasiStaticConstraint_swigregister
QuasiStaticConstraint_swigregister(QuasiStaticConstraint)

class PostureConstraint(RigidBodyConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_PostureConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_PostureConstraint
    __del__ = lambda self: None

    def isTimeValid(self, t):
        return _ik.PostureConstraint_isTimeValid(self, t)

    def setJointLimits(self, *args):
        return _ik.PostureConstraint_setJointLimits(self, *args)

    def bounds(self, t, joint_min, joint_max):
        return _ik.PostureConstraint_bounds(self, t, joint_min, joint_max)
PostureConstraint_swigregister = _ik.PostureConstraint_swigregister
PostureConstraint_swigregister(PostureConstraint)

class MultipleTimeLinearPostureConstraint(RigidBodyConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ik.delete_MultipleTimeLinearPostureConstraint
    __del__ = lambda self: None

    def isTimeValid(self, t, n_breaks):
        return _ik.MultipleTimeLinearPostureConstraint_isTimeValid(self, t, n_breaks)

    def eval(self, t, n_breaks, q, c, dc):
        return _ik.MultipleTimeLinearPostureConstraint_eval(self, t, n_breaks, q, c, dc)

    def getNumConstraint(self, t, n_breaks):
        return _ik.MultipleTimeLinearPostureConstraint_getNumConstraint(self, t, n_breaks)

    def feval(self, t, n_breaks, q, c):
        return _ik.MultipleTimeLinearPostureConstraint_feval(self, t, n_breaks, q, c)

    def geval(self, t, n_breaks, iAfun, jAvar, A):
        return _ik.MultipleTimeLinearPostureConstraint_geval(self, t, n_breaks, iAfun, jAvar, A)

    def name(self, t, n_breaks, name_str):
        return _ik.MultipleTimeLinearPostureConstraint_name(self, t, n_breaks, name_str)

    def bounds(self, t, n_breaks, lb, ub):
        return _ik.MultipleTimeLinearPostureConstraint_bounds(self, t, n_breaks, lb, ub)
MultipleTimeLinearPostureConstraint_swigregister = _ik.MultipleTimeLinearPostureConstraint_swigregister
MultipleTimeLinearPostureConstraint_swigregister(MultipleTimeLinearPostureConstraint)

class SingleTimeLinearPostureConstraint(RigidBodyConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_SingleTimeLinearPostureConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_SingleTimeLinearPostureConstraint
    __del__ = lambda self: None

    def isTimeValid(self, t):
        return _ik.SingleTimeLinearPostureConstraint_isTimeValid(self, t)

    def getNumConstraint(self, t):
        return _ik.SingleTimeLinearPostureConstraint_getNumConstraint(self, t)

    def bounds(self, t, lb, ub):
        return _ik.SingleTimeLinearPostureConstraint_bounds(self, t, lb, ub)

    def feval(self, t, q, c):
        return _ik.SingleTimeLinearPostureConstraint_feval(self, t, q, c)

    def geval(self, t, iAfun, jAvar, A):
        return _ik.SingleTimeLinearPostureConstraint_geval(self, t, iAfun, jAvar, A)

    def eval(self, t, q, c, dc):
        return _ik.SingleTimeLinearPostureConstraint_eval(self, t, q, c, dc)

    def name(self, t, name_str):
        return _ik.SingleTimeLinearPostureConstraint_name(self, t, name_str)
SingleTimeLinearPostureConstraint_swigregister = _ik.SingleTimeLinearPostureConstraint_swigregister
SingleTimeLinearPostureConstraint_swigregister(SingleTimeLinearPostureConstraint)

class SingleTimeKinematicConstraint(RigidBodyConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ik.delete_SingleTimeKinematicConstraint
    __del__ = lambda self: None

    def isTimeValid(self, t):
        return _ik.SingleTimeKinematicConstraint_isTimeValid(self, t)

    def getNumConstraint(self, t):
        return _ik.SingleTimeKinematicConstraint_getNumConstraint(self, t)

    def eval(self, t, cache, c, dc):
        return _ik.SingleTimeKinematicConstraint_eval(self, t, cache, c, dc)

    def bounds(self, t, lb, ub):
        return _ik.SingleTimeKinematicConstraint_bounds(self, t, lb, ub)

    def name(self, t, name_str):
        return _ik.SingleTimeKinematicConstraint_name(self, t, name_str)

    def updateRobot(self, robot):
        return _ik.SingleTimeKinematicConstraint_updateRobot(self, robot)
SingleTimeKinematicConstraint_swigregister = _ik.SingleTimeKinematicConstraint_swigregister
SingleTimeKinematicConstraint_swigregister(SingleTimeKinematicConstraint)

class MultipleTimeKinematicConstraint(RigidBodyConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ik.delete_MultipleTimeKinematicConstraint
    __del__ = lambda self: None

    def isTimeValid(self, t, n_breaks):
        return _ik.MultipleTimeKinematicConstraint_isTimeValid(self, t, n_breaks)

    def getNumConstraint(self, t, n_breaks):
        return _ik.MultipleTimeKinematicConstraint_getNumConstraint(self, t, n_breaks)

    def eval(self, t, n_breaks, q, c, dc):
        return _ik.MultipleTimeKinematicConstraint_eval(self, t, n_breaks, q, c, dc)

    def eval_valid(self, valid_t, num_valid_t, valid_q, c, dc_valid):
        return _ik.MultipleTimeKinematicConstraint_eval_valid(self, valid_t, num_valid_t, valid_q, c, dc_valid)

    def bounds(self, t, n_breaks, lb, ub):
        return _ik.MultipleTimeKinematicConstraint_bounds(self, t, n_breaks, lb, ub)

    def name(self, t, n_breaks, name_str):
        return _ik.MultipleTimeKinematicConstraint_name(self, t, n_breaks, name_str)

    def updateRobot(self, robot):
        return _ik.MultipleTimeKinematicConstraint_updateRobot(self, robot)
MultipleTimeKinematicConstraint_swigregister = _ik.MultipleTimeKinematicConstraint_swigregister
MultipleTimeKinematicConstraint_swigregister(MultipleTimeKinematicConstraint)

class PositionConstraint(SingleTimeKinematicConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ik.delete_PositionConstraint
    __del__ = lambda self: None

    def eval(self, t, cache, c, dc):
        return _ik.PositionConstraint_eval(self, t, cache, c, dc)

    def bounds(self, t, lb, ub):
        return _ik.PositionConstraint_bounds(self, t, lb, ub)

    def name(self, t, name_str):
        return _ik.PositionConstraint_name(self, t, name_str)
PositionConstraint_swigregister = _ik.PositionConstraint_swigregister
PositionConstraint_swigregister(PositionConstraint)

class WorldPositionConstraint(PositionConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_WorldPositionConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_WorldPositionConstraint
    __del__ = lambda self: None
WorldPositionConstraint_swigregister = _ik.WorldPositionConstraint_swigregister
WorldPositionConstraint_swigregister(WorldPositionConstraint)

class WorldCoMConstraint(PositionConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_WorldCoMConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_WorldCoMConstraint
    __del__ = lambda self: None

    def updateRobotnum(self, model_instance_id):
        return _ik.WorldCoMConstraint_updateRobotnum(self, model_instance_id)
WorldCoMConstraint_swigregister = _ik.WorldCoMConstraint_swigregister
WorldCoMConstraint_swigregister(WorldCoMConstraint)

class RelativePositionConstraint(PositionConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, model, pts, lb, ub, bodyA_idx, bodyB_idx, bTbp, tspan):
        this = _ik.new_RelativePositionConstraint(model, pts, lb, ub, bodyA_idx, bodyB_idx, bTbp, tspan)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_RelativePositionConstraint
    __del__ = lambda self: None
RelativePositionConstraint_swigregister = _ik.RelativePositionConstraint_swigregister
RelativePositionConstraint_swigregister(RelativePositionConstraint)

class QuatConstraint(SingleTimeKinematicConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ik.delete_QuatConstraint
    __del__ = lambda self: None

    def eval(self, t, cache, c, dc):
        return _ik.QuatConstraint_eval(self, t, cache, c, dc)

    def bounds(self, t, lb, ub):
        return _ik.QuatConstraint_bounds(self, t, lb, ub)
QuatConstraint_swigregister = _ik.QuatConstraint_swigregister
QuatConstraint_swigregister(QuatConstraint)

class WorldQuatConstraint(QuatConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_WorldQuatConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_WorldQuatConstraint
    __del__ = lambda self: None

    def name(self, t, name_str):
        return _ik.WorldQuatConstraint_name(self, t, name_str)
WorldQuatConstraint_swigregister = _ik.WorldQuatConstraint_swigregister
WorldQuatConstraint_swigregister(WorldQuatConstraint)

class RelativeQuatConstraint(QuatConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_RelativeQuatConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def name(self, t, name_str):
        return _ik.RelativeQuatConstraint_name(self, t, name_str)
    __swig_destroy__ = _ik.delete_RelativeQuatConstraint
    __del__ = lambda self: None
RelativeQuatConstraint_swigregister = _ik.RelativeQuatConstraint_swigregister
RelativeQuatConstraint_swigregister(RelativeQuatConstraint)

class EulerConstraint(SingleTimeKinematicConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ik.delete_EulerConstraint
    __del__ = lambda self: None

    def eval(self, t, cache, c, dc):
        return _ik.EulerConstraint_eval(self, t, cache, c, dc)

    def bounds(self, t, lb, ub):
        return _ik.EulerConstraint_bounds(self, t, lb, ub)
EulerConstraint_swigregister = _ik.EulerConstraint_swigregister
EulerConstraint_swigregister(EulerConstraint)

class WorldEulerConstraint(EulerConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_WorldEulerConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_WorldEulerConstraint
    __del__ = lambda self: None

    def name(self, t, name_str):
        return _ik.WorldEulerConstraint_name(self, t, name_str)
WorldEulerConstraint_swigregister = _ik.WorldEulerConstraint_swigregister
WorldEulerConstraint_swigregister(WorldEulerConstraint)

class GazeConstraint(SingleTimeKinematicConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ik.delete_GazeConstraint
    __del__ = lambda self: None
GazeConstraint_swigregister = _ik.GazeConstraint_swigregister
GazeConstraint_swigregister(GazeConstraint)

class GazeOrientConstraint(GazeConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ik.delete_GazeOrientConstraint
    __del__ = lambda self: None

    def eval(self, t, cache, c, dc):
        return _ik.GazeOrientConstraint_eval(self, t, cache, c, dc)

    def bounds(self, t, lb, ub):
        return _ik.GazeOrientConstraint_bounds(self, t, lb, ub)
GazeOrientConstraint_swigregister = _ik.GazeOrientConstraint_swigregister
GazeOrientConstraint_swigregister(GazeOrientConstraint)

class WorldGazeOrientConstraint(GazeOrientConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_WorldGazeOrientConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_WorldGazeOrientConstraint
    __del__ = lambda self: None

    def name(self, t, name_str):
        return _ik.WorldGazeOrientConstraint_name(self, t, name_str)
WorldGazeOrientConstraint_swigregister = _ik.WorldGazeOrientConstraint_swigregister
WorldGazeOrientConstraint_swigregister(WorldGazeOrientConstraint)

class GazeDirConstraint(GazeConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ik.delete_GazeDirConstraint
    __del__ = lambda self: None

    def bounds(self, t, lb, ub):
        return _ik.GazeDirConstraint_bounds(self, t, lb, ub)
GazeDirConstraint_swigregister = _ik.GazeDirConstraint_swigregister
GazeDirConstraint_swigregister(GazeDirConstraint)

class WorldGazeDirConstraint(GazeDirConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_WorldGazeDirConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_WorldGazeDirConstraint
    __del__ = lambda self: None

    def eval(self, t, cache, c, dc):
        return _ik.WorldGazeDirConstraint_eval(self, t, cache, c, dc)

    def name(self, t, name_str):
        return _ik.WorldGazeDirConstraint_name(self, t, name_str)
WorldGazeDirConstraint_swigregister = _ik.WorldGazeDirConstraint_swigregister
WorldGazeDirConstraint_swigregister(WorldGazeDirConstraint)

class GazeTargetConstraint(GazeConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ik.delete_GazeTargetConstraint
    __del__ = lambda self: None

    def bounds(self, t, lb, ub):
        return _ik.GazeTargetConstraint_bounds(self, t, lb, ub)
GazeTargetConstraint_swigregister = _ik.GazeTargetConstraint_swigregister
GazeTargetConstraint_swigregister(GazeTargetConstraint)

class WorldGazeTargetConstraint(GazeTargetConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_WorldGazeTargetConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_WorldGazeTargetConstraint
    __del__ = lambda self: None

    def eval(self, t, cache, c, dc):
        return _ik.WorldGazeTargetConstraint_eval(self, t, cache, c, dc)

    def name(self, t, name_str):
        return _ik.WorldGazeTargetConstraint_name(self, t, name_str)
WorldGazeTargetConstraint_swigregister = _ik.WorldGazeTargetConstraint_swigregister
WorldGazeTargetConstraint_swigregister(WorldGazeTargetConstraint)

class RelativeGazeTargetConstraint(GazeTargetConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_RelativeGazeTargetConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_RelativeGazeTargetConstraint
    __del__ = lambda self: None

    def eval(self, t, cache, c, dc):
        return _ik.RelativeGazeTargetConstraint_eval(self, t, cache, c, dc)

    def name(self, t, name_str):
        return _ik.RelativeGazeTargetConstraint_name(self, t, name_str)
RelativeGazeTargetConstraint_swigregister = _ik.RelativeGazeTargetConstraint_swigregister
RelativeGazeTargetConstraint_swigregister(RelativeGazeTargetConstraint)

class RelativeGazeDirConstraint(GazeDirConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_RelativeGazeDirConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_RelativeGazeDirConstraint
    __del__ = lambda self: None

    def eval(self, t, cache, c, dc):
        return _ik.RelativeGazeDirConstraint_eval(self, t, cache, c, dc)

    def name(self, t, name_str):
        return _ik.RelativeGazeDirConstraint_name(self, t, name_str)
RelativeGazeDirConstraint_swigregister = _ik.RelativeGazeDirConstraint_swigregister
RelativeGazeDirConstraint_swigregister(RelativeGazeDirConstraint)

class Point2PointDistanceConstraint(SingleTimeKinematicConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_Point2PointDistanceConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_Point2PointDistanceConstraint
    __del__ = lambda self: None

    def eval(self, t, cache, c, dc):
        return _ik.Point2PointDistanceConstraint_eval(self, t, cache, c, dc)

    def name(self, t, name_str):
        return _ik.Point2PointDistanceConstraint_name(self, t, name_str)

    def bounds(self, t, lb, ub):
        return _ik.Point2PointDistanceConstraint_bounds(self, t, lb, ub)
Point2PointDistanceConstraint_swigregister = _ik.Point2PointDistanceConstraint_swigregister
Point2PointDistanceConstraint_swigregister(Point2PointDistanceConstraint)

class Point2LineSegDistConstraint(SingleTimeKinematicConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_Point2LineSegDistConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_Point2LineSegDistConstraint
    __del__ = lambda self: None

    def eval(self, t, cache, c, dc):
        return _ik.Point2LineSegDistConstraint_eval(self, t, cache, c, dc)

    def name(self, t, name_str):
        return _ik.Point2LineSegDistConstraint_name(self, t, name_str)

    def bounds(self, t, lb, ub):
        return _ik.Point2LineSegDistConstraint_bounds(self, t, lb, ub)
Point2LineSegDistConstraint_swigregister = _ik.Point2LineSegDistConstraint_swigregister
Point2LineSegDistConstraint_swigregister(Point2LineSegDistConstraint)

class WorldFixedPositionConstraint(MultipleTimeKinematicConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_WorldFixedPositionConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_WorldFixedPositionConstraint
    __del__ = lambda self: None

    def getNumConstraint(self, t, n_breaks):
        return _ik.WorldFixedPositionConstraint_getNumConstraint(self, t, n_breaks)

    def eval_valid(self, valid_t, num_valid_t, valid_q, c, dc_valid):
        return _ik.WorldFixedPositionConstraint_eval_valid(self, valid_t, num_valid_t, valid_q, c, dc_valid)

    def bounds(self, t, n_breaks, lb, ub):
        return _ik.WorldFixedPositionConstraint_bounds(self, t, n_breaks, lb, ub)

    def name(self, t, n_breaks, name_str):
        return _ik.WorldFixedPositionConstraint_name(self, t, n_breaks, name_str)
WorldFixedPositionConstraint_swigregister = _ik.WorldFixedPositionConstraint_swigregister
WorldFixedPositionConstraint_swigregister(WorldFixedPositionConstraint)

class WorldFixedOrientConstraint(MultipleTimeKinematicConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_WorldFixedOrientConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getNumConstraint(self, t, n_breaks):
        return _ik.WorldFixedOrientConstraint_getNumConstraint(self, t, n_breaks)
    __swig_destroy__ = _ik.delete_WorldFixedOrientConstraint
    __del__ = lambda self: None

    def eval_valid(self, valid_t, num_valid_t, valid_q, c, dc_valid):
        return _ik.WorldFixedOrientConstraint_eval_valid(self, valid_t, num_valid_t, valid_q, c, dc_valid)

    def bounds(self, t, n_breaks, lb, ub):
        return _ik.WorldFixedOrientConstraint_bounds(self, t, n_breaks, lb, ub)

    def name(self, t, n_breaks, name_str):
        return _ik.WorldFixedOrientConstraint_name(self, t, n_breaks, name_str)
WorldFixedOrientConstraint_swigregister = _ik.WorldFixedOrientConstraint_swigregister
WorldFixedOrientConstraint_swigregister(WorldFixedOrientConstraint)

class WorldFixedBodyPoseConstraint(MultipleTimeKinematicConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_WorldFixedBodyPoseConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_WorldFixedBodyPoseConstraint
    __del__ = lambda self: None

    def getNumConstraint(self, t, n_breaks):
        return _ik.WorldFixedBodyPoseConstraint_getNumConstraint(self, t, n_breaks)

    def eval_valid(self, valid_t, num_valid_t, valid_q, c, dc_valid):
        return _ik.WorldFixedBodyPoseConstraint_eval_valid(self, valid_t, num_valid_t, valid_q, c, dc_valid)

    def bounds(self, t, n_breaks, lb, ub):
        return _ik.WorldFixedBodyPoseConstraint_bounds(self, t, n_breaks, lb, ub)

    def name(self, t, n_breaks, name_str):
        return _ik.WorldFixedBodyPoseConstraint_name(self, t, n_breaks, name_str)
WorldFixedBodyPoseConstraint_swigregister = _ik.WorldFixedBodyPoseConstraint_swigregister
WorldFixedBodyPoseConstraint_swigregister(WorldFixedBodyPoseConstraint)

class AllBodiesClosestDistanceConstraint(SingleTimeKinematicConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_AllBodiesClosestDistanceConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_AllBodiesClosestDistanceConstraint
    __del__ = lambda self: None

    def updateRobot(self, robot):
        return _ik.AllBodiesClosestDistanceConstraint_updateRobot(self, robot)

    def eval(self, t, cache, c, dc):
        return _ik.AllBodiesClosestDistanceConstraint_eval(self, t, cache, c, dc)

    def name(self, t, name):
        return _ik.AllBodiesClosestDistanceConstraint_name(self, t, name)

    def bounds(self, t, lb, ub):
        return _ik.AllBodiesClosestDistanceConstraint_bounds(self, t, lb, ub)
AllBodiesClosestDistanceConstraint_swigregister = _ik.AllBodiesClosestDistanceConstraint_swigregister
AllBodiesClosestDistanceConstraint_swigregister(AllBodiesClosestDistanceConstraint)

class MinDistanceConstraint(SingleTimeKinematicConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_MinDistanceConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_MinDistanceConstraint
    __del__ = lambda self: None

    def eval(self, t, cache, c, dc):
        return _ik.MinDistanceConstraint_eval(self, t, cache, c, dc)

    def name(self, t, name):
        return _ik.MinDistanceConstraint_name(self, t, name)

    def scaleDistance(self, dist, scaled_dist, dscaled_dist_ddist):
        return _ik.MinDistanceConstraint_scaleDistance(self, dist, scaled_dist, dscaled_dist_ddist)

    def penalty(self, dist, cost, dcost_ddist):
        return _ik.MinDistanceConstraint_penalty(self, dist, cost, dcost_ddist)

    def bounds(self, t, lb, ub):
        return _ik.MinDistanceConstraint_bounds(self, t, lb, ub)
MinDistanceConstraint_swigregister = _ik.MinDistanceConstraint_swigregister
MinDistanceConstraint_swigregister(MinDistanceConstraint)

class WorldPositionInFrameConstraint(WorldPositionConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_WorldPositionInFrameConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_WorldPositionInFrameConstraint
    __del__ = lambda self: None
WorldPositionInFrameConstraint_swigregister = _ik.WorldPositionInFrameConstraint_swigregister
WorldPositionInFrameConstraint_swigregister(WorldPositionInFrameConstraint)

class PostureChangeConstraint(MultipleTimeLinearPostureConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_PostureChangeConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_PostureChangeConstraint
    __del__ = lambda self: None

    def getNumConstraint(self, t, n_breaks):
        return _ik.PostureChangeConstraint_getNumConstraint(self, t, n_breaks)

    def feval(self, t, n_breaks, q, c):
        return _ik.PostureChangeConstraint_feval(self, t, n_breaks, q, c)

    def geval(self, t, n_breaks, iAfun, jAvar, A):
        return _ik.PostureChangeConstraint_geval(self, t, n_breaks, iAfun, jAvar, A)

    def name(self, t, n_breaks, name_str):
        return _ik.PostureChangeConstraint_name(self, t, n_breaks, name_str)

    def bounds(self, t, n_breaks, lb, ub):
        return _ik.PostureChangeConstraint_bounds(self, t, n_breaks, lb, ub)
PostureChangeConstraint_swigregister = _ik.PostureChangeConstraint_swigregister
PostureChangeConstraint_swigregister(PostureChangeConstraint)

class GravityCompensationTorqueConstraint(SingleTimeKinematicConstraint):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _ik.new_GravityCompensationTorqueConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ik.delete_GravityCompensationTorqueConstraint
    __del__ = lambda self: None

    def eval(self, t, cache, c, dc):
        return _ik.GravityCompensationTorqueConstraint_eval(self, t, cache, c, dc)

    def name(self, t, name):
        return _ik.GravityCompensationTorqueConstraint_name(self, t, name)

    def bounds(self, t, lb, ub):
        return _ik.GravityCompensationTorqueConstraint_bounds(self, t, lb, ub)
GravityCompensationTorqueConstraint_swigregister = _ik.GravityCompensationTorqueConstraint_swigregister
GravityCompensationTorqueConstraint_swigregister(GravityCompensationTorqueConstraint)



