## Module: fusion
import array
#------ PRELUDE BEGIN
import threading
import mosek
import mosek.fusion
import mosek.array
import Utils
from Utils import OutputFileStream,Debug
from SolverInfo import SolverInfo


class BaseModel:
  _lock = threading.Lock()
  _global_env = None
  _global_env_counter = 0

  @classmethod
  def _globalEnv(self):
    self._lock.acquire()
    try:
      if BaseModel._global_env is None:
        try:
          env = mosek.Env()
          BaseModel._global_env = env
          BaseModel._global_env_counter += 1
        except mosek.Exception,e:
          raise UnexpectedError(e)
      return BaseModel._global_env
    finally:
      self._lock.release()

  def __init__(self,name,licfile):
    env = self._globalEnv()
    self.__modelname = name
    task = mosek.Task(self._global_env, 0, 0);
    finished = False
    try:
      task.putintparam(mosek.iparam.log_expand,0);
      self.__task = task
      if name is not None:
        task.puttaskname(name)
        

      self._synched = SolutionStatus.Optimal;

      self.__vars = []
      self.__cons = []

      self.__varNameMap = {}
      self.__conNameMap = {}

      self._sol_itr = None
      self._sol_bas = None
      self._sol_itg = None

      self.__objname = None
      self.__objexpr = None

      # handler for log output.
      def loghandler(text):
        if self.__logwriter is not None:
          self.__logwriter.write(text)
          self.__logwriter.flush()
      self.__logwriter = loghandler

      task.set_Stream(mosek.streamtype.log,loghandler)
      finished = True
    finally:
      if not finished:
        self.__task.__del__()
        self.__task = None
        BaseModel._global_env_counter -= 1

  def __del__(self):
    if self.__task is not None:
      self._lock.acquire()
      try:
        task = self.__task
        self.__task = None
        BaseModel._global_env_counter -= 1
        task.__del__()
        
        ignore_attrs = frozenset(['__del__','_lock','_BaseModel__task'] + dir(self.__class__))
        for a in set(dir(self)) - ignore_attrs:
          setattr(self,a,None)
      except Exception,e:
        import traceback
        traceback.print_exc()
        print e

      finally:
        self._lock.release()
  def __enter__(self):
    return self
  def __exit__(self,exc_type,exc_val,exc_tb):
    self.__del__()


  def _task_1setLogHandler_OStreamWriter_2(self,handler):
    """
    Set the object to handle log output from the solver.

    The handler object must have a write method accepting a string.
    """
    self.__logwriter = handler
  def _hasVariable_S (self,name):
    return name is not None and self.__varNameMap.has_key(name)
  def _hasConstraint_S (self,name):
    return name is not None and self.__conNameMap.has_key(name)  
  def _addVariable_SOmosek_fusion_Variable_2(self,name,x):
    self.__vars.append(x)
    if name is not None:
      self.__varNameMap[name] = x
  def _addConstraint_SOmosek_fusion_Constraint_2(self,name,c):
    self.__cons.append(c)
    if name is not None:
      self.__conNameMap[name] = c 

  def _get_1constraint_S(self,name):
    return self.__conNameMap.get(name,None)
  def _get_1variable_S(self,name):
    return self.__varNameMap.get(name,None)

  #def _task_1put_1param_SF(self,name,value):
  #  self.__task.putnadouparam(name,value)
  #def _task_1put_1param_SS(self,name,value):
  #  self.__task.putnastrparam(name,value)
  #def _task_1put_1param_SI(self,name,value):
  #  self.__task.putnaintaram(name,value)

  def _task_1put_1param_SS(self,name,value):
    self.__task.putnastrparam(name,value)
  def _task_1put_1param_SF(self,name,value):
    self.__task.putnadouparam(name,value)
  def _task_1put_1param_SI(self,name,value):
    self.__task.putnaintparam(name,value)

  def _task_1get_1dinf_S(self,name):
    key = SolverInfo._getdouinf(name)
    if key is None:
      raise NameError("Invalid double info name '%s'" % name)
    else:
      return self.__task.getdouinf(key)
  def _task_1get_1iinf_S(self,name):
    key = SolverInfo._getintinf(name)
    if key is None:
      raise NameError("Invalid integer info name '%s'" % name)
    else:
      return self.__task.getintinf(key)
  def _task_1get_1liinf_S(self,name):
    key = SolverInfo._getlintinf(name)
    if key is None:
      raise NameError("Invalid long integer info name '%s'" % name)
    else:
      return self.__task.getlintinf(key)

  def _numVariables_ (self):
    return len(self.__vars)
  def _numConstraints_ (self):
    return len(self.__cons)
  
  def _alloc_1rangedvar_SFF(self,name,lb,ub):
    n = self.__task.getnumvar()
    self.__task.appendvars(1)
    if name is not None:
        self.__task.putvarname(n,name)
    self.__task.putbound(mosek.accmode.var, n, mosek.boundkey.ra, lb, ub)
    return n
  
  def _alloc_1linearvar_SOmosek_fusion_RelationKey_2F(self,name,relkey,bnd):
    task = self.__task
    n = task.getnumvar();
    task.appendvars(1)
    if name is not None:
        task.putvarname(n,name)

    if   relkey is RelationKey.IsFree:
      task.putbound(mosek.accmode.var, n, mosek.boundkey.fr, 0.0, 0.0)
    elif relkey is RelationKey.LessThan:
      task.putbound(mosek.accmode.var, n, mosek.boundkey.up, 0.0, bnd)
    elif relkey is RelationKey.GreaterThan:
      task.putbound(mosek.accmode.var, n, mosek.boundkey.lo, bnd, 0.0)
    else:
      task.putbound(mosek.accmode.var, n, mosek.boundkey.fx, bnd, bnd)
    return n

  def _task_1con_1name_IS(self,idx,name):
    self.__task.putconname(idx,name)
  def _task_1var_1name_IS(self,idx, name):
    self.__task.putvarname(idx,name)
  
  def _task_1cone_1name_IS(self,idx,name):
    self.__task.putconename(idx,name)

  def _task_1numcon_(self):
    return self.__task.getnumcon()
  def _task_1numvar_(self):
    return self.__task.getnumvar()
  def _task_1numcone_(self):
    return self.__task.getnumcone()
  
  def __task_putboundslice(self,acc,first,last,bl,bu,bk):  
    num = last-first
    if bl == None: bl = mosek.array.zeros(num,float)
    if bu is None: bu = mosek.array.zeros(num,float)
    
    bka = [bk] * num
    self.__task.putboundslice(acc,first,last,bka,bl,bu)
  

  def __task_putboundlist(self,acc,idxs,bl,bu,bk):
    num = len(idxs)
    if bl is None: bl = mosek.array.zeros(num,float)
    if bu is None: bu = mosek.array.zeros(num,float)

    bka = [bk] * num
    self.__task.putboundlist(acc,idxs,bka,bl,bu)
  
  def _task_1con_1putboundslice_1fx_II_3F(self,first, last, rhs):
    self.__task_putboundslice(mosek.accmode.con, first, last, rhs, rhs, mosek.boundkey.fx);
  
  def _task_1con_1putboundslice_1lo_II_3F(self,first, last, rhs):
    self.__task_putboundslice(mosek.accmode.con, first, last, rhs, rhs, mosek.boundkey.lo);
  
  def _task_1con_1putboundslice_1up_II_3F(self,first, last, rhs):
    self.__task_putboundslice(mosek.accmode.con, first, last, rhs, rhs, mosek.boundkey.up);
  
  def _task_1con_1putboundslice_1ra_II_3F_3F(self,first, last, lb, ub):
    self.__task_putboundslice(mosek.accmode.con, first, last, lb, ub, mosek.boundkey.ra);
  
  def _task_1con_1putboundslice_1fr_II(self,first, last):
    self.__task_putboundslice(mosek.accmode.con, first, last, None, None, mosek.boundkey.fr);
  
  def _task_1var_1putboundslice_1fx_II_3F(self,first, last, rhs):
    self.__task_putboundslice(mosek.accmode.var, first, last, rhs, rhs, mosek.boundkey.fx);
  
  def _task_1var_1putboundslice_1lo_II_3F(self,first, last, rhs):
    self.__task_putboundslice(mosek.accmode.var, first, last, rhs, rhs, mosek.boundkey.lo);
  
  def _task_1var_1putboundslice_1up_II_3F(self,first, last, rhs):
    self.__task_putboundslice(mosek.accmode.var, first, last, rhs, rhs, mosek.boundkey.up);
  
  def _task_1var_1putboundslice_1ra_II_3F_3F(self,first, last, lb, ub):
    self.__task_putboundslice(mosek.accmode.var, first, last, lb, ub, mosek.boundkey.ra);

  def _task_1var_1putboundslice_1fr_II(self,first, last):
    self.__task_putboundslice(mosek.accmode.var, first, last, None, None, mosek.boundkey.fr);
                                                                  
  def _task_1con_1putboundlist_1fx__3I_3F(self,idxs, rhs):
    self.__task_putboundlist(mosek.accmode.con, idxs, rhs, rhs, mosek.boundkey.fx);
  
  def _task_1con_1putboundlist_1lo__3I_3F(self,idxs, rhs):
    self.__task_putboundlist(mosek.accmode.con, idxs, rhs, rhs, mosek.boundkey.lo);
  
  def _task_1con_1putboundlist_1up__3I_3F(self,idxs, rhs):
    self.__task_putboundlist(mosek.accmode.con, idxs, rhs, rhs, mosek.boundkey.up);
  
  def _task_1con_1putboundlist_1ra__3I_3F_3F(self,idxs, lb, ub):
    self.__task_putboundlist(mosek.accmode.con, idxs, lb, ub, mosek.boundkey.ra);

  def _task_1var_1putintlist__3I(self,idxs):
    self.__task.putvartypelist(idxs,[mosek.variabletype.type_int] * len(idxs))
  
  
  def _task_1task_1optimize_ (self):
    try:
      self.__task.optimize()
      self.__task.solutionsummary(streamtype.log)
    except mosek.Error, e:
      raise OptimizeError("Error occurred while optimizeing")
    except mosek.Warning,e:
      pass
  
  def __task_appendvars(self,num):
    idx = self.__task.getnumvar()
    self.__task.appendvars(num)
    return idx

  def __task_appendcons(self,num):
    idx = self.__task.getnumcon()
    self.__task.appendcons(num)
    return idx

  def __task_appendcones(self,ct,conesize,first,num):
    idx = self.__task.getnumcone()
    cts = [ct]       * num
    cps = [0.0]      * num
    csz = [conesize] * num
    self.__task.appendconesseq(cts,cps,csz,first)
    return idx
  
  def _task_1append_1var_I(self,num):
    return self.__task_appendvars(num)

  def _task_1append_1con_I(self,num):
    return self.__task_appendcons(num)

  def _task_1append_1quadcone_III(self,conesize,first,num):
    return self.__task_appendcones(mosek.conetype.quad, conesize, first,num);

  def _task_1append_1rquadcone_III(self,conesize,first,num):
    return self.__task_appendcones(mosek.conetype.rquad, conesize, first,num)
  
  def _task_1putarowslice_II_3L_3I_3F(self,first, last, ptrb, subj, cof):
    num   = last-first
    sub   = range(first,last)
    self.__task.putarowlist(sub, ptrb[:-1], ptrb[1:], subj, cof);

  def _task_1putaijlist__3I_3I_3FL(self,subi,subj,cof,num):
    self.__task.putaijlist(subi[:num],subj[:num],cof[:num])
  
  def _task_1putobjectivename_S(self,name):
    self.__task.putobjname("" if name is None else name)
    
  def _task_1putobjective_B_3I_3FF(self,maximize,subj,cof,cfix):
    c = mosek.array.zeros(self.__task.getnumvar(),mosek.array.float64)
    idxs = range(len(c))
    for i in xrange(len(subj)):
      c[subj[i]] += cof[i]
    self.__task.putclist(idxs,c)
    self.__task.putcfix(cfix)
    self.__task.putobjsense(mosek.objsense.maximize if maximize else mosek.objsense.minimize)
  
  


  def _task_1putbaraij_III(self,i,j,k):
    self.__task.putbaraij(i,j,[k], [1.0])
  def _task_1putbarcj_II(self,j,k):
    self.__task.putbarcj(j,[k],[1.0])
  
  def _task_1putbaraij_II_3I(self,i,j,k):
    self.__task.putbaraij(i,j,k, [1.0]*len(k))
  def _task_1putbarcj_I_3I(self,j,k):
    self.__task.putbarcj(j,k,[1.0]*len(k))

  def _task_1append_1barmatrix_I_3I_3I_3F(self,dim,subi, subj, cof):
    return self.__task.appendsparsesymmat(dim,subi,subj,cof)

  def _task_1barvardim_I(self,index):
    return self.__task.getdimbarvarj(index)

  def _task_1numbarvar_(self):
    return self.__task.getnumbarvar()

  def _task_1barvar_1name_IS(self, idx, name):
    self.__task.putbarvarname(idx,name)

  def _task_1append_1barvar_II(self,size, num):
    res = self.__task.getnumbarvar()
    self.__task.appendbarvars([size] * num)
    return res

  def _task_1cleanup_IIII(self,inumvar,inumcon,inumcone,inumbarvar):
    numvar  = self.__task.getnumvar()
    numcon  = self.__task.getnumcon()
    numcone = self.__task.getnumcone()
    numbarvar = self.__task.getnumbarvar()

    if inumcone < numcone:
      self.__task.removecones(range(inumcone,numcone))

    if inumvar < numvar:
      idxs = range(inumvar,numvar)
      self.__task.removevars(idxs)
    
    if (inumcon < numcon):
      idxs = range(inumcon,numcon)
      self.__task.removecons(idxs)

    if (inumbarvar < numbarvar):
      self.__task.removebarvars(range(inumbarvar,numbarvar))
    
  @staticmethod
  def __convertSolutionStatus(soltype,sol,status):
    pd = { 
        mosek.solsta.optimal :                    SolutionStatus.Optimal,
        mosek.solsta.near_optimal :               SolutionStatus.NearOptimal,
        mosek.solsta.integer_optimal :            SolutionStatus.Optimal,
        mosek.solsta.near_integer_optimal :       SolutionStatus.NearOptimal,
        mosek.solsta.prim_and_dual_feas :         SolutionStatus.Feasible,
        mosek.solsta.near_prim_and_dual_feas :    SolutionStatus.NearFeasible,
        mosek.solsta.prim_feas :                  SolutionStatus.Feasible,
        mosek.solsta.near_prim_feas :             SolutionStatus.NearFeasible,
        mosek.solsta.dual_feas :                  SolutionStatus.Unknown,
        mosek.solsta.near_dual_feas :             SolutionStatus.Unknown,
        mosek.solsta.prim_infeas_cer :            SolutionStatus.Unknown,
        mosek.solsta.near_prim_infeas_cer :       SolutionStatus.Unknown,
        mosek.solsta.near_dual_infeas_cer :       SolutionStatus.Certificate,
        mosek.solsta.dual_infeas_cer :            SolutionStatus.NearCertificate }

    dd = {
        mosek.solsta.optimal :                    SolutionStatus.Optimal,
        mosek.solsta.near_optimal :               SolutionStatus.NearOptimal,
        mosek.solsta.integer_optimal :            SolutionStatus.Unknown, 
        mosek.solsta.near_integer_optimal :       SolutionStatus.Unknown, 
        mosek.solsta.prim_and_dual_feas :         SolutionStatus.Feasible, 
        mosek.solsta.near_prim_and_dual_feas :    SolutionStatus.NearFeasible, 
        mosek.solsta.prim_feas :                  SolutionStatus.Unknown, 
        mosek.solsta.near_prim_feas :             SolutionStatus.Unknown, 
        mosek.solsta.dual_feas :                  SolutionStatus.Feasible, 
        mosek.solsta.near_dual_feas :             SolutionStatus.NearFeasible, 
        mosek.solsta.prim_infeas_cer :            SolutionStatus.Certificate, 
        mosek.solsta.near_prim_infeas_cer :       SolutionStatus.NearCertificate, 
        mosek.solsta.near_dual_infeas_cer :       SolutionStatus.Unknown, 
        mosek.solsta.dual_infeas_cer :            SolutionStatus.Unknown }

    sol.pstatus = pd.get(status,SolutionStatus.Unknown)
    sol.dstatus = dd.get(status,SolutionStatus.Unknown)

  @staticmethod
  def _matchargs_task_1write_S(self,*args):
      return True
  def _task_1write_S(self,filename):
      self.__task.putintparam(mosek.iparam.opf_write_solutions, 1)
      self.__task.putintparam(mosek.iparam.write_ignore_incompatible_items, 1)
      self.__task.writedata(filename)
  
  def _task_1write(self,filename):
    return self._writeProblem_S(filename)
  
      
  @staticmethod
  def _matchargs_task_1solve_(self,*args):
    return True
  def _task_1solve_(self):
    task = self.__task
    ok = False
    try:
      trmcode = mosek.rescode.ok
      try:
        trmcode = task.optimize()
      except mosek.Error,e:
        raise OptimizeError(e.message)
      except mosek.Warning,e:
        pass
      
      numcon  = task.getnumcon()
      numvar  = task.getnumvar()
      numcone = task.getnumcone()
      numbarvar = task.getnumbarvar()
      
      sol_bas_def = 0 != task.solutiondef(mosek.soltype.bas)
      sol_itr_def = 0 != task.solutiondef(mosek.soltype.itr)
      sol_itg_def = 0 != task.solutiondef(mosek.soltype.itg)

      self._sol_itr = None
      self._sol_bas = None
      self._sol_itg = None 


      if sol_itr_def:
        self._sol_itr = SolutionStruct(numvar,numcon,numcone,numbarvar)
        sol_itr = self._sol_itr
        prosta,solsta = task.getsolution(
          mosek.soltype.itr,
          #sol_itr.skc,sol_itr.skx,sol_itr.skn,
          None,None,None,
          sol_itr.xc,sol_itr.xx,sol_itr.y,
          sol_itr.slc,sol_itr.suc,
          sol_itr.slx,sol_itr.sux,
          sol_itr.snx)
        for j in xrange(numbarvar):
          barxjdim = task.getdimbarvarj(j)
          self._sol_itr.barx[j] = [ 0.0 ] * (barxjdim * (barxjdim + 1) / 2)
          self._sol_itr.bars[j] = [ 0.0 ] * (barxjdim * (barxjdim + 1) / 2)
          task.getbarxj(mosek.soltype.itr, j, self._sol_itr.barx[j])
          task.getbarsj(mosek.soltype.itr, j, self._sol_itr.bars[j])

        sol_itr.pobj = task.getprimalobj(mosek.soltype.itr)
        sol_itr.dobj = task.getdualobj  (mosek.soltype.itr)
        self.__convertSolutionStatus(mosek.soltype.itr, sol_itr, solsta);
        #print "got itr sol, stat = %s/%s" % (sol_itr.pstatus,sol_itr.dstatus)

      if sol_bas_def:
        self._sol_bas = SolutionStruct(numvar,numcon,numcone,numbarvar);
        sol_bas = self._sol_bas
        prosta,solsta = task.getsolution(
          mosek.soltype.bas,
          #sol_bas.skc,sol_bas.skx,sol_bas.skn,
          None,None,None,
          sol_bas.xc,sol_bas.xx,sol_bas.y,
          sol_bas.slc,sol_bas.suc,
          sol_bas.slx,sol_bas.sux,
          sol_bas.snx)
        
        # NOTE: this probably never happens:
        for j in xrange(numbarvar):
          barxjdim = task.getdimbarvarj(j)
          self._sol_bas.barx[j] = [ 0.0 ] * (barxjdim * (barxjdim + 1) / 2)
          self._sol_bas.bars[j] = [ 0.0 ] * (barxjdim * (barxjdim + 1) / 2)
          task.getbarxj(mosek.soltype.bas, j, self._sol_bas.barx[j])
          task.getbarsj(mosek.soltype.bas, j, self._sol_bas.bars[j])

        sol_bas.pobj = task.getprimalobj(mosek.soltype.bas)
        sol_bas.dobj = task.getdualobj  (mosek.soltype.bas)
        self.__convertSolutionStatus(mosek.soltype.bas, sol_bas, solsta);

        #print "got bas sol, stat = %s/%s" % (sol_bas.pstatus,sol_bas.dstatus)

      if sol_itg_def:
        self._sol_itg = SolutionStruct(numvar,numcon,numcone,numbarvar);
        sol_itg = self._sol_itg
        prosta,solsta = task.getsolution(
          mosek.soltype.itg,
          #sol_itg.skc,sol_itg.skx,sol_itg.skn,
          None,None,None,
          sol_itg.xc,sol_itg.xx,sol_itg.y,
          sol_itg.slc,sol_itg.suc,
          sol_itg.slx,sol_itg.sux,
          sol_itg.snx)

        # NOTE: this probably wont happen for a long time:
        for j in xrange(numbarvar):
          barxjdim = task.getdimbarvarj(j)
          self._sol_itg.barx[j] = [ 0.0 ] * (barxjdim * (barxjdim + 1) / 2)
          self._sol_itg.bars[j] = [ 0.0 ] * (barxjdim * (barxjdim + 1) / 2)
          task.getbarxj(mosek.soltype.itg, j, self._sol_itg.barx[j])
          task.getbarsj(mosek.soltype.itg, j, self._sol_itg.bars[j])

        sol_itg.pobj = task.getprimalobj(mosek.soltype.itg)
        self.__convertSolutionStatus(mosek.soltype.itg, sol_itg, solsta);
      ok = True
    
    finally:
      if not ok: # means exception
        self._sol_itr = None
        self._sol_bas = None
        self._sol_itg = None


#------ PRELUDE END

def _argtypestr(a):
  if     isinstance(a,bool): return 'bool'
  elif   isinstance(a,int): return 'int'
  elif   isinstance(a,long): return 'long'
  elif   isinstance(a,float): return 'float'
  elif   isinstance(a,basestring): return 'string'
  elif   isinstance(a,list): 
    if len(a) > 0:
      return '[%s]' % _argtypestr(a[0])
    else: 
      return '[]'
  else:  return a.__class__.__name__
def _cliptrace(f):
  def _(*args):
    try:
      return f(*args)
    except Exception,e:
      import sys
      if hasattr(e,'_internal_trace'):
        e._internal_trace.append(sys.exc_info()[2])
      else:
        e._internal_trace = [ sys.exc_info()[2] ]
      raise e
  _.__name__ = f.__name__
  return _
_cliptrace = lambda f:f
##origin: src/fusion/StatusKey.mbi(16:11-22:5)
StatusKey = mosek.Enum("StatusKey",[
    "Unknown",
    "Basic",
    "SuperBasic",
    "OnBound",
    "Infinity" ])


##origin: src/fusion/SolutionType.mbi(14:11-19:5)
SolutionType = mosek.Enum("SolutionType",[
    "Default",
    "Basic",
    "Interior",
    "Integer" ])


##origin: src/fusion/SolutionStatus.mbi(47:11-53:5)
AccSolutionStatus = mosek.Enum("AccSolutionStatus",[
    "Anything",
    "Optimal",
    "NearOptimal",
    "Feasible",
    "Certificate" ])


##origin: src/fusion/domain.mbi(8:11-16:5)
RelationKey = mosek.Enum("RelationKey",[
    "EqualsTo",
    "LessThan",
    "GreaterThan",
    "IsFree",
    "InQCone",
    "InRotatedQCone",
    "InRange" ])


##origin: src/fusion/ObjectiveSense.mbi(14:11-18:5)
ObjectiveSense = mosek.Enum("ObjectiveSense",[
    "Undefined",
    "Minimize",
    "Maximize" ])


##origin: src/fusion/domain.mbi(19:11-23:5)
PSDKey = mosek.Enum("PSDKey",[
    "IsSymPSD",
    "IsTrilPSD",
    "IsLinPSD" ])


##origin: src/fusion/SolutionStatus.mbi(23:11-36:5)
SolutionStatus = mosek.Enum("SolutionStatus",[
    "Undefined",
    "Unknown",
    "Optimal",
    "NearOptimal",
    "Feasible",
    "NearFeasible",
    "Certificate",
    "NearCertificate" ])


## origin: src/fusion/Variable.mbi(74:5-1234:5)
class Variable:
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,mosek.fusion.Set) @ src/fusion/Variable.mbi(87:15-94:7)")
  def __constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,m,shape_):
    self._model = m
    self.shape = shape_
    self._shape_p = self.shape
  def __init__(self,*args):
    #self.shape = None

    #self._protected_shape_p = None

    #self._protected_model = None

    self.__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(*args)
  @staticmethod
  def _matchargs_reduceDims_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(98:16-108:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("reduceDims()")
  def __reduceDims_(self):
    if   (self.shape.nd > 1):
      ndim = ( self.shape._realnd_() )

      d = ([ 0 for _autovar_0 in xrange(ndim) ])

      d[0] = 1
      # { @ src/fusion/Variable.mbi(103:11-111)
      j = 0

      # src/fusion/Variable.mbi(103:24-109)
      i = 0

      while (i < ndim):
        if   (( self.shape._dim_I(i) ) > 1):
          d[j] = ( self.shape._dim_I(i) )
          j += 1
        i += 1
      # } @ src/fusion/Variable.mbi(103:11-111)
      self.shape = mosek.fusion.NDSet(d)
      self._shape_p = self.shape
    return self
  @staticmethod
  def _matchargs_asExpr_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(122:15-128:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("asExpr()")
  def _asExpr_(self):
    ptrb = ( Utils.Tools._range_LL (0l,(1l + ( self._size_() ))) )

    subj = ( Utils.Tools._range_LL (0l,( self._size_() )) )

    cof = ( Utils.Tools._ones_I (int(( self._size_() ))) )

    return mosek.fusion.Expr(ptrb,self,subj,cof,None,self.shape,None,1)
  @staticmethod
  def _matchargs_flatten_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(133:18-135:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("flatten()")
  def _flatten_(self):
    return ( Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2 (self,mosek.fusion.IntSet(int(self.shape._size))) )
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(151:15-153:9)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    pass
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(170:15-172:9)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int],[int])")
  def _slice__3I_3I(self,first,last):
    pass
  @staticmethod
  def _matchargs_index_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Variable.mbi(179:15-181:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index(int)")
  def _index_I(self,i0):
    return ( self._slice_II(i0,(i0 + 1)) )
  @staticmethod
  def _matchargs_index_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(188:15-190:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index(int,int)")
  def _index_II(self,i0,i1):
    return ( self._slice__3I_3I(([ i0,i1]),([ (i0 + 1),(i1 + 1)])) )
  @staticmethod
  def _matchargs_index_III(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    return True
  # origin: src/fusion/Variable.mbi(197:15-201:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index(int,int,int)")
  def _index_III(self,i0,i1,i2):
    return ( self._slice__3I_3I(([ i0,i1,i2]),([ (i0 + 1),(i1 + 1),(i2 + 1)])) )
  @staticmethod
  def _matchargs_index__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(212:15-216:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index([int])")
  def _index__3I(self,idx):
    idxplusone = ( Utils.Tools._arraycopy__3I (idx) )

    # src/fusion/Variable.mbi(214:9-50)
    for i in xrange(0,int(len(idx))):
      idxplusone[i] += 1
    return ( ( self._slice__3I_3I(idx,idxplusone) ).__reduceDims_() )
  @staticmethod
  def _matchargs_symmetric_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(243:15-257:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("symmetric(mosek.fusion.Variable)")
  def _symmetric_Omosek_fusion_Variable_2(v):
    _autovar_1 = v
    if   isinstance(_autovar_1,mosek.fusion.PSDVariable):
      w = _autovar_1
      return w
    elif isinstance(_autovar_1,mosek.fusion.SymmetricVariable):
      w = _autovar_1
      return w
    else:
      w = _autovar_1
      return mosek.fusion.SymmetricVariable(w)
  @staticmethod
  def _matchargs_dstack__3Omosek_fusion_Variable_2I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(261:18-294:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dstack([mosek.fusion.Variable],int)")
  def _dstack__3Omosek_fusion_Variable_2I(v,dim):
    n = int(len(v))

    nd = (dim + 1)

    # src/fusion/Variable.mbi(268:27-271:14)
    for i in xrange(0,n):
      if   (v[i].shape.nd > nd):
        nd = v[i].shape.nd
    rdims = ([ 0 for _autovar_2 in xrange(nd) ])

    # src/fusion/Variable.mbi(271:9-68)
    for i in xrange(0,v[0].shape.nd):
      rdims[i] = ( v[0].shape._dim_I(i) )
    # src/fusion/Variable.mbi(272:9-53)
    for i in xrange(v[0].shape.nd,nd):
      rdims[i] = 1
    rv = ([ None for _autovar_3 in xrange(n) ])

    rv[0] = ( Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2 (v[0],mosek.fusion.NDSet(rdims)) )
    # src/fusion/Variable.mbi(278:9-291:9)
    for i in xrange(1,n):
      # { @ src/fusion/Variable.mbi(279:9-291:9)
      # src/fusion/Variable.mbi(280:11-287:18)
      for j in xrange(0,nd):
        if   (j != dim):
          if   (( v[i].shape._dim_I(j) ) != rdims[j]):
            raise mosek.fusion.DimensionError("Variable dimensions do not match")
      rdims[dim] = ( v[i].shape._dim_I(dim) )
      if   (v[i].shape.nd == nd):
        rv[i] = v[i]
      else:
        rv[i] = ( Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2 (v[i],mosek.fusion.NDSet(rdims)) )
      # } @ src/fusion/Variable.mbi(279:9-291:9)
    return mosek.fusion.CompoundVariable(rv,dim)
  @staticmethod
  def _matchargs_hstack__3Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(310:15-313:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("hstack([mosek.fusion.Variable])")
  def _hstack__3Omosek_fusion_Variable_2(v):
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (v,1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(332:15-336:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,mosek.fusion.Variable)")
  def _hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(v0,v1):
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (([ v0,v1]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(354:15-359:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)")
  def _hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(v0,v1,v2):
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (([ v0,v1,v2]),1) )
  @staticmethod
  def _matchargs_vstack__3Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(375:15-378:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("vstack([mosek.fusion.Variable])")
  def _vstack__3Omosek_fusion_Variable_2(v):
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (v,0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(397:15-401:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,mosek.fusion.Variable)")
  def _vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(v0,v1):
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (([ v0,v1]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(419:15-424:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)")
  def _vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(v0,v1,v2):
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (([ v0,v1,v2]),0) )
  @staticmethod
  def _matchargs_stack__3_3Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not isinstance(a,mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(467:15-505:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("stack([[mosek.fusion.Variable]])")
  def _stack__3_3Omosek_fusion_Variable_2(vlist):
    tmp = ([ None for _autovar_4 in xrange(int(len(vlist))) ])

    # src/fusion/Variable.mbi(471:9-499:11)
    for i in xrange(0,int(len(vlist))):
      if   (int(len(vlist[i])) == 1):
        v = vlist[i][0]

        if   (v.shape.nd == 1):
          tmp[i] = ( Variable._reshape_Omosek_fusion_Variable_2II (v,( v.shape._dim_I(0) ),1) )
        else:
          tmp[i] = v
      else:
        rowlen = 0

        # src/fusion/Variable.mbi(483:13-486:18)
        j = 0

        while (j < int(len(vlist[i]))):
          if   (vlist[i][j].shape._size > 0):
            rowlen += 1
          j += 1
        vrow = ([ None for _autovar_5 in xrange(rowlen) ])

        k = 0

        # src/fusion/Variable.mbi(486:24-497:13)
        j = 0

        while (j < int(len(vlist[i]))):
          v = vlist[i][j]

          if   (v.shape._size > 0):
            if   (v.shape.nd == 1):
              vrow[k] = ( Variable._reshape_Omosek_fusion_Variable_2II (v,( v.shape._dim_I(0) ),1) )
            else:
              vrow[k] = v
            k += 1
          j += 1
        tmp[i] = mosek.fusion.CompoundVariable(vrow,1)
    if   (int(len(tmp)) == 1):
      return tmp[0]
    else:
      return mosek.fusion.CompoundVariable(tmp,0)
  @staticmethod
  def _matchargs_repeat_Omosek_fusion_Variable_2I(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(519:15-529:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("repeat(mosek.fusion.Variable,int)")
  def _repeat_Omosek_fusion_Variable_2I(v,num):
    if   (num <= 0):
      return mosek.fusion.SliceVariable(v,mosek.fusion.IntSet(0),0l,([ 0l for _autovar_6 in xrange(1) ]))
    else:
      tmp = ([ None for _autovar_7 in xrange(num) ])

      # src/fusion/Variable.mbi(526:11-51)
      i = 0

      while (i < num):
        tmp[i] = v
        i += 1
      return ( Variable._dstack__3Omosek_fusion_Variable_2I (tmp,0) )
  @staticmethod
  def _matchargs_index_1permute_1__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(535:18-545:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index_permute_([int])")
  def _index_1permute_1__3I(self,perm):
    strides = ([ 0l for _autovar_8 in xrange(self.shape.nd) ])

    dims = ([ 0 for _autovar_9 in xrange(self.shape.nd) ])

    # src/fusion/Variable.mbi(539:9-543:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/Variable.mbi(540:9-543:9)
      strides[i] = ( self.shape._stride_I(perm[i]) )
      dims[i] = ( self.shape._dim_I(perm[i]) )
      # } @ src/fusion/Variable.mbi(540:9-543:9)
    return mosek.fusion.SliceVariable(self,mosek.fusion.NDSet(dims),0l,strides)
  @staticmethod
  def _matchargs_index_1flip_1__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(548:18-565:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index_flip_([int])")
  def _index_1flip_1__3I(self,idxs):
    strides = ([ 0l for _autovar_10 in xrange(self.shape.nd) ])

    dims = ([ 0 for _autovar_11 in xrange(self.shape.nd) ])

    start = 0l

    # src/fusion/Variable.mbi(553:9-557:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/Variable.mbi(554:9-557:9)
      strides[i] = ( self.shape._stride_I(i) )
      dims[i] = ( self.shape._dim_I(i) )
      # } @ src/fusion/Variable.mbi(554:9-557:9)
    # src/fusion/Variable.mbi(558:9-562:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/Variable.mbi(559:9-562:9)
      start = (start + (strides[idxs[i]] * (dims[i] - 1)))
      strides[dims[i]] = (- strides[dims[i]])
      # } @ src/fusion/Variable.mbi(559:9-562:9)
    return mosek.fusion.SliceVariable(self,self.shape,0l,strides)
  @staticmethod
  def _matchargs_diag_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Variable.mbi(578:15-594:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("diag(int)")
  def _diag_I(self,index):
    if   ((self.shape.nd != 2) or (( self.shape._dim_I(0) ) != ( self.shape._dim_I(1) ))):
      raise mosek.fusion.DimensionError("Expected a one- or two-dimensional variable.")
    d = ( self.shape._dim_I(0) )

    if   ((index >= d) or (index <= (- d))):
      raise mosek.fusion.IndexError("Diagonal index out of bounds")
    if   (index == 0):
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet(d),0l,([ long((d + 1))]))
    elif (index > 0):
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet((d - index)),long(index),([ long((d + 1))]))
    else:
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet((d + index)),(long((- index)) * ( self.shape._stride_I(0) )),([ long((d + 1))]))
  @staticmethod
  def _matchargs_diag_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(598:15-597:55)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("diag()")
  def _diag_(self):
    return ( self._diag_I(0) )
  @staticmethod
  def _matchargs_antidiag_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Variable.mbi(610:15-626:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("antidiag(int)")
  def _antidiag_I(self,index):
    if   ((self.shape.nd != 2) or (( self.shape._dim_I(0) ) != ( self.shape._dim_I(1) ))):
      raise mosek.fusion.DimensionError("Expected a one- or two-dimensional variable.")
    d = ( self.shape._dim_I(0) )

    if   ((index >= d) or (index <= (- d))):
      raise mosek.fusion.IndexError("Diagonal index out of bounds")
    if   (index == 0):
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet(d),long((d - 1)),([ long((d - 1))]))
    elif (index > 0):
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet((d - index)),long(((d - index) - 1)),([ long((d - 1))]))
    else:
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet((d + index)),(((long((- index)) * ( self.shape._stride_I(0) )) + d) - 1l),([ long((d - 1))]))
  @staticmethod
  def _matchargs_antidiag_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(630:15-629:63)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("antidiag()")
  def _antidiag_(self):
    return ( self._antidiag_I(0) )
  @staticmethod
  def _matchargs_index_1flat_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/Variable.mbi(633:15-637:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index_flat(long)")
  def _index_1flat_L(self,i):
    if   ((i < 0) or (i >= self.shape._size)):
      raise mosek.fusion.IndexError("Index is out of bounds")
    return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet(1),i,([ 1l]))
  @staticmethod
  def _matchargs_pick_1flat__3L(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  # origin: src/fusion/Variable.mbi(641:15-650:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("pick_flat([long])")
  def _pick_1flat__3L(self,indexes):
    # src/fusion/Variable.mbi(642:9-647:14)
    for i in xrange(0,int(len(indexes))):
      if   ((indexes[i] < 0) or (indexes[i] >= self.shape._size)):
        raise mosek.fusion.IndexError("Index is out of bounds")
    vlist = ([ None for _autovar_12 in xrange(int(len(indexes))) ])

    # src/fusion/Variable.mbi(647:9-72)
    for i in xrange(0,int(len(indexes))):
      vlist[i] = ( self._index_1flat_L(indexes[i]) )
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (vlist,0) )
  @staticmethod
  def _matchargs_pick__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(654:15-668:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("pick([int])")
  def _pick__3I(self,idxs):
    if   (int(len(idxs)) > 0):
      # src/fusion/Variable.mbi(657:11-662:16)
      for i in xrange(0,int(len(idxs))):
        if   ((idxs[i] < 0) or (idxs[i] >= self.shape._size)):
          raise mosek.fusion.IndexError("Index is out of bounds")
      vlist = ([ None for _autovar_13 in xrange(int(len(idxs))) ])

      # src/fusion/Variable.mbi(662:11-63)
      for i in xrange(0,int(len(idxs))):
        vlist[i] = ( self._index_I(idxs[i]) )
      return ( Variable._dstack__3Omosek_fusion_Variable_2I (vlist,0) )
    else:
      return ( self._slice_II(0,0) )
  @staticmethod
  def _matchargs_pick__3_3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(672:15-677:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("pick([[int]])")
  def _pick__3_3I(self,midxs):
    vlist = ([ None for _autovar_14 in xrange(int(len(midxs))) ])

    # src/fusion/Variable.mbi(674:9-63)
    for i in xrange(0,int(len(midxs))):
      vlist[i] = ( self._index__3I(midxs[i]) )
    return ( Variable._dstack__3Omosek_fusion_Variable_2I (vlist,0) )
  @staticmethod
  def _matchargs_transpose_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(686:15-693:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("transpose()")
  def _transpose_(self):
    if   (self.shape.nd == 1):
      return ( self._reshape_1_Omosek_fusion_Set_2(mosek.fusion.NDSet(([ 1,( self.shape._dim_I(0) )]))) )
    elif (self.shape.nd == 2):
      return ( self._index_1permute_1__3I(([ 1,0])) )
    else:
      raise mosek.fusion.DimensionError("Expected a one- or two-dimensional variable.")
  @staticmethod
  def _matchargs_reshape_1_Omosek_fusion_Set_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/Variable.mbi(701:18-705:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape_(mosek.fusion.Set)")
  def _reshape_1_Omosek_fusion_Set_2(self,s):
    strides = ([ 0l for _autovar_15 in xrange(s.nd) ])

    # src/fusion/Variable.mbi(703:9-55)
    for i in xrange(0,s.nd):
      strides[i] = ( s._stride_I(i) )
    return mosek.fusion.SliceVariable(self,s,0l,strides)
  @staticmethod
  def _matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/Variable.mbi(741:15-746:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape(mosek.fusion.Variable,mosek.fusion.Set)")
  def _reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(v,s):
    if   (s._size != v.shape._size):
      raise mosek.fusion.DimensionError("New shape has wrong number of elements")
    return ( v._reshape_1_Omosek_fusion_Set_2(s) )
  @staticmethod
  def _matchargs_flatten_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Variable.mbi(749:15-755:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("flatten(mosek.fusion.Variable)")
  def _flatten_Omosek_fusion_Variable_2(v):
    if   (v.shape.nd == 1):
      return v
    else:
      return ( v._reshape_1_Omosek_fusion_Set_2(mosek.fusion.IntSet(int(v.shape._size))) )
  @staticmethod
  def _matchargs_reshape_Omosek_fusion_Variable_2II(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    return True
  # origin: src/fusion/Variable.mbi(769:15-774:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape(mosek.fusion.Variable,int,int)")
  def _reshape_Omosek_fusion_Variable_2II(v,d1,d2):
    if   ((d1 * d2) != v.shape._size):
      raise mosek.fusion.DimensionError("New shape has wrong number of elements")
    return mosek.fusion.SliceVariable(v,mosek.fusion.NDSet(d1,d2),0l,([ long(d2),1l]))
  @staticmethod
  def _matchargs_reshape_Omosek_fusion_Variable_2I(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(787:15-792:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape(mosek.fusion.Variable,int)")
  def _reshape_Omosek_fusion_Variable_2I(v,d1):
    if   (d1 != v.shape._size):
      raise mosek.fusion.DimensionError("New shape has wrong number of elements")
    return mosek.fusion.SliceVariable(v,mosek.fusion.IntSet(d1),0l,([ 1l]))
  @staticmethod
  def _matchargs_compress_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(806:15-826:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("compress()")
  def _compress_(self):
    nd = ( self.shape._realnd_() )

    if   (nd == self.shape.nd):
      return self
    elif (nd == 1):
      return ( Variable._reshape_Omosek_fusion_Variable_2I (self,int(self.shape._size)) )
    else:
      d = ([ 0 for _autovar_16 in xrange(nd) ])

      # { @ src/fusion/Variable.mbi(815:11-823:11)
      j = 0

      # src/fusion/Variable.mbi(817:13-824:14)
      for i in xrange(0,self.shape.nd):
        if   (( self.shape._dim_I(i) ) > 1):
          d[j] = ( self.shape._dim_I(i) )
          j += 1
      # } @ src/fusion/Variable.mbi(815:11-823:11)
      return ( Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2 (self,mosek.fusion.NDSet(d)) )
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Variable.mbi(846:18-852:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    pass
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Variable.mbi(855:18-859:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    pass
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Variable.mbi(870:18-877:7)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    pass
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Variable.mbi(880:18-884:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    pass
  @staticmethod
  def _matchargs_level_1values_I_3F(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Variable.mbi(891:18-900:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(int,[float])")
  def _level_1values_I_3F(self,offset,target):
    strides = ([ 0l for _autovar_17 in xrange(self.shape.nd) ])

    dims = ([ 0 for _autovar_18 in xrange(self.shape.nd) ])

    # src/fusion/Variable.mbi(897:9-65)
    for i in xrange(0,self.shape.nd):
      strides[i] = ( self.shape._stride_I(i) )
    # src/fusion/Variable.mbi(898:9-62)
    for i in xrange(0,self.shape.nd):
      dims[i] = ( self.shape._dim_I(i) )
    ( self._level_1values_L_3I_3LI_3F(0l,dims,strides,offset,target) )
  @staticmethod
  def _matchargs_dual_1values_I_3F(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Variable.mbi(908:18-921:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(int,[float])")
  def _dual_1values_I_3F(self,offset,target):
    nsize = ([ 0 for _autovar_19 in xrange(self.shape.nd) ])

    strides = ([ 0l for _autovar_20 in xrange(self.shape.nd) ])

    # src/fusion/Variable.mbi(914:9-918:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/Variable.mbi(915:9-918:9)
      nsize[i] = ( self.shape._dim_I(i) )
      strides[i] = ( self.shape._stride_I(i) )
      # } @ src/fusion/Variable.mbi(915:9-918:9)
    ( self._dual_1values_L_3I_3LI_3F(0l,nsize,strides,offset,target) )
  @staticmethod
  def _matchargs_level_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(941:15-959:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level(int,int)")
  def _level_II(self,firstidx,lastidx):
    if   ((((self.shape.nd != 1) or (firstidx < 0)) or (firstidx > lastidx)) or (lastidx > ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = (lastidx - firstidx)

    res = ([ 0.0 for _autovar_21 in xrange(num) ])

    if   (num > 0):
      dims = ([ (lastidx - firstidx)])

      strides = ([ 1l])

      ( self._level_1values_L_3I_3LI_3F(long(firstidx),dims,strides,0,res) )
    return res
  @staticmethod
  def _matchargs_level__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(978:15-1012:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level([int],[int])")
  def _level__3I_3I(self,firstidx,lastidx):
    if   ((self.shape.nd != int(len(firstidx))) or (self.shape.nd != int(len(lastidx)))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = 1

    # src/fusion/Variable.mbi(988:9-995:9)
    i = 0

    while (i < self.shape.nd):
      if   (((firstidx[i] > lastidx[i]) or (firstidx[i] < 0)) or (lastidx[i] > ( self.shape._dim_I(i) ))):
        raise mosek.fusion.SliceError("Slice index out of bound")
      num = (num * (lastidx[i] - firstidx[i]))
      i += 1
    res = ([ 0.0 for _autovar_22 in xrange(num) ])

    if   (num > 0):
      dims = ([ 0 for _autovar_23 in xrange(self.shape.nd) ])

      strides = ([ 0l for _autovar_24 in xrange(self.shape.nd) ])

      # src/fusion/Variable.mbi(1002:11-65)
      for i in xrange(0,self.shape.nd):
        strides[i] = ( self.shape._stride_I(i) )
      # src/fusion/Variable.mbi(1003:11-74)
      for i in xrange(0,self.shape.nd):
        dims[i] = (lastidx[i] - firstidx[i])
      start = 0l

      # src/fusion/Variable.mbi(1006:11-1007:60)
      for i in xrange(0,self.shape.nd):
        start = (start + (long(firstidx[i]) * strides[i]))
      ( self._level_1values_L_3I_3LI_3F(start,dims,strides,0,res) )
    return res
  @staticmethod
  def _matchargs_level_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Variable.mbi(1029:15-1038:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level(int)")
  def _level_I(self,index):
    if   (((self.shape.nd != 1) or (index < 0)) or (index >= ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Invalid index.")
    idxs = ([ long(index)])

    res = ([ 0.0 for _autovar_25 in xrange(1) ])

    ( self._level_1values__3LI_3F(idxs,0,res) )
    return res[0]
  @staticmethod
  def _matchargs_dual_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Variable.mbi(1057:15-1075:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual(int,int)")
  def _dual_II(self,firstidx,lastidx):
    if   ((((self.shape.nd != 1) or (firstidx > lastidx)) or (firstidx < 0)) or (lastidx >= ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = (lastidx - firstidx)

    res = ([ 0.0 for _autovar_26 in xrange(num) ])

    if   (num > 0):
      ( self._dual_1values_L_3I_3LI_3F(long(firstidx),([ num]),([ 1l]),0,res) )
    return res
  @staticmethod
  def _matchargs_dual__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(1094:15-1127:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual([int],[int])")
  def _dual__3I_3I(self,firstidx,lastidx):
    if   ((self.shape.nd != int(len(firstidx))) or (self.shape.nd != int(len(lastidx)))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = 1

    # src/fusion/Variable.mbi(1103:9-1110:9)
    i = 0

    while (i < self.shape.nd):
      if   (((firstidx[i] > lastidx[i]) or (firstidx[i] < 0)) or (lastidx[i] >= ( self.shape._dim_I(i) ))):
        raise mosek.fusion.SliceError("Slice index out of bound")
      num = (num * (lastidx[i] * firstidx[i]))
      i += 1
    res = ([ 0.0 for _autovar_27 in xrange(num) ])

    if   (num > 0):
      nsize = ([ 0 for _autovar_28 in xrange(self.shape.nd) ])

      strides = ([ 0l for _autovar_29 in xrange(self.shape.nd) ])

      firstelm = 0l

      # src/fusion/Variable.mbi(1117:11-1122:11)
      for i in xrange(0,self.shape.nd):
        # { @ src/fusion/Variable.mbi(1118:11-1122:11)
        nsize[i] = (lastidx[i] - firstidx[i])
        strides[i] = ( self.shape._stride_I(i) )
        firstelm = (firstelm + (strides[i] * firstidx[i]))
        # } @ src/fusion/Variable.mbi(1118:11-1122:11)
      ( self._dual_1values_L_3I_3LI_3F(firstelm,nsize,strides,0,res) )
    return res
  @staticmethod
  def _matchargs_level_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(1138:15-1143:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("level()")
  def _level_(self):
    res = ([ 0.0 for _autovar_30 in xrange(self.shape._size) ])

    if   (self.shape._size > 0):
      ( self._level_1values_I_3F(0,res) )
    return res
  @staticmethod
  def _matchargs_dual_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(1154:15-1166:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("dual()")
  def _dual_(self):
    try:
      res = ([ 0.0 for _autovar_31 in xrange(self.shape._size) ])

      if   (self.shape._size > 0):
        ( self._dual_1values_I_3F(0,res) )
      return res
    except mosek.fusion.Utils.FusionException, e:
      raise mosek.fusion.UnexpectedError(( e._toString_() ))
  @staticmethod
  def _matchargs_size_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(1170:15-1172:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("size()")
  def _size_(self):
    return self.shape._size
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(1191:18-1196:9)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int],[int],[int])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    pass
  @staticmethod
  def _matchargs_inst__3LIILL_3I_3I_3I(args):
    if len(args) != 8:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Variable.mbi(1199:18-1211:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst([long],int,int,long,long,[int],[int],[int])")
  def _inst__3LIILL_3I_3I_3I(self,index,first_idx,last_idx,index_offset,dst_offset,dst_nindex,dst_nsubi,dst_nsubj):
    # src/fusion/Variable.mbi(1209:9-1210:96)
    for i in xrange(first_idx,last_idx):
      ( self._inst_LL_3I_3I_3I((index[i] - index_offset),((dst_offset + i) - first_idx),dst_nindex,dst_nsubi,dst_nsubj) )
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Variable.mbi(1219:15-1229:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( ( sb._a_S("Variable(dimensions=") )._a_I(( self.shape._dim_I(0) )) )
    # src/fusion/Variable.mbi(1223:9-1226:9)
    i = 1

    while (i < self.shape.nd):
      ( ( sb._a_S(",") )._a_I(( self.shape._dim_I(i) )) )
      i += 1
    ( ( ( sb._a_S("; totalsize=") )._a_L(self.shape._size) )._a_S(")") )
    return ( sb._toString_() )
  @staticmethod
  def _matchargs_elementName_LOmosek_fusion_Utils_StringBuffer_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],long): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Utils.StringBuffer): return False
    return True
  # origin: src/fusion/Variable.mbi(1232:18-8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("elementName(long,mosek.fusion.Utils.StringBuffer)")
  def _elementName_LOmosek_fusion_Utils_StringBuffer_2(self,index,sb):
    pass
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index_III(args):
      return Variable._index_III(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(1,"\tindex([int])"),(2,"\tindex(int,int)"),(3,"\tindex(int,int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlevel()"),(1,"\tlevel(int)"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int]])"),(1,"\tpick([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   Variable._matchargs_slice_II(args):
      return Variable._slice_II(self,*args)
    elif Variable._matchargs_slice__3I_3I(args):
      return Variable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Variable._matchargs_toString_(args):
      return Variable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Variable._matchargs_flatten_Omosek_fusion_Variable_2(args):
      return Variable._flatten_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/SymmetricVariable.mbi(16:5-214:5)
class SymmetricVariable(Variable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Variable) @ src/fusion/SymmetricVariable.mbi(55:18-63:7)")
  def __constructor_Omosek_fusion_Variable_2(self,v):
    mosek.fusion.Variable._Variable__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,v._model,v.shape)
    if   ((v.shape.nd == 2) and (( v.shape._dim_I(0) ) == ( v.shape._dim_I(1) ))):
      self.__x = v
    else:
      raise mosek.fusion.DimensionError("Expected a square matrix")
  def __init__(self,*args):
    #self.__x = None

    self.__constructor_Omosek_fusion_Variable_2(*args)
  @staticmethod
  def _matchargs_check_1symmetrix_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(21:16-35:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("check_symmetrix(mosek.fusion.Variable)")
  def __check_1symmetrix_Omosek_fusion_Variable_2(self,v):
    _autovar_32 = v
    if   isinstance(_autovar_32,mosek.fusion.PSDVariable):
      w = _autovar_32
      return True
    elif isinstance(_autovar_32,mosek.fusion.SymmetricVariable):
      w = _autovar_32
      return True
    else:
      w = _autovar_32
      return False
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(66:18-79:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int],[int],[int])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    i = int((index / long(( self.shape._dim_I(1) ))))

    j = int((index - long((( self.shape._dim_I(1) ) * i))))

    if   (j <= i):
      ( self.__x._inst_LL_3I_3I_3I(index,offset,nindex,nsubi,nsubj) )
    else:
      ( self.__x._inst_LL_3I_3I_3I((long((j * ( self.shape._dim_I(1) ))) + i),offset,nindex,nsubi,nsubj) )
  @staticmethod
  def _matchargs_elementName_LOmosek_fusion_Utils_StringBuffer_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],long): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Utils.StringBuffer): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(82:18-90:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("elementName(long,mosek.fusion.Utils.StringBuffer)")
  def _elementName_LOmosek_fusion_Utils_StringBuffer_2(self,index,sb):
    i = int((index / long(( self.shape._dim_I(1) ))))

    j = int((index - long((( self.shape._dim_I(1) ) * i))))

    if   (j <= i):
      ( self.__x._elementName_LOmosek_fusion_Utils_StringBuffer_2(index,sb) )
    else:
      ( self.__x._elementName_LOmosek_fusion_Utils_StringBuffer_2((long((j * ( self.shape._dim_I(1) ))) + i),sb) )
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(94:15-96:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    raise mosek.fusion.IndexError("Two dimensional index expected")
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(99:15-118:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int],[int])")
  def _slice__3I_3I(self,first,last):
    if   ((int(len(first)) != 2) or (int(len(last)) != 2)):
      raise mosek.fusion.IndexError("Two dimensional index expected")
    d = ( self.shape._dim_I(0) )

    if   (((first[0] == first[1]) and (last[0] == last[1])) and (first[0] == (d - last[0]))):
      return mosek.fusion.SymmetricVariable(( self.__x._slice__3I_3I(first,last) ))
    else:
      return mosek.fusion.SliceVariable(self,mosek.fusion.NDSet((last[0] - first[0]),(last[1] - first[0])),long(((first[0] * ( self.shape._dim_I(1) )) + first[1])),([ long(( self.shape._dim_I(1) )),1l]))
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(125:18-146:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    size = (nsize[0] * nsize[1])

    pidxs = ([ 0l for _autovar_33 in xrange(size) ])

    k = 0

    # src/fusion/SymmetricVariable.mbi(135:9-144:9)
    for i in xrange(0,nsize[0]):
      # { @ src/fusion/SymmetricVariable.mbi(136:9-144:9)
      # src/fusion/SymmetricVariable.mbi(137:11-143:11)
      for j in xrange(0,nsize[1]):
        # { @ src/fusion/SymmetricVariable.mbi(138:11-143:11)
        if   (i >= j):
          pidxs[k] = ((start + (strides[0] * i)) + (strides[1] * j))
        else:
          pidxs[k] = ((start + (strides[1] * i)) + (strides[0] * j))
        # } @ src/fusion/SymmetricVariable.mbi(138:11-143:11)
      # } @ src/fusion/SymmetricVariable.mbi(136:9-144:9)
    ( self.__x._level_1values__3LI_3F(pidxs,offset,target) )
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(149:18-165:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    pidxs = ([ 0l for _autovar_34 in xrange(int(len(idxs))) ])

    # src/fusion/SymmetricVariable.mbi(154:9-163:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/SymmetricVariable.mbi(155:9-163:9)
      ii = int((idxs[i] / ( self.shape._dim_I(1) )))

      ij = int((idxs[i] - (( self.shape._dim_I(1) ) * ii)))

      if   (ii >= ij):
        pidxs[i] = idxs[i]
      else:
        pidxs[i] = long(((ij * ( self.shape._dim_I(1) )) + ii))
      # } @ src/fusion/SymmetricVariable.mbi(155:9-163:9)
    ( self.__x._level_1values__3LI_3F(pidxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(171:18-192:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    size = (nsize[0] * nsize[1])

    pidxs = ([ 0l for _autovar_35 in xrange(size) ])

    k = 0

    # src/fusion/SymmetricVariable.mbi(181:9-190:9)
    for i in xrange(0,nsize[0]):
      # { @ src/fusion/SymmetricVariable.mbi(182:9-190:9)
      # src/fusion/SymmetricVariable.mbi(183:11-189:11)
      for j in xrange(0,nsize[1]):
        # { @ src/fusion/SymmetricVariable.mbi(184:11-189:11)
        if   (i >= j):
          pidxs[k] = ((start + (strides[0] * i)) + (strides[1] * j))
        else:
          pidxs[k] = ((start + (strides[1] * i)) + (strides[0] * j))
        # } @ src/fusion/SymmetricVariable.mbi(184:11-189:11)
      # } @ src/fusion/SymmetricVariable.mbi(182:9-190:9)
    ( self.__x._dual_1values__3LI_3F(pidxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SymmetricVariable.mbi(196:18-212:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    pidxs = ([ 0l for _autovar_36 in xrange(int(len(idxs))) ])

    # src/fusion/SymmetricVariable.mbi(201:9-210:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/SymmetricVariable.mbi(202:9-210:9)
      ii = int((idxs[i] / ( self.shape._dim_I(1) )))

      ij = int((idxs[i] - (( self.shape._dim_I(1) ) * ii)))

      if   (ii >= ij):
        pidxs[i] = idxs[i]
      else:
        pidxs[i] = long(((ij * ( self.shape._dim_I(1) )) + ii))
      # } @ src/fusion/SymmetricVariable.mbi(202:9-210:9)
    ( self.__x._dual_1values__3LI_3F(pidxs,offset,target) )
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlevel()"),(1,"\tlevel(int)"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int]])"),(1,"\tpick([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   SymmetricVariable._matchargs_slice_II(args):
      return SymmetricVariable._slice_II(self,*args)
    elif SymmetricVariable._matchargs_slice__3I_3I(args):
      return SymmetricVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Variable._matchargs_toString_(args):
      return Variable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    elif Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdual()"),(2,"\tdual([int],[int])"),(2,"\tdual(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Variable._matchargs_flatten_Omosek_fusion_Variable_2(args):
      return Variable._flatten_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_III(args):
      return Variable._index_III(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tindex(int,int,int)"),(2,"\tindex(int,int)"),(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/SliceVariable.mbi(17:5-331:5)
class SliceVariable(Variable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2L_3L(args):
    if len(args) != 4:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if not isinstance(args[2],long): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Variable,mosek.fusion.Set,long,[long]) @ src/fusion/SliceVariable.mbi(48:18-58:7)")
  def __constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2L_3L(self,origin_,shape_,first_,strides_):
    mosek.fusion.Variable._Variable__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,origin_._model,shape_)
    self.__origin = origin_
    self.__first = first_
    self.__strides = strides_
  def __init__(self,*args):
    #self.__origin = None

    #self.__first = None

    #self.__strides = None

    self.__constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2L_3L(*args)
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(62:18-78:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    tmpidxs = ([ 0l for _autovar_37 in xrange(int(len(idxs))) ])

    # src/fusion/SliceVariable.mbi(68:9-75:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/SliceVariable.mbi(69:9-75:9)
      index = ( self.shape._idxtokey_L(idxs[i]) )

      tmpi = self.__first

      # src/fusion/SliceVariable.mbi(72:11-73:55)
      for j in xrange(0,self.shape.nd):
        tmpi = (tmpi + (long(index[j]) * self.__strides[j]))
      tmpidxs[i] = tmpi
      # } @ src/fusion/SliceVariable.mbi(69:9-75:9)
    ( self.__origin._level_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(81:18-159:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides_,offset,target):
    if   ((((start == 0l) and (int(len(nsize)) == 1)) and (nsize[0] == self.shape._size)) and (strides_[0] == 1)):
      tmp_nsize = ([ 0 for _autovar_38 in xrange(self.shape.nd) ])

      # src/fusion/SliceVariable.mbi(93:43-96)
      for i in xrange(0,self.shape.nd):
        tmp_nsize[i] = ( self.shape._dim_I(i) )
      ( self.__origin._level_1values_L_3I_3LI_3F(self.__first,tmp_nsize,self.__strides,offset,target) )
    else:
      n = int(len(nsize))

      is_compatible = (n == self.shape.nd)

      # src/fusion/SliceVariable.mbi(107:11-108:59)
      i = 0

      while ((i < n) and is_compatible):
        is_compatible = (strides_[i] == ( self.shape._stride_I(i) ))
        i += 1
      if   is_compatible:
        slice_start = self.__first

        # { @ src/fusion/SliceVariable.mbi(116:13-124:13)
        tmp = start

        # src/fusion/SliceVariable.mbi(118:15-123:15)
        for i in xrange(0,(self.shape.nd - 1)):
          # { @ src/fusion/SliceVariable.mbi(119:15-123:15)
          dimiofs = (tmp / strides_[i])

          tmp = (tmp - (strides_[i] * dimiofs))
          slice_start = (slice_start + (( self.shape._stride_I(i) ) * dimiofs))
          # } @ src/fusion/SliceVariable.mbi(119:15-123:15)
        # } @ src/fusion/SliceVariable.mbi(116:13-124:13)
        ( self.__origin._level_1values_L_3I_3LI_3F(slice_start,nsize,self.__strides,offset,target) )
      else:
        totalsize = 1l

        # src/fusion/SliceVariable.mbi(130:33-95)
        for i in xrange(0,int(len(nsize))):
          totalsize = (totalsize * nsize[i])
        tmpidxs = ([ 0l for _autovar_39 in xrange(totalsize) ])

        # { @ src/fusion/SliceVariable.mbi(133:13-154:13)
        ii = ([ 0 for _autovar_40 in xrange(int(len(nsize))) ])

        st = ([ 0l for _autovar_41 in xrange(int(len(nsize))) ])

        # src/fusion/SliceVariable.mbi(136:15-153:15)
        for i in xrange(0l,totalsize):
          # { @ src/fusion/SliceVariable.mbi(137:15-153:15)
          tmpidxs[i] = (( self.__origin.shape._linearidx__3I(( self.shape._idxtokey_L((start + st[0])) )) ) + self.__first)
          # { @ src/fusion/SliceVariable.mbi(143:17-152:17)
          j = 0

          ii[0] += 1
          st[0] = (st[0] + strides_[(n - 1)])
          # src/fusion/SliceVariable.mbi(145:20-150:20)
          while ((j < (n - 1)) and (ii[j] >= nsize[((n - j) - 1)])):
            st[(j + 1)] = (st[(j + 1)] + strides_[((n - j) - 2)])
            ii[j] = 0
            ii[(j + 1)] += 1
            j += 1
          # src/fusion/SliceVariable.mbi(151:20-54)
          for k in xrange(0,j):
            st[k] = st[j]
          # } @ src/fusion/SliceVariable.mbi(143:17-152:17)
          # } @ src/fusion/SliceVariable.mbi(137:15-153:15)
        # } @ src/fusion/SliceVariable.mbi(133:13-154:13)
        ( self.__origin._level_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(165:18-181:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    tmpidxs = ([ 0l for _autovar_42 in xrange(int(len(idxs))) ])

    # src/fusion/SliceVariable.mbi(171:9-178:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/SliceVariable.mbi(172:9-178:9)
      index = ( self.shape._idxtokey_L(idxs[i]) )

      tmpi = 0l

      # src/fusion/SliceVariable.mbi(175:11-176:55)
      for j in xrange(0,self.shape.nd):
        tmpi = (tmpi + (long(index[j]) * self.__strides[j]))
      tmpidxs[i] = tmpi
      # } @ src/fusion/SliceVariable.mbi(172:9-178:9)
    ( self.__origin._dual_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(184:18-262:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides_,offset,target):
    if   ((((start == 0l) and (int(len(nsize)) == 1)) and (nsize[0] == self.shape._size)) and (strides_[0] == 1)):
      tmp_nsize = ([ 0 for _autovar_43 in xrange(self.shape.nd) ])

      # src/fusion/SliceVariable.mbi(196:43-96)
      for i in xrange(0,self.shape.nd):
        tmp_nsize[i] = ( self.shape._dim_I(i) )
      ( self.__origin._dual_1values_L_3I_3LI_3F(self.__first,tmp_nsize,self.__strides,offset,target) )
    else:
      n = int(len(nsize))

      is_compatible = (n == self.shape.nd)

      # src/fusion/SliceVariable.mbi(210:11-211:59)
      i = 0

      while ((i < n) and is_compatible):
        is_compatible = (strides_[i] == ( self.shape._stride_I(i) ))
        i += 1
      if   is_compatible:
        slice_start = self.__first

        # { @ src/fusion/SliceVariable.mbi(219:13-227:13)
        tmp = start

        # src/fusion/SliceVariable.mbi(221:15-226:15)
        for i in xrange(0,(self.shape.nd - 1)):
          # { @ src/fusion/SliceVariable.mbi(222:15-226:15)
          dimiofs = (tmp / strides_[i])

          tmp = (tmp - (strides_[i] * dimiofs))
          slice_start = (slice_start + (( self.shape._stride_I(i) ) * dimiofs))
          # } @ src/fusion/SliceVariable.mbi(222:15-226:15)
        # } @ src/fusion/SliceVariable.mbi(219:13-227:13)
        ( self.__origin._dual_1values_L_3I_3LI_3F(slice_start,nsize,self.__strides,offset,target) )
      else:
        totalsize = 1l

        # src/fusion/SliceVariable.mbi(233:33-95)
        for i in xrange(0,int(len(nsize))):
          totalsize = (totalsize * nsize[i])
        tmpidxs = ([ 0l for _autovar_44 in xrange(totalsize) ])

        # { @ src/fusion/SliceVariable.mbi(236:13-257:13)
        ii = ([ 0 for _autovar_45 in xrange(int(len(nsize))) ])

        st = ([ 0l for _autovar_46 in xrange(int(len(nsize))) ])

        # src/fusion/SliceVariable.mbi(239:15-256:15)
        for i in xrange(0l,totalsize):
          # { @ src/fusion/SliceVariable.mbi(240:15-256:15)
          tmpidxs[i] = (( self.__origin.shape._linearidx__3I(( self.shape._idxtokey_L((start + st[0])) )) ) + self.__first)
          # { @ src/fusion/SliceVariable.mbi(246:17-255:17)
          j = 0

          ii[0] += 1
          st[0] = (st[0] + strides_[(n - 1)])
          # src/fusion/SliceVariable.mbi(248:20-253:20)
          while ((j < (n - 1)) and (ii[j] >= nsize[((n - j) - 1)])):
            st[(j + 1)] = (st[(j + 1)] + strides_[((n - j) - 2)])
            ii[j] = 0
            ii[(j + 1)] += 1
            j += 1
          # src/fusion/SliceVariable.mbi(254:20-54)
          for k in xrange(0,j):
            st[k] = st[j]
          # } @ src/fusion/SliceVariable.mbi(246:17-255:17)
          # } @ src/fusion/SliceVariable.mbi(240:15-256:15)
        # } @ src/fusion/SliceVariable.mbi(236:13-257:13)
        ( self.__origin._dual_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(270:15-272:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,firstidx,lastidx):
    return mosek.fusion.SliceVariable(self.__origin,( self.shape._slice_II(firstidx,lastidx) ),(self.__first + long(firstidx)),self.__strides)
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(275:15-282:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int],[int])")
  def _slice__3I_3I(self,firstidx,lastidx):
    shp = ( self.shape._slice__3I_3I(firstidx,lastidx) )

    newfirst = self.__first

    # src/fusion/SliceVariable.mbi(279:9-280:55)
    i = 0

    while (i < int(len(firstidx))):
      newfirst = (newfirst + (self.__strides[i] * firstidx[i]))
      i += 1
    return mosek.fusion.SliceVariable(self.__origin,shp,newfirst,self.__strides)
  @staticmethod
  def _matchargs_elementName_LOmosek_fusion_Utils_StringBuffer_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],long): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Utils.StringBuffer): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(286:18-303:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("elementName(long,mosek.fusion.Utils.StringBuffer)")
  def _elementName_LOmosek_fusion_Utils_StringBuffer_2(self,index,sb):
    if   ((index < 0l) or (index >= self.shape._size)):
      raise mosek.fusion.IndexError("Index out of bounds")
    idx = self.__first

    rest = index

    # src/fusion/SliceVariable.mbi(294:9-299:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/SliceVariable.mbi(295:9-299:9)
      k = (rest / ( self.shape._stride_I(i) ))

      rest = (rest - (k * ( self.shape._stride_I(i) )))
      idx = (idx + (self.__strides[i] * k))
      # } @ src/fusion/SliceVariable.mbi(295:9-299:9)
    ( self.__origin._elementName_LOmosek_fusion_Utils_StringBuffer_2(idx,sb) )
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/SliceVariable.mbi(307:18-328:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int],[int],[int])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    if   ((index < 0l) or (index >= self.shape._size)):
      raise mosek.fusion.IndexError("Index out of bounds")
    idx = self.__first

    rest = index

    # src/fusion/SliceVariable.mbi(319:9-325:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/SliceVariable.mbi(320:9-325:9)
      k = (rest / ( self.shape._stride_I(i) ))

      rest = (rest - (k * ( self.shape._stride_I(i) )))
      idx = (idx + (self.__strides[i] * k))
      # } @ src/fusion/SliceVariable.mbi(320:9-325:9)
    ( self.__origin._inst_LL_3I_3I_3I(idx,offset,nindex,nsubi,nsubj) )
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlevel()"),(1,"\tlevel(int)"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int]])"),(1,"\tpick([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   SliceVariable._matchargs_slice_II(args):
      return SliceVariable._slice_II(self,*args)
    elif SliceVariable._matchargs_slice__3I_3I(args):
      return SliceVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_III(args):
      return Variable._index_III(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tindex(int,int,int)"),(2,"\tindex(int,int)"),(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    elif Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdual()"),(2,"\tdual([int],[int])"),(2,"\tdual(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Variable._matchargs_toString_(args):
      return Variable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Variable._matchargs_flatten_Omosek_fusion_Variable_2(args):
      return Variable._flatten_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/BoundInterfaceVariable.mbi(22:5-73:5)
class BoundInterfaceVariable(SliceVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_RangedVariable_2Omosek_fusion_Set_2L_3LB(args):
    if len(args) != 5:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.RangedVariable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if not isinstance(args[2],long): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[4],bool): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.RangedVariable,mosek.fusion.Set,long,[long],bool) @ src/fusion/BoundInterfaceVariable.mbi(29:18-39:7)")
  def __constructor_Omosek_fusion_RangedVariable_2Omosek_fusion_Set_2L_3LB(self,origin_,shape_,first_,strides_,islower_):
    mosek.fusion.SliceVariable._SliceVariable__constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2L_3L(self,origin_,shape_,first_,strides_)
    self.__originvar = origin_
    self.__islower = islower_
  def __init__(self,*args):
    #self.__islower = None

    #self.__originvar = None

    self.__constructor_Omosek_fusion_RangedVariable_2Omosek_fusion_Set_2L_3LB(*args)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/BoundInterfaceVariable.mbi(42:18-50:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    if   self.__islower:
      ( self.__originvar._dual_1l__3LI_3F(idxs,offset,target) )
    else:
      ( self.__originvar._dual_1u__3LI_3F(idxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/BoundInterfaceVariable.mbi(52:18-62:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    if   self.__islower:
      ( self.__originvar._dual_1l_L_3I_3LI_3F(start,nsize,strides,offset,target) )
    else:
      ( self.__originvar._dual_1u_L_3I_3LI_3F(start,nsize,strides,offset,target) )
  @staticmethod
  def _matchargs_slice_1_Omosek_fusion_Set_2L_3L(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  # origin: src/fusion/BoundInterfaceVariable.mbi(67:18-72:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice_(mosek.fusion.Set,long,[long])")
  def _slice_1_Omosek_fusion_Set_2L_3L(self,shape_,first_,strides_):
    return mosek.fusion.BoundInterfaceVariable(self.__originvar,shape_,first_,strides_,self.__islower)
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index_III(args):
      return Variable._index_III(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(1,"\tindex([int])"),(2,"\tindex(int,int)"),(3,"\tindex(int,int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlevel()"),(1,"\tlevel(int)"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int]])"),(1,"\tpick([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    elif Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tantidiag()"),(1,"\tantidiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   SliceVariable._matchargs_slice_II(args):
      return SliceVariable._slice_II(self,*args)
    elif SliceVariable._matchargs_slice__3I_3I(args):
      return SliceVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Variable._matchargs_toString_(args):
      return Variable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Variable._matchargs_flatten_Omosek_fusion_Variable_2(args):
      return Variable._flatten_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/CompoundVariable.mbi(19:5-497:5)
class CompoundVariable(Variable):
  @staticmethod
  def _matchargs_constructor__3Omosek_fusion_Variable_2I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    if not isinstance(args[1],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([mosek.fusion.Variable],int) @ src/fusion/CompoundVariable.mbi(83:18-121:7)")
  def __constructor__3Omosek_fusion_Variable_2I(self,v,dim):
    mosek.fusion.Variable._Variable__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,( CompoundVariable.__model_1from_1var__3Omosek_fusion_Variable_2 (v) ),( CompoundVariable.__compute_1shape__3Omosek_fusion_Variable_2I (v,dim) ))
    numnz = 0

    dimsize = 0

    # src/fusion/CompoundVariable.mbi(89:9-101:9)
    for i in xrange(0,int(len(v))):
      # { @ src/fusion/CompoundVariable.mbi(90:9-101:9)
      if   (v[i].shape._size == 1):
        numnz += 1
        dimsize += 1
      elif (v[i].shape._size > 1):
        numnz += 1
        dimsize = (dimsize + ( v[i].shape._dim_I(dim) ))
      # } @ src/fusion/CompoundVariable.mbi(90:9-101:9)
    self.__vars = ([ None for _autovar_47 in xrange(numnz) ])
    self.__varsb = ([ 0 for _autovar_48 in xrange((numnz + 1)) ])
    self.__varsb[0] = 0
    self.__stackdim = dim
    # { @ src/fusion/CompoundVariable.mbi(108:9-120:9)
    j = 0

    # src/fusion/CompoundVariable.mbi(110:11-121:12)
    i = 0

    while (i < int(len(v))):
      if   (v[i].shape._size > 0):
        self.__vars[j] = v[i]
        if   (v[i].shape._size == 1):
          self.__varsb[(j + 1)] = (self.__varsb[j] + 1)
        else:
          self.__varsb[(j + 1)] = (self.__varsb[j] + ( v[i].shape._dim_I(dim) ))
        j += 1
      i += 1
    # } @ src/fusion/CompoundVariable.mbi(108:9-120:9)
  def __init__(self,*args):
    #self.__vars = None

    #self.__varsb = None

    #self.__stackdim = None

    self.__constructor__3Omosek_fusion_Variable_2I(*args)
  @staticmethod
  def _matchargs_model_1from_1var__3Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(29:16-31:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("model_from_var([mosek.fusion.Variable])")
  def __model_1from_1var__3Omosek_fusion_Variable_2(v):
    return v[0]._model
  @staticmethod
  def _matchargs_compute_1shape__3Omosek_fusion_Variable_2I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(53:16-80:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("compute_shape([mosek.fusion.Variable],int)")
  def __compute_1shape__3Omosek_fusion_Variable_2I(v,dim):
    s = v[0].shape

    sdsize = 0

    # src/fusion/CompoundVariable.mbi(57:9-70:9)
    for i in xrange(0,int(len(v))):
      # { @ src/fusion/CompoundVariable.mbi(58:9-70:9)
      thisv = v[i]

      if   (thisv.shape._size > 0):
        if   (thisv.shape.nd != s.nd):
          raise mosek.fusion.DimensionError("Mismatching variable shape")
        # src/fusion/CompoundVariable.mbi(65:13-69:21)
        for j in xrange(0,s.nd):
          if   ((j != dim) and (( s._dim_I(j) ) != ( thisv.shape._dim_I(j) ))):
            raise mosek.fusion.DimensionError("Mismatching variable shape")
        sdsize = (sdsize + ( thisv.shape._dim_I(dim) ))
      # } @ src/fusion/CompoundVariable.mbi(58:9-70:9)
    if   (s.nd == 1):
      return mosek.fusion.IntSet(sdsize)
    else:
      d = ([ 0 for _autovar_49 in xrange(s.nd) ])

      # src/fusion/CompoundVariable.mbi(76:11-57)
      i = 0

      while (i < s.nd):
        d[i] = ( s._dim_I(i) )
        i += 1
      d[dim] = sdsize
      return mosek.fusion.NDSet(d)
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(125:15-171:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    if   (self.shape.nd != 1):
      raise mosek.fusion.SliceError("Slice has wrong number of dimensions")
    elif (first > last):
      raise mosek.fusion.SliceError("Invalid slice range")
    elif ((first < 0) or (last > ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Slice index is out of bounds")
    if   (first == last):
      return mosek.fusion.SliceVariable(self,mosek.fusion.IntSet(0),0l,([ 0l for _autovar_50 in xrange(1) ]))




    # { @ src/fusion/CompoundVariable.mbi(142:9-150:9)
    i = 0

    # src/fusion/CompoundVariable.mbi(144:11-42)
    while (first >= self.__varsb[(i + 1)]):
      i += 1
    idxb = i
    offsetb = (first - self.__varsb[i])
    # src/fusion/CompoundVariable.mbi(147:11-40)
    while (last > self.__varsb[(i + 1)]):
      i += 1
    idxe = i
    offsete = (last - self.__varsb[i])
    # } @ src/fusion/CompoundVariable.mbi(142:9-150:9)
    if   (idxb == idxe):
      return ( self.__vars[idxb]._slice_II(offsetb,offsete) )
    else:
      r = ([ None for _autovar_51 in xrange(((idxb - idxe) + 1)) ])

      if   (offsetb > 0):
        r[0] = ( self.__vars[idxb]._slice_II(offsetb,( self.__vars[idxb].shape._dim_I(0) )) )
      else:
        r[0] = self.__vars[idxb]
      if   (offsete < ( self.__vars[idxe].shape._dim_I(0) )):
        r[(int(len(r)) - 1)] = ( self.__vars[idxe]._slice_II(0,offsete) )
      else:
        r[(int(len(r)) - 1)] = self.__vars[idxe]
      # src/fusion/CompoundVariable.mbi(166:11-167:32)
      i = 1

      while (i < (int(len(r)) - 1)):
        r[i] = self.__vars[(idxb + i)]
        i += 1
      return mosek.fusion.CompoundVariable(r,0)
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(174:15-266:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int],[int])")
  def _slice__3I_3I(self,first,last):
    if   (int(len(first)) != int(len(last))):
      raise mosek.fusion.LengthError("Mismatching array lengths")
    elif (int(len(first)) != self.shape.nd):
      raise mosek.fusion.SliceError("Slice has wrong number of dimensions")
    else:
      # src/fusion/CompoundVariable.mbi(183:11-187:12)
      for i in xrange(0,int(len(first))):
        if   (((first[i] < 0) or (first[i] > last[i])) or (last[i] > ( self.shape._dim_I(i) ))):
          raise mosek.fusion.SliceError("Slice index is out of bounds")
    isnull = False

    # { @ src/fusion/CompoundVariable.mbi(190:9-194:9)
    # src/fusion/CompoundVariable.mbi(191:11-195:12)
    i = 0

    while (i < int(len(first))):
      if   (first[i] >= last[i]):
        isnull = True
      i += 1
    # } @ src/fusion/CompoundVariable.mbi(190:9-194:9)
    if   isnull:
      nd = int(len(first))

      resdims = ([ 0 for _autovar_52 in xrange(nd) ])

      # src/fusion/CompoundVariable.mbi(199:11-203:29)
      i = 0

      while (i < nd):
        if   (first[i] < last[i]):
          resdims[i] = (last[i] - first[i])
        else:
          resdims[i] = 0
        i += 1
      return mosek.fusion.SliceVariable(self,mosek.fusion.NDSet(resdims),0l,([ 0l for _autovar_53 in xrange(nd) ]))
    elif (int(len(first)) == 1):
      return ( self._slice_II(first[0],last[0]) )
    else:
      nd = self.shape.nd

      subslicefirst = ([ 0 for _autovar_54 in xrange(nd) ])

      subslicelast = ([ 0 for _autovar_55 in xrange(nd) ])





      # { @ src/fusion/CompoundVariable.mbi(216:11-224:11)
      i = 0

      # src/fusion/CompoundVariable.mbi(218:13-54)
      while (first[self.__stackdim] >= self.__varsb[(i + 1)]):
        i += 1
      idxb = i
      offsetb = (first[self.__stackdim] - int(self.__varsb[i]))
      # src/fusion/CompoundVariable.mbi(221:13-59)
      while (last[self.__stackdim] > int(self.__varsb[(i + 1)])):
        i += 1
      idxe = i
      offsete = (last[self.__stackdim] - int(self.__varsb[i]))
      # } @ src/fusion/CompoundVariable.mbi(216:11-224:11)
      # src/fusion/CompoundVariable.mbi(226:11-230:11)
      i = 0

      while (i < nd):
        subslicefirst[i] = first[i]
        subslicelast[i] = last[i]
        i += 1
      if   (idxb == idxe):
        subslicefirst[self.__stackdim] = offsetb
        subslicelast[self.__stackdim] = offsete
        return ( self.__vars[idxb]._slice__3I_3I(subslicefirst,subslicelast) )
      else:
        r = ([ None for _autovar_56 in xrange(((idxe - idxb) + 1)) ])

        subslicefirst[self.__stackdim] = offsetb
        subslicelast[self.__stackdim] = ( self.__vars[idxb].shape._dim_I(self.__stackdim) )
        r[0] = ( self.__vars[idxb]._slice__3I_3I(subslicefirst,subslicelast) )
        subslicefirst[self.__stackdim] = 0
        subslicelast[self.__stackdim] = offsete
        r[(int(len(r)) - 1)] = ( self.__vars[idxe]._slice__3I_3I(subslicefirst,subslicelast) )
        # src/fusion/CompoundVariable.mbi(255:13-261:13)
        i = 1

        while (i < (int(len(r)) - 1)):
          subslicefirst[self.__stackdim] = 0
          subslicelast[self.__stackdim] = ( self.__vars[(i + idxb)].shape._dim_I(self.__stackdim) )
          r[i] = ( self.__vars[(i + idxb)]._slice__3I_3I(subslicefirst,subslicelast) )
          i += 1
        return mosek.fusion.CompoundVariable(r,self.__stackdim)
  @staticmethod
  def _matchargs_asExpr_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(269:15-276:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("asExpr()")
  def _asExpr_(self):
    ptrb = ( Utils.Tools._range_LL (0l,(self.shape._size + 1)) )

    sub = ( Utils.Tools._range_LL (0l,self.shape._size) )

    cof = ( Utils.Tools._ones_I (int(self.shape._size)) )

    return mosek.fusion.Expr(ptrb,self,sub,cof,None,self.shape,None,1)
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(281:18-307:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    tmp_indexes = ([ 0l for _autovar_57 in xrange(1) ])

    index = ([ 0 for _autovar_58 in xrange(self.shape.nd) ])

    # src/fusion/CompoundVariable.mbi(288:9-306:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/CompoundVariable.mbi(289:9-306:9)
      # { @ src/fusion/CompoundVariable.mbi(290:11-297:11)
      tmpval = long(idxs[i])

      # src/fusion/CompoundVariable.mbi(292:13-296:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundVariable.mbi(293:13-296:13)
        index[k] = int((tmpval / ( self.shape._stride_I(k) )))
        tmpval = (tmpval - (long(index[k]) * ( self.shape._stride_I(k) )))
        # } @ src/fusion/CompoundVariable.mbi(293:13-296:13)
      # } @ src/fusion/CompoundVariable.mbi(290:11-297:11)
      # { @ src/fusion/CompoundVariable.mbi(299:11-305:11)
      vidx = 0

      # src/fusion/CompoundVariable.mbi(301:13-60)
      while (index[self.__stackdim] >= self.__varsb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__varsb[vidx])
      tmp_indexes[0] = ( self.__vars[vidx].shape._linearidx__3I(index) )
      ( self.__vars[vidx]._level_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundVariable.mbi(299:11-305:11)
      # } @ src/fusion/CompoundVariable.mbi(289:9-306:9)
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(310:18-369:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    n = int(len(strides))

    totalsize = nsize[0]

    # src/fusion/CompoundVariable.mbi(318:9-69)
    for i in xrange(1,int(len(nsize))):
      totalsize = (totalsize * nsize[i])
    st = ([ 0l for _autovar_59 in xrange(int(len(nsize))) ])

    # src/fusion/CompoundVariable.mbi(327:36-77)
    for i in xrange(0,int(len(nsize))):
      st[i] = start
    ii = ([ 0 for _autovar_60 in xrange(int(len(nsize))) ])

    index = ([ 0 for _autovar_61 in xrange(self.shape.nd) ])

    cumdim = ([ 0l for _autovar_62 in xrange(self.shape.nd) ])

    cumdim[(self.shape.nd - 1)] = 1l
    # src/fusion/CompoundVariable.mbi(330:62-155)
    for i in xrange(1,self.shape.nd):
      cumdim[((self.shape.nd - i) - 1)] = (cumdim[(self.shape.nd - i)] * ( self.shape._dim_I((self.shape.nd - i)) ))
    tmp_indexes = ([ 0l for _autovar_63 in xrange(1) ])

    # src/fusion/CompoundVariable.mbi(334:9-368:9)
    for i in xrange(0,totalsize):
      # { @ src/fusion/CompoundVariable.mbi(335:9-368:9)
      # { @ src/fusion/CompoundVariable.mbi(337:11-344:11)
      tmpval = st[0]

      # src/fusion/CompoundVariable.mbi(339:13-343:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundVariable.mbi(340:13-343:13)
        index[k] = int((tmpval / cumdim[k]))
        tmpval = (tmpval - (long(index[k]) * cumdim[k]))
        # } @ src/fusion/CompoundVariable.mbi(340:13-343:13)
      # } @ src/fusion/CompoundVariable.mbi(337:11-344:11)
      # { @ src/fusion/CompoundVariable.mbi(347:11-353:11)
      vidx = 0

      # src/fusion/CompoundVariable.mbi(349:13-60)
      while (index[self.__stackdim] >= self.__varsb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__varsb[vidx])
      tmp_indexes[0] = ( self.__vars[vidx].shape._linearidx__3I(index) )
      ( self.__vars[vidx]._level_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundVariable.mbi(347:11-353:11)
      # { @ src/fusion/CompoundVariable.mbi(356:11-367:11)
      ii[0] += 1
      st[0] = (st[0] + strides[(n - 1)])
      j = 0

      # src/fusion/CompoundVariable.mbi(360:13-363:13)
      j = 0
      while ((j < (n - 1)) and (ii[j] == nsize[j])):
        ii[j] = 0
        ii[(j + 1)] += 1
        j += 1
      # src/fusion/CompoundVariable.mbi(365:13-366:27)
      for k in xrange(0,j):
        st[k] = st[j]
      # } @ src/fusion/CompoundVariable.mbi(356:11-367:11)
      # } @ src/fusion/CompoundVariable.mbi(335:9-368:9)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(375:18-401:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    tmp_indexes = ([ 0l for _autovar_64 in xrange(1) ])

    index = ([ 0 for _autovar_65 in xrange(self.shape.nd) ])

    # src/fusion/CompoundVariable.mbi(382:9-400:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/CompoundVariable.mbi(383:9-400:9)
      # { @ src/fusion/CompoundVariable.mbi(384:11-391:11)
      tmpval = long(idxs[i])

      # src/fusion/CompoundVariable.mbi(386:13-390:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundVariable.mbi(387:13-390:13)
        index[k] = int((tmpval / ( self.shape._stride_I(k) )))
        tmpval = (tmpval - (long(index[k]) * ( self.shape._stride_I(k) )))
        # } @ src/fusion/CompoundVariable.mbi(387:13-390:13)
      # } @ src/fusion/CompoundVariable.mbi(384:11-391:11)
      # { @ src/fusion/CompoundVariable.mbi(393:11-399:11)
      vidx = 0

      # src/fusion/CompoundVariable.mbi(395:13-60)
      while (index[self.__stackdim] >= self.__varsb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__varsb[vidx])
      tmp_indexes[0] = ( self.__vars[vidx].shape._linearidx__3I(index) )
      ( self.__vars[vidx]._dual_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundVariable.mbi(393:11-399:11)
      # } @ src/fusion/CompoundVariable.mbi(383:9-400:9)
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(404:18-463:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    n = int(len(strides))

    totalsize = nsize[0]

    # src/fusion/CompoundVariable.mbi(412:9-69)
    for i in xrange(1,int(len(nsize))):
      totalsize = (totalsize * nsize[i])
    st = ([ 0l for _autovar_66 in xrange(int(len(nsize))) ])

    # src/fusion/CompoundVariable.mbi(421:36-77)
    for i in xrange(0,int(len(nsize))):
      st[i] = start
    ii = ([ 0 for _autovar_67 in xrange(int(len(nsize))) ])

    index = ([ 0 for _autovar_68 in xrange(self.shape.nd) ])

    cumdim = ([ 0l for _autovar_69 in xrange(self.shape.nd) ])

    cumdim[(self.shape.nd - 1)] = 1l
    # src/fusion/CompoundVariable.mbi(424:62-155)
    for i in xrange(1,self.shape.nd):
      cumdim[((self.shape.nd - i) - 1)] = (cumdim[(self.shape.nd - i)] * ( self.shape._dim_I((self.shape.nd - i)) ))
    tmp_indexes = ([ 0l for _autovar_70 in xrange(1) ])

    # src/fusion/CompoundVariable.mbi(428:9-462:9)
    for i in xrange(0,totalsize):
      # { @ src/fusion/CompoundVariable.mbi(429:9-462:9)
      # { @ src/fusion/CompoundVariable.mbi(431:11-438:11)
      tmpval = st[0]

      # src/fusion/CompoundVariable.mbi(433:13-437:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundVariable.mbi(434:13-437:13)
        index[k] = int((tmpval / cumdim[k]))
        tmpval = (tmpval - (long(index[k]) * cumdim[k]))
        # } @ src/fusion/CompoundVariable.mbi(434:13-437:13)
      # } @ src/fusion/CompoundVariable.mbi(431:11-438:11)
      # { @ src/fusion/CompoundVariable.mbi(441:11-447:11)
      vidx = 0

      # src/fusion/CompoundVariable.mbi(443:13-60)
      while (index[self.__stackdim] >= self.__varsb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__varsb[vidx])
      tmp_indexes[0] = ( self.__vars[vidx].shape._linearidx__3I(index) )
      ( self.__vars[vidx]._dual_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundVariable.mbi(441:11-447:11)
      # { @ src/fusion/CompoundVariable.mbi(450:11-461:11)
      ii[0] += 1
      st[0] = (st[0] + strides[(n - 1)])
      j = 0

      # src/fusion/CompoundVariable.mbi(454:13-457:13)
      j = 0
      while ((j < (n - 1)) and (ii[j] == nsize[j])):
        ii[j] = 0
        ii[(j + 1)] += 1
        j += 1
      # src/fusion/CompoundVariable.mbi(459:13-460:27)
      for k in xrange(0,j):
        st[k] = st[j]
      # } @ src/fusion/CompoundVariable.mbi(450:11-461:11)
      # } @ src/fusion/CompoundVariable.mbi(429:9-462:9)
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(467:18-481:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int],[int],[int])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    if   ((index < 0l) or (index >= self.shape._size)):
      raise mosek.fusion.IndexError("Index out of bounds.")
    key = ( self.shape._idxtokey_L(index) )

    i = 0

    # src/fusion/CompoundVariable.mbi(477:20-59)
    while (key[self.__stackdim] >= self.__varsb[(i + 1)]):
      i += 1
    key[self.__stackdim] = (key[self.__stackdim] - self.__varsb[i])
    ( self.__vars[i]._inst_LL_3I_3I_3I(( self.__vars[i].shape._linearidx__3I(key) ),offset,nindex,nsubi,nsubj) )
  @staticmethod
  def _matchargs_elementName_LOmosek_fusion_Utils_StringBuffer_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],long): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Utils.StringBuffer): return False
    return True
  # origin: src/fusion/CompoundVariable.mbi(484:18-493:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("elementName(long,mosek.fusion.Utils.StringBuffer)")
  def _elementName_LOmosek_fusion_Utils_StringBuffer_2(self,index,sb):
    if   ((index < 0l) or (index >= self.shape._size)):
      raise mosek.fusion.IndexError("Index out of bounds.")
    key = ( self.shape._idxtokey_L(index) )

    i = 0

    # src/fusion/CompoundVariable.mbi(489:20-59)
    while (key[self.__stackdim] >= self.__varsb[(i + 1)]):
      i += 1
    key[self.__stackdim] = (key[self.__stackdim] - self.__varsb[i])
    ( self.__vars[i]._elementName_LOmosek_fusion_Utils_StringBuffer_2(( self.__vars[i].shape._linearidx__3I(key) ),sb) )
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlevel()"),(1,"\tlevel(int)"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int]])"),(1,"\tpick([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   CompoundVariable._matchargs_slice_II(args):
      return CompoundVariable._slice_II(self,*args)
    elif CompoundVariable._matchargs_slice__3I_3I(args):
      return CompoundVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_III(args):
      return Variable._index_III(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tindex(int,int,int)"),(2,"\tindex(int,int)"),(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    elif Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdual()"),(2,"\tdual([int],[int])"),(2,"\tdual(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Variable._matchargs_toString_(args):
      return Variable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Variable._matchargs_flatten_Omosek_fusion_Variable_2(args):
      return Variable._flatten_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def asExpr(self,*args):
    if   CompoundVariable._matchargs_asExpr_(args):
      return CompoundVariable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/ModelVariable.mbi(11:5-96:5)
class ModelVariable(Variable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(args):
    if len(args) != 4:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    if not isinstance(args[3],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,long) @ src/fusion/ModelVariable.mbi(24:18-32:7)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(self,model_,name_,shape_,varid_):
    mosek.fusion.Variable._Variable__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,model_,shape_)
    self._name = name_
    self._varid = varid_
  def __init__(self,*args):
    #self._protected_name = None

    #self._protected_varid = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(*args)
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/ModelVariable.mbi(40:15-49:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    if   (self.shape.nd != 1):
      raise mosek.fusion.DimensionError("Wrong size of slice")
    strides = ([ 1l])

    return mosek.fusion.SliceVariable(self,( self.shape._slice_II(first,last) ),long(first),strides)
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/ModelVariable.mbi(52:15-70:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int],[int])")
  def _slice__3I_3I(self,first,last):
    if   (int(len(first)) != int(len(last))):
      raise mosek.fusion.LengthError("Mismatching array lengths")
    shp = ( self.shape._slice__3I_3I(first,last) )

    strides = ([ 0l for _autovar_71 in xrange(self.shape.nd) ])

    strides[(self.shape.nd - 1)] = 1l
    # src/fusion/ModelVariable.mbi(59:9-60:51)
    i = (self.shape.nd - 1)

    while (i > 0):
      strides[(i - 1)] = (strides[i] * ( self.shape._dim_I(i) ))
      i = (i - 1)
    firstidx = 0l

    # src/fusion/ModelVariable.mbi(63:9-64:56)
    i = 0

    while (i < int(len(strides))):
      firstidx = (firstidx + (strides[i] * first[i]))
      i += 1
    return mosek.fusion.SliceVariable(self,shp,firstidx,strides)
  @staticmethod
  def _matchargs_elementName_LOmosek_fusion_Utils_StringBuffer_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],long): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Utils.StringBuffer): return False
    return True
  # origin: src/fusion/ModelVariable.mbi(73:18-79:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("elementName(long,mosek.fusion.Utils.StringBuffer)")
  def _elementName_LOmosek_fusion_Utils_StringBuffer_2(self,index,sb):
    if   (self._name == None):
      ( sb._a_S("_") )
    else:
      ( sb._a_S(self._name) )
    ( ( ( sb._a_S("[") )._a_S(( self.shape._indexToString_L(index) )) )._a_S("]") )
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/ModelVariable.mbi(83:15-94:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( sb._a_S("Variable(") )
    if   (self._name != None):
      ( ( ( sb._a_S("name='") )._a_S(self._name) )._a_S("'; ") )
    ( ( sb._a_S("dimensions=") )._a_I(( self.shape._dim_I(0) )) )
    # src/fusion/ModelVariable.mbi(89:9-90:36)
    for i in xrange(1,self.shape.nd):
      ( ( sb._a_S(",") )._a_I(( self.shape._dim_I(i) )) )
    ( ( sb._a_S("; size=") )._a_L(self.shape._size) )
    ( sb._a_S(")") )
    return ( sb._toString_() )
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlevel()"),(1,"\tlevel(int)"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int]])"),(1,"\tpick([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_III(args):
      return Variable._index_III(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tindex(int,int,int)"),(2,"\tindex(int,int)"),(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    elif Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdual()"),(2,"\tdual([int],[int])"),(2,"\tdual(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Variable._matchargs_flatten_Omosek_fusion_Variable_2(args):
      return Variable._flatten_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/LinearVariable.mbi(21:5-300:5)
class LinearVariable(ModelVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(args):
    if len(args) != 6:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Set): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[5],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Domain,mosek.fusion.Set,[int],long) @ src/fusion/LinearVariable.mbi(34:18-49:7)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(self,model_,name_,dom_,shape_,nativeidxs_,varid_):
    mosek.fusion.ModelVariable._ModelVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(self,model_,name_,shape_,varid_)
    self.__nativeidxs = nativeidxs_
    if   (nativeidxs_ == None):
      self.__idxmap = mosek.fusion.Utils.IntMap()
    else:
      self.__idxmap = None
    self.__dom = dom_
  def __init__(self,*args):
    #self.__idxmap = None

    #self.__nativeidxs = None

    #self.__dom = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(*args)
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearVariable.mbi(52:18-78:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self.__nativeidxs != None):
      # src/fusion/LinearVariable.mbi(59:11-60:55)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = xx[self.__nativeidxs[idxs[i]]]
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/LinearVariable.mbi(64:11-76:13)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = xx[( self.__idxmap._getItem_L(idxs[i]) )]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1rhs_1item_L(idxs[i]) )
          else:
            target[(offset + i)] = 0.0
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearVariable.mbi(81:18-123:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/LinearVariable.mbi(93:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self.__nativeidxs != None):
      # src/fusion/LinearVariable.mbi(96:11-100:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/LinearVariable.mbi(97:11-100:11)
        target[(i + offset)] = xx[self.__nativeidxs[( cnt._get_() )]]
        ( cnt._inc_() )
        # } @ src/fusion/LinearVariable.mbi(97:11-100:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/LinearVariable.mbi(105:11-121:11)
      for i in xrange(0,int(tlen)):
        # { @ src/fusion/LinearVariable.mbi(106:11-121:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[(offset + i)] = xx[( self.__idxmap._getItem_L(( cnt._get_() )) )]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1rhs_1item_L(( cnt._get_() )) )
          else:
            target[(offset + i)] = 0.0
        ( cnt._inc_() )
        # } @ src/fusion/LinearVariable.mbi(106:11-121:11)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearVariable.mbi(128:18-161:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    slx = ( self._model._getSolution_1slx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    sux = ( self._model._getSolution_1sux_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self.__nativeidxs != None):
      # src/fusion/LinearVariable.mbi(136:11-140:11)
      for i in xrange(0,int(len(idxs))):
        # { @ src/fusion/LinearVariable.mbi(137:11-140:11)
        ni = self.__nativeidxs[idxs[i]]

        target[(offset + i)] = (slx[ni] - sux[ni])
        # } @ src/fusion/LinearVariable.mbi(137:11-140:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/LinearVariable.mbi(144:11-159:13)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          ni = ( self.__idxmap._getItem_L(idxs[i]) )

          target[(offset + i)] = (slx[ni] - sux[ni])
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1rhs_1item_L(idxs[i]) )
          else:
            target[(offset + i)] = 0.0
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearVariable.mbi(164:18-213:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    slx = ( self._model._getSolution_1slx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    sux = ( self._model._getSolution_1sux_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/LinearVariable.mbi(178:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self.__nativeidxs != None):
      # src/fusion/LinearVariable.mbi(181:11-187:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/LinearVariable.mbi(182:11-187:11)
        ni = self.__nativeidxs[( cnt._get_() )]

        target[(i + offset)] = (slx[ni] - sux[ni])
        ( cnt._inc_() )
        # } @ src/fusion/LinearVariable.mbi(182:11-187:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/LinearVariable.mbi(192:11-211:11)
      for i in xrange(0,int(tlen)):
        # { @ src/fusion/LinearVariable.mbi(193:11-211:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          ni = ( self.__idxmap._getItem_L(( cnt._get_() )) )

          target[(offset + i)] = (slx[ni] - sux[ni])
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1rhs_1item_L(( cnt._get_() )) )
          else:
            target[(offset + i)] = 0.0
        ( cnt._inc_() )
        # } @ src/fusion/LinearVariable.mbi(193:11-211:11)
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/LinearVariable.mbi(223:18-256:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int],[int],[int])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    if   (self.__nativeidxs != None):
      nindex[offset] = self.__nativeidxs[index]
    else:
      if   (not ( self.__idxmap._hasItem_L(index) )):
        tmpname = None

        if   (self._name != None):
          tmpname = ( ( ( ( ( mosek.fusion.Utils.StringBuffer()._a_S(self._name) )._a_S("[") )._a_S(( self.shape._getname_L(index) )) )._a_S("]") )._toString_() )
        v = self

        nidx = ( self._model._append_1linearvar_Omosek_fusion_ModelVariable_2LSOmosek_fusion_RelationKey_2F(v,index,tmpname,self.__dom._key,( self.__dom._get_1rhs_1item_L(index) )) )

        ( self.__idxmap._setItem_LI(index,nidx) )
        nindex[offset] = nidx
      else:
        nindex[offset] = ( self.__idxmap._getItem_L(index) )
  @staticmethod
  def _matchargs_inst__3LIILL_3I_3I_3I(args):
    if len(args) != 8:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/LinearVariable.mbi(259:18-299:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst([long],int,int,long,long,[int],[int],[int])")
  def _inst__3LIILL_3I_3I_3I(self,index,first_idx,last_idx,index_offset,dst_offset,dst_nindex,dst_nsubi,dst_nsubj):
    if   (self.__nativeidxs != None):
      # src/fusion/LinearVariable.mbi(271:11-272:98)
      for i in xrange(first_idx,last_idx):
        dst_nindex[(dst_offset + long((i - first_idx)))] = self.__nativeidxs[index[(long(i) - index_offset)]]
    else:
      # src/fusion/LinearVariable.mbi(276:11-296:11)
      for i in xrange(first_idx,last_idx):
        # { @ src/fusion/LinearVariable.mbi(277:11-296:11)
        if   (not ( self.__idxmap._hasItem_L(index[(long(i) - index_offset)]) )):
          tmpname = None

          if   (self._name != None):
            tmpname = ( ( ( ( ( mosek.fusion.Utils.StringBuffer()._a_S(self._name) )._a_S("[") )._a_S(( self.shape._getname_L(index[(long(i) - index_offset)]) )) )._a_S("]") )._toString_() )
          v = self

          nidx = ( self._model._append_1linearvar_Omosek_fusion_ModelVariable_2LSOmosek_fusion_RelationKey_2F(v,index[(long(i) - index_offset)],tmpname,self.__dom._key,( self.__dom._get_1rhs_1item_L(index[(long(i) - index_offset)]) )) )

          ( self.__idxmap._setItem_LI(index[(long(i) - index_offset)],nidx) )
          dst_nindex[(dst_offset + long((i - first_idx)))] = nidx
        else:
          dst_nindex[(dst_offset + long((i - first_idx)))] = ( self.__idxmap._getItem_L(index[(long(i) - index_offset)]) )
        # } @ src/fusion/LinearVariable.mbi(277:11-296:11)
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index_III(args):
      return Variable._index_III(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(1,"\tindex([int])"),(2,"\tindex(int,int)"),(3,"\tindex(int,int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlevel()"),(1,"\tlevel(int)"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int]])"),(1,"\tpick([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Variable._matchargs_flatten_Omosek_fusion_Variable_2(args):
      return Variable._flatten_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/IntegerVariable.mbi(13:5-72:5)
class IntegerLinearVariable(LinearVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(args):
    if len(args) != 6:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Set): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[5],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Domain,mosek.fusion.Set,[int],long) @ src/fusion/IntegerVariable.mbi(17:18-30:7)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(self,model_,name_,dom_,shape_,nativeidxs_,varid_):
    mosek.fusion.LinearVariable._LinearVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(self,model_,name_,dom_,shape_,nativeidxs_,varid_)
    if   (nativeidxs_ != None):
      ( model_._task_1var_1putintlist__3I(nativeidxs_) )
  def __init__(self,*args):
    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IL(*args)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(33:18-39:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    raise mosek.fusion.SolutionError("No dual solution available for integer variables")
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(43:18-51:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    raise mosek.fusion.SolutionError("No dual solution available for integer variables")
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(54:18-62:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int],[int],[int])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    ( LinearVariable._inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj) )
    ( self._model._task_1var_1putintlist__3I(([ nindex[offset]])) )
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlevel()"),(1,"\tlevel(int)"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int]])"),(1,"\tpick([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_III(args):
      return Variable._index_III(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tindex(int,int,int)"),(2,"\tindex(int,int)"),(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    elif Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdual()"),(2,"\tdual([int],[int])"),(2,"\tdual(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Variable._matchargs_flatten_Omosek_fusion_Variable_2(args):
      return Variable._flatten_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/RangedVariable.mbi(18:5-455:5)
class RangedVariable(ModelVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(args):
    if len(args) != 6:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.RangeDomain): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[5],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,[int],long) @ src/fusion/RangedVariable.mbi(35:18-49:7)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(self,model_,name_,shape_,dom_,nativeidxs_,varid_):
    mosek.fusion.ModelVariable._ModelVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(self,model_,name_,shape_,varid_)
    self.__nativeidxs = nativeidxs_
    if   (nativeidxs_ == None):
      self.__idxmap = mosek.fusion.Utils.IntMap()
    else:
      self.__idxmap = None
    self.__dom = dom_
  def __init__(self,*args):
    #self.__idxmap = None

    #self.__dom = None

    #self.__nativeidxs = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(*args)
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(54:18-80:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(61:11-62:55)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = xx[self.__nativeidxs[idxs[i]]]
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(66:11-78:13)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = xx[( self.__idxmap._getItem_L(idxs[i]) )]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
          else:
            target[(offset + i)] = 0.0
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(82:18-124:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedVariable.mbi(94:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(97:11-101:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedVariable.mbi(98:11-101:11)
        target[(i + offset)] = xx[self.__nativeidxs[( cnt._get_() )]]
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(98:11-101:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(106:11-122:11)
      for i in xrange(0,int(tlen)):
        # { @ src/fusion/RangedVariable.mbi(107:11-122:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = xx[( self.__idxmap._getItem_L(( cnt._get_() )) )]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
          else:
            target[(offset + i)] = 0.0
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(107:11-122:11)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(127:18-160:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    slx = ( self._model._getSolution_1slx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    sux = ( self._model._getSolution_1sux_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(135:11-139:11)
      for i in xrange(0,int(len(idxs))):
        # { @ src/fusion/RangedVariable.mbi(136:11-139:11)
        ni = self.__nativeidxs[idxs[i]]

        target[(offset + i)] = (slx[ni] - sux[ni])
        # } @ src/fusion/RangedVariable.mbi(136:11-139:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(143:11-158:13)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          ni = ( self.__idxmap._getItem_L(idxs[i]) )

          target[(offset + i)] = (slx[ni] - sux[ni])
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
          else:
            target[(offset + i)] = 0.0
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(162:18-210:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    slx = ( self._model._getSolution_1slx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    sux = ( self._model._getSolution_1sux_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedVariable.mbi(175:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(178:11-184:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedVariable.mbi(179:11-184:11)
        ni = self.__nativeidxs[( cnt._get_() )]

        target[(i + offset)] = (slx[ni] - sux[ni])
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(179:11-184:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(189:11-208:11)
      for i in xrange(0,int(tlen)):
        # { @ src/fusion/RangedVariable.mbi(190:11-208:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          ni = ( self.__idxmap._getItem_L(( cnt._get_() )) )

          target[i] = (slx[ni] - sux[ni])
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
          else:
            target[(offset + i)] = 0.0
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(190:11-208:11)
  @staticmethod
  def _matchargs_dual_1l__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(215:18-247:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_l([long],int,[float])")
  def _dual_1l__3LI_3F(self,idxs,offset,target):
    slx = ( self._model._getSolution_1slx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(222:11-226:11)
      for i in xrange(0,int(len(idxs))):
        # { @ src/fusion/RangedVariable.mbi(223:11-226:11)
        ni = self.__nativeidxs[idxs[i]]

        target[(offset + i)] = slx[ni]
        # } @ src/fusion/RangedVariable.mbi(223:11-226:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(230:11-245:13)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          ni = ( self.__idxmap._getItem_L(idxs[i]) )

          target[(offset + i)] = slx[ni]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
          else:
            target[(offset + i)] = 0.0
  @staticmethod
  def _matchargs_dual_1l_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(249:18-295:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_l(long,[int],[long],int,[float])")
  def _dual_1l_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    slx = ( self._model._getSolution_1slx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedVariable.mbi(261:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(264:11-269:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedVariable.mbi(265:11-269:11)
        ni = self.__nativeidxs[( cnt._get_() )]

        target[(i + offset)] = slx[ni]
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(265:11-269:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(274:11-293:11)
      for i in xrange(0,int(tlen)):
        # { @ src/fusion/RangedVariable.mbi(275:11-293:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          ni = ( self.__idxmap._getItem_L(( cnt._get_() )) )

          target[i] = slx[ni]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
          else:
            target[(offset + i)] = 0.0
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(275:11-293:11)
  @staticmethod
  def _matchargs_dual_1u__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(300:18-332:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_u([long],int,[float])")
  def _dual_1u__3LI_3F(self,idxs,offset,target):
    sux = ( self._model._getSolution_1sux_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(307:11-311:11)
      for i in xrange(0,int(len(idxs))):
        # { @ src/fusion/RangedVariable.mbi(308:11-311:11)
        ni = self.__nativeidxs[idxs[i]]

        target[(offset + i)] = sux[ni]
        # } @ src/fusion/RangedVariable.mbi(308:11-311:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(315:11-330:13)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          ni = ( self.__idxmap._getItem_L(idxs[i]) )

          target[(offset + i)] = sux[ni]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
          else:
            target[(offset + i)] = 0.0
  @staticmethod
  def _matchargs_dual_1u_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(335:18-382:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_u(long,[int],[long],int,[float])")
  def _dual_1u_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    sux = ( self._model._getSolution_1sux_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedVariable.mbi(347:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self.__nativeidxs != None):
      # src/fusion/RangedVariable.mbi(350:11-356:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedVariable.mbi(351:11-356:11)
        ni = self.__nativeidxs[( cnt._get_() )]

        target[(i + offset)] = sux[ni]
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(351:11-356:11)
    else:
      pst = ( self._model._getPrimalSolutionStatus_() )

      # src/fusion/RangedVariable.mbi(361:11-380:11)
      for i in xrange(0,int(tlen)):
        # { @ src/fusion/RangedVariable.mbi(362:11-380:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          ni = ( self.__idxmap._getItem_L(( cnt._get_() )) )

          target[i] = sux[ni]
        else:
          if   ((((pst == SolutionStatus.Optimal) or (pst == SolutionStatus.NearOptimal)) or (pst == SolutionStatus.Feasible)) or (pst == SolutionStatus.NearFeasible)):
            target[(offset + i)] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
          else:
            target[(offset + i)] = 0.0
        ( cnt._inc_() )
        # } @ src/fusion/RangedVariable.mbi(362:11-380:11)
  @staticmethod
  def _matchargs_lowerBoundVar_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/RangedVariable.mbi(392:15-401:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("lowerBoundVar()")
  def _lowerBoundVar_(self):
    strides = ([ 0l for _autovar_72 in xrange(self.shape.nd) ])

    strides[(self.shape.nd - 1)] = 1l
    # src/fusion/RangedVariable.mbi(395:9-398:9)
    i = (self.shape.nd - 1)

    while (i > 0):
      strides[(i - 1)] = (strides[i] * long(( self.shape._dim_I(i) )))
      i -= 1
    return mosek.fusion.BoundInterfaceVariable(self,self.shape,0l,strides,True)
  @staticmethod
  def _matchargs_upperBoundVar_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/RangedVariable.mbi(407:15-417:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("upperBoundVar()")
  def _upperBoundVar_(self):
    strides = ([ 0l for _autovar_73 in xrange(self.shape.nd) ])

    strides[(self.shape.nd - 1)] = 1l
    # src/fusion/RangedVariable.mbi(411:9-414:9)
    i = (self.shape.nd - 1)

    while (i > 0):
      strides[(i - 1)] = (strides[i] * long(( self.shape._dim_I(i) )))
      i -= 1
    return mosek.fusion.BoundInterfaceVariable(self,self.shape,0l,strides,False)
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/RangedVariable.mbi(421:18-453:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int],[int],[int])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    if   ((index < 0l) or (index >= self.shape._size)):
      raise mosek.fusion.IndexError("Index out of bounds")
    if   (self.__nativeidxs != None):
      nindex[offset] = self.__nativeidxs[index]
    else:
      if   (not ( self.__idxmap._hasItem_L(index) )):
        s = None

        if   (self._name != None):
          s = ( ( ( ( ( mosek.fusion.Utils.StringBuffer()._a_S(self._name) )._a_S("[") )._a_S(( self.shape._getname_L(index) )) )._a_S("]") )._toString_() )
        v = self

        nidx = ( self._model._append_1rangedvar_Omosek_fusion_ModelVariable_2LSFF(v,index,s,( self.__dom._get_1lb_1item_L(index) ),( self.__dom._get_1ub_1item_L(index) )) )

        ( self.__idxmap._setItem_LI(index,nidx) )
        nindex[offset] = nidx
      else:
        nindex[offset] = ( self.__idxmap._getItem_L(index) )
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def lowerBoundVar(self,*args):
    if   RangedVariable._matchargs_lowerBoundVar_(args):
      return RangedVariable._lowerBoundVar_(self,*args)
    else:
      argtypestr = "lowerBoundVar(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlowerBoundVar()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def upperBoundVar(self,*args):
    if   RangedVariable._matchargs_upperBoundVar_(args):
      return RangedVariable._upperBoundVar_(self,*args)
    else:
      argtypestr = "upperBoundVar(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tupperBoundVar()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Variable._matchargs_flatten_Omosek_fusion_Variable_2(args):
      return Variable._flatten_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index_III(args):
      return Variable._index_III(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int])"),(1,"\tindex(int)"),(2,"\tindex(int,int)"),(3,"\tindex(int,int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlevel()"),(1,"\tlevel(int)"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int]])"),(1,"\tpick([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/IntegerVariable.mbi(132:5-183:5)
class IntegerRangedVariable(RangedVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(args):
    if len(args) != 6:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.RangeDomain): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[5],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,[int],long) @ src/fusion/IntegerVariable.mbi(136:18-149:7)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(self,model_,name_,shape_,dom_,nativeidxs_,varid_):
    mosek.fusion.RangedVariable._RangedVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(self,model_,name_,shape_,dom_,nativeidxs_,varid_)
    if   (nativeidxs_ != None):
      ( model_._task_1var_1putintlist__3I(nativeidxs_) )
  def __init__(self,*args):
    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3IL(*args)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(152:18-158:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    raise mosek.fusion.SolutionError("No dual solution available for integer variables")
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(162:18-170:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    raise mosek.fusion.SolutionError("No dual solution available for integer variables")
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(173:18-181:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int],[int],[int])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    ( RangedVariable._inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj) )
    ( self._model._task_1var_1putintlist__3I(([ nindex[offset]])) )
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def lowerBoundVar(self,*args):
    if   RangedVariable._matchargs_lowerBoundVar_(args):
      return RangedVariable._lowerBoundVar_(self,*args)
    else:
      argtypestr = "lowerBoundVar(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlowerBoundVar()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def upperBoundVar(self,*args):
    if   RangedVariable._matchargs_upperBoundVar_(args):
      return RangedVariable._upperBoundVar_(self,*args)
    else:
      argtypestr = "upperBoundVar(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tupperBoundVar()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Variable._matchargs_flatten_Omosek_fusion_Variable_2(args):
      return Variable._flatten_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    elif Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdual()"),(2,"\tdual([int],[int])"),(2,"\tdual(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index_III(args):
      return Variable._index_III(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(3,"\tindex(int,int,int)"),(2,"\tindex(int,int)"),(1,"\tindex([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlevel()"),(1,"\tlevel(int)"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int]])"),(1,"\tpick([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/SemidefiniteVariable.mbi(8:5-167:5)
class PSDVariable(ModelVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SIIIL(args):
    if len(args) != 6:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    if not isinstance(args[5],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,int,int,int,long) @ src/fusion/SemidefiniteVariable.mbi(22:18-34:7)")
  def __constructor_Omosek_fusion_Model_2SIIIL(self,model_,name_,conesize_,coneidx_,num_,varid_):
    mosek.fusion.ModelVariable._ModelVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(self,model_,name_,mosek.fusion.NDSet(conesize_,conesize_),varid_)
    self.__conesize = conesize_
    self.__coneidx = coneidx_
    self.__numcones = num_
  def __init__(self,*args):
    #self.__conesize = None

    #self.__coneidx = None

    #self.__numcones = None

    self.__constructor_Omosek_fusion_Model_2SIIIL(*args)
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteVariable.mbi(37:18-56:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    barx = ( self._model._getSolution_1barx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteVariable.mbi(44:9-55:9)
    for p in xrange(0,int(len(idxs))):
      # { @ src/fusion/SemidefiniteVariable.mbi(45:9-55:9)
      k = (idxs[p] / blocksize)

      lidx = (idxs[p] - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = barx[(long(self.__coneidx) + k)][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = barx[(long(self.__coneidx) + k)][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteVariable.mbi(45:9-55:9)
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteVariable.mbi(59:18-89:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    barx = ( self._model._getSolution_1barx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteVariable.mbi(72:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/SemidefiniteVariable.mbi(73:9-88:9)
    for p in xrange(0l,tlen):
      # { @ src/fusion/SemidefiniteVariable.mbi(74:9-88:9)
      # { @ src/fusion/SemidefiniteVariable.mbi(75:11-86:11)
      k = (( cnt._get_() ) / blocksize)

      lidx = (( cnt._get_() ) - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = barx[(long(self.__coneidx) + k)][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = barx[(long(self.__coneidx) + k)][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteVariable.mbi(75:11-86:11)
      ( cnt._inc_() )
      # } @ src/fusion/SemidefiniteVariable.mbi(74:9-88:9)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteVariable.mbi(92:18-111:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    bars = ( self._model._getSolution_1bars_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteVariable.mbi(99:9-110:9)
    for p in xrange(0,int(len(idxs))):
      # { @ src/fusion/SemidefiniteVariable.mbi(100:9-110:9)
      k = (idxs[p] / blocksize)

      lidx = (idxs[p] - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = bars[(long(self.__coneidx) + k)][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = bars[(long(self.__coneidx) + k)][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteVariable.mbi(100:9-110:9)
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteVariable.mbi(114:18-145:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    bars = ( self._model._getSolution_1bars_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteVariable.mbi(127:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/SemidefiniteVariable.mbi(128:9-144:9)
    for p in xrange(0l,tlen):
      # { @ src/fusion/SemidefiniteVariable.mbi(129:9-144:9)
      # { @ src/fusion/SemidefiniteVariable.mbi(130:11-141:11)
      k = (( cnt._get_() ) / blocksize)

      lidx = (( cnt._get_() ) - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = bars[(long(self.__coneidx) + k)][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = bars[(long(self.__coneidx) + k)][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteVariable.mbi(130:11-141:11)
      ( cnt._inc_() )
      # } @ src/fusion/SemidefiniteVariable.mbi(129:9-144:9)
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/SemidefiniteVariable.mbi(148:18-166:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int],[int],[int])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    if   ((index < 0) or (index >= self.shape._size)):
      raise mosek.fusion.IndexError("Index out of bounds")
    coneoffset = int((index / (self.__conesize * self.__conesize)))

    matrixoffset = (index - ((self.__conesize * self.__conesize) * coneoffset))

    nindex[offset] = (- ((1 + self.__coneidx) + coneoffset))
    i = (int(matrixoffset) / ( self.shape._dim_I(1) ))

    j = (int(matrixoffset) - int((i * ( self.shape._dim_I(1) ))))

    if   (i >= j):
      nsubi[offset] = i
      nsubj[offset] = j
    else:
      nsubi[offset] = j
      nsubj[offset] = i
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index_III(args):
      return Variable._index_III(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(1,"\tindex([int])"),(2,"\tindex(int,int)"),(3,"\tindex(int,int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlevel()"),(1,"\tlevel(int)"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int]])"),(1,"\tpick([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Variable._matchargs_flatten_Omosek_fusion_Variable_2(args):
      return Variable._flatten_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/ConicVariable.mbi(18:5-156:5)
class ConicVariable(ModelVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(args):
    if len(args) != 8:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[4],int): return False
    if not isinstance(args[5],int): return False
    if not isinstance(args[6],int): return False
    if not isinstance(args[7],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,[int],int,int,int,long) @ src/fusion/ConicVariable.mbi(30:18-44:7)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,varid_):
    mosek.fusion.ModelVariable._ModelVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2L(self,model_,name_,shape_,varid_)
    self.__conesize = conesize_
    self.__coneidx = firstcone_
    self.__numcone = numcone_
    self.__nativeidxs = nativeidxs_
  def __init__(self,*args):
    #self.__coneidx = None

    #self.__conesize = None

    #self.__numcone = None

    #self.__nativeidxs = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(*args)
  @staticmethod
  def _matchargs_get_1variable_1index_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(47:18-52:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get_variable_index(int)")
  def _get_1variable_1index_I(self,idx):
    if   (idx >= int(len(self.__nativeidxs))):
      raise mosek.fusion.IndexError("Variable index out of range")
    else:
      return self.__nativeidxs[idx]
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(55:18-63:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicVariable.mbi(61:9-62:53)
    for i in xrange(0,int(len(idxs))):
      target[(offset + i)] = xx[self.__nativeidxs[idxs[i]]]
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(66:18-84:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicVariable.mbi(78:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/ConicVariable.mbi(79:9-83:9)
    for i in xrange(0l,tlen):
      # { @ src/fusion/ConicVariable.mbi(80:9-83:9)
      target[(i + offset)] = xx[self.__nativeidxs[( cnt._get_() )]]
      ( cnt._inc_() )
      # } @ src/fusion/ConicVariable.mbi(80:9-83:9)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(88:18-96:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    snx = ( self._model._getSolution_1snx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicVariable.mbi(94:9-95:54)
    for i in xrange(0,int(len(idxs))):
      target[(offset + i)] = snx[self.__nativeidxs[idxs[i]]]
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(99:18-117:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    snx = ( self._model._getSolution_1snx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    # src/fusion/ConicVariable.mbi(111:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/ConicVariable.mbi(112:9-116:9)
    for i in xrange(0l,tlen):
      # { @ src/fusion/ConicVariable.mbi(113:9-116:9)
      target[(i + offset)] = snx[self.__nativeidxs[( cnt._get_() )]]
      ( cnt._inc_() )
      # } @ src/fusion/ConicVariable.mbi(113:9-116:9)
  @staticmethod
  def _matchargs_inst_LL_3I_3I_3I(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(120:18-129:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst(long,long,[int],[int],[int])")
  def _inst_LL_3I_3I_3I(self,index,offset,nindex,nsubi,nsubj):
    if   ((index < 0) or (index >= long(len(self.__nativeidxs)))):
      raise mosek.fusion.IndexError("Index out of bounds")
    nindex[offset] = self.__nativeidxs[index]
  @staticmethod
  def _matchargs_inst__3LIILL_3I_3I_3I(args):
    if len(args) != 8:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(132:18-147:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inst([long],int,int,long,long,[int],[int],[int])")
  def _inst__3LIILL_3I_3I_3I(self,index,first_idx,last_idx,index_offset,dst_offset,dst_nindex,dst_nsubi,dst_nsubj):
    if   (self.__nativeidxs != None):
      # src/fusion/ConicVariable.mbi(144:11-145:98)
      for i in xrange(first_idx,last_idx):
        dst_nindex[(dst_offset + long((i - first_idx)))] = self.__nativeidxs[index[(long(i) - index_offset)]]
  @staticmethod
  def _matchargs_instantiate_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/ConicVariable.mbi(150:18-155:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("instantiate(long)")
  def _instantiate_L(self,index):
    if   ((index < 0) or (index >= long(len(self.__nativeidxs)))):
      raise mosek.fusion.IndexError("Index out of bounds")
    return self.__nativeidxs[index]
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index_III(args):
      return Variable._index_III(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex(int)"),(1,"\tindex([int])"),(2,"\tindex(int,int)"),(3,"\tindex(int,int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlevel()"),(1,"\tlevel(int)"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int]])"),(1,"\tpick([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Variable._matchargs_flatten_Omosek_fusion_Variable_2(args):
      return Variable._flatten_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    elif Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/IntegerVariable.mbi(81:5-123:5)
class IntegerConicVariable(ConicVariable):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(args):
    if len(args) != 8:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[4],int): return False
    if not isinstance(args[5],int): return False
    if not isinstance(args[6],int): return False
    if not isinstance(args[7],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,[int],int,int,int,long) @ src/fusion/IntegerVariable.mbi(85:18-101:7)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,varid_):
    mosek.fusion.ConicVariable._ConicVariable__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,varid_)
    if   (nativeidxs_ != None):
      ( model_._task_1var_1putintlist__3I(nativeidxs_) )
  def __init__(self,*args):
    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIIIL(*args)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(104:18-110:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    raise mosek.fusion.SolutionError("No dual solution available for integer variables")
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/IntegerVariable.mbi(114:18-122:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    raise mosek.fusion.SolutionError("No dual solution available for integer variables")
  @staticmethod
  @_cliptrace
  def symmetric(*args):
    if   Variable._matchargs_symmetric_Omosek_fusion_Variable_2(args):
      return Variable._symmetric_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "symmetric(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsymmetric(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def repeat(*args):
    if   Variable._matchargs_repeat_Omosek_fusion_Variable_2I(args):
      return Variable._repeat_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "repeat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\trepeat(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_hstack__3Omosek_fusion_Variable_2(args):
      return Variable._hstack__3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\thstack([mosek.fusion.Variable])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Variable._matchargs_level_(args):
      return Variable._level_(self,*args)
    elif Variable._matchargs_level_I(args):
      return Variable._level_I(self,*args)
    elif Variable._matchargs_level__3I_3I(args):
      return Variable._level__3I_3I(self,*args)
    elif Variable._matchargs_level_II(args):
      return Variable._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlevel()"),(1,"\tlevel(int)"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index_flat(self,*args):
    if   Variable._matchargs_index_1flat_L(args):
      return Variable._index_1flat_L(self,*args)
    else:
      argtypestr = "index_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex_flat(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def diag(self,*args):
    if   Variable._matchargs_diag_(args):
      return Variable._diag_(self,*args)
    elif Variable._matchargs_diag_I(args):
      return Variable._diag_I(self,*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdiag()"),(1,"\tdiag(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick(self,*args):
    if   Variable._matchargs_pick__3_3I(args):
      return Variable._pick__3_3I(self,*args)
    elif Variable._matchargs_pick__3I(args):
      return Variable._pick__3I(self,*args)
    else:
      argtypestr = "pick(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick([[int]])"),(1,"\tpick([int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Variable._matchargs_transpose_(args):
      return Variable._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def pick_flat(self,*args):
    if   Variable._matchargs_pick_1flat__3L(args):
      return Variable._pick_1flat__3L(self,*args)
    else:
      argtypestr = "pick_flat(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tpick_flat([long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack__3Omosek_fusion_Variable_2(args):
      return Variable._vstack__3Omosek_fusion_Variable_2(*args)
    elif Variable._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tvstack([mosek.fusion.Variable])"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   ModelVariable._matchargs_slice_II(args):
      return ModelVariable._slice_II(self,*args)
    elif ModelVariable._matchargs_slice__3I_3I(args):
      return ModelVariable._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Variable._matchargs_index_III(args):
      return Variable._index_III(self,*args)
    elif Variable._matchargs_index_II(args):
      return Variable._index_II(self,*args)
    elif Variable._matchargs_index__3I(args):
      return Variable._index__3I(self,*args)
    elif Variable._matchargs_index_I(args):
      return Variable._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tindex(int,int,int)"),(2,"\tindex(int,int)"),(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def antidiag(self,*args):
    if   Variable._matchargs_antidiag_I(args):
      return Variable._antidiag_I(self,*args)
    elif Variable._matchargs_antidiag_(args):
      return Variable._antidiag_(self,*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tantidiag(int)"),(0,"\tantidiag()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Variable._matchargs_dual_(args):
      return Variable._dual_(self,*args)
    elif Variable._matchargs_dual__3I_3I(args):
      return Variable._dual__3I_3I(self,*args)
    elif Variable._matchargs_dual_II(args):
      return Variable._dual_II(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdual()"),(2,"\tdual([int],[int])"),(2,"\tdual(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Variable._matchargs_reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      return Variable._reshape_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2II(args):
      return Variable._reshape_Omosek_fusion_Variable_2II(*args)
    elif Variable._matchargs_reshape_Omosek_fusion_Variable_2I(args):
      return Variable._reshape_Omosek_fusion_Variable_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Variable,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Variable,int,int)"),(2,"\treshape(mosek.fusion.Variable,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   ModelVariable._matchargs_toString_(args):
      return ModelVariable._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Variable._matchargs_flatten_Omosek_fusion_Variable_2(args):
      return Variable._flatten_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Variable._matchargs_size_(args):
      return Variable._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Variable._matchargs_stack__3_3Omosek_fusion_Variable_2(args):
      return Variable._stack__3_3Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Variable]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def asExpr(self,*args):
    if   Variable._matchargs_asExpr_(args):
      return Variable._asExpr_(self,*args)
    else:
      argtypestr = "asExpr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tasExpr()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compress(self,*args):
    if   Variable._matchargs_compress_(args):
      return Variable._compress_(self,*args)
    else:
      argtypestr = "compress(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tcompress()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Constraint.mbi(51:5-729:5)
class Constraint:
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,mosek.fusion.Set) @ src/fusion/Constraint.mbi(65:15-71:7)")
  def __constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,model_,shape_):
    self._model = model_
    self.shape = shape_
    self._shape_p = shape_
  def __init__(self,*args):
    #self._protected_model = None

    #self.shape = None

    #self._protected_shape_p = None

    self.__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(*args)
  @staticmethod
  def _matchargs_reduceDims_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Constraint.mbi(75:16-85:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("reduceDims()")
  def __reduceDims_(self):
    if   (self.shape.nd > 1):
      ndim = ( self.shape._realnd_() )

      d = ([ 0 for _autovar_74 in xrange(ndim) ])

      # { @ src/fusion/Constraint.mbi(80:11-111)
      j = 0

      # src/fusion/Constraint.mbi(80:24-109)
      i = 0

      while (i < ndim):
        if   (( self.shape._dim_I(i) ) > 1):
          d[j] = ( self.shape._dim_I(i) )
          j += 1
        i += 1
      # } @ src/fusion/Constraint.mbi(80:11-111)
      self.shape = mosek.fusion.NDSet(d)
      self._shape_p = self.shape
    return self
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Constraint.mbi(104:15-8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    pass
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(120:15-8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int],[int])")
  def _slice__3I_3I(self,first,last):
    pass
  @staticmethod
  def _matchargs_index_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Constraint.mbi(127:15-129:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index(int)")
  def _index_I(self,idx):
    return ( self._slice_II(idx,(idx + 1)) )
  @staticmethod
  def _matchargs_index__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(136:15-140:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("index([int])")
  def _index__3I(self,idx):
    idxplusone = ( Utils.Tools._arraycopy__3I (idx) )

    # src/fusion/Constraint.mbi(138:9-59)
    i = 0

    while (i < int(len(idx))):
      idxplusone[i] += 1
      i += 1
    return ( ( self._slice__3I_3I(idx,idxplusone) ).__reduceDims_() )
  @staticmethod
  def _matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Constraint): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Constraint): return False
    return True
  # origin: src/fusion/Constraint.mbi(155:15-162:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stack(mosek.fusion.Constraint,mosek.fusion.Constraint)")
  def _stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(v1,v2):

    vs = ([ None for _autovar_75 in xrange(2) ])
    vs[0] = v1
    vs[1] = v2
    return mosek.fusion.CompoundConstraint(vs)
  @staticmethod
  def _matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Constraint): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Constraint): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Constraint): return False
    return True
  # origin: src/fusion/Constraint.mbi(177:15-185:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")
  def _stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(v1,v2,v3):

    vs = ([ None for _autovar_76 in xrange(2) ])
    vs[0] = v1
    vs[1] = v2
    return mosek.fusion.CompoundConstraint(vs)
  @staticmethod
  def _matchargs_stack__3Omosek_fusion_Constraint_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Constraint): return False
    return True
  # origin: src/fusion/Constraint.mbi(200:15-203:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("stack([mosek.fusion.Constraint])")
  def _stack__3Omosek_fusion_Constraint_2(clist):
    return mosek.fusion.CompoundConstraint(clist)
  @staticmethod
  def _matchargs_size_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Constraint.mbi(209:15-211:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("size()")
  def _size_(self):
    return self._shape_p._size
  @staticmethod
  def _matchargs_get_1nd_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Constraint.mbi(216:15-218:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("get_nd()")
  def _get_1nd_(self):
    return self._shape_p._nd_p
  @staticmethod
  def _matchargs_get_1model_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Constraint.mbi(223:15-225:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("get_model()")
  def _get_1model_(self):
    return self._model
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(257:18-263:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    pass
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(266:18-270:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    pass
  @staticmethod
  def _matchargs_level_1values_I_3F(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(278:18-287:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(int,[float])")
  def _level_1values_I_3F(self,offset,target):
    strides = ([ 0l for _autovar_77 in xrange(self.shape.nd) ])

    dims = ([ 0 for _autovar_78 in xrange(self.shape.nd) ])

    # src/fusion/Constraint.mbi(284:9-65)
    for i in xrange(0,self.shape.nd):
      strides[i] = ( self.shape._stride_I(i) )
    # src/fusion/Constraint.mbi(285:9-62)
    for i in xrange(0,self.shape.nd):
      dims[i] = ( self.shape._dim_I(i) )
    ( self._level_1values_L_3I_3LI_3F(0l,dims,strides,offset,target) )
  @staticmethod
  def _matchargs_level_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Constraint.mbi(305:15-321:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level(int,int)")
  def _level_II(self,firstidx,lastidx):
    if   ((((self.shape.nd != 1) or (firstidx < 0)) or (firstidx > lastidx)) or (lastidx > ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = (lastidx - firstidx)

    res = ([ 0.0 for _autovar_79 in xrange(num) ])

    dims = ([ (lastidx - firstidx)])

    strides = ([ 1l])

    ( self._level_1values_L_3I_3LI_3F(long(firstidx),dims,strides,0,res) )
    return res
  @staticmethod
  def _matchargs_level__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(340:15-374:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level([int],[int])")
  def _level__3I_3I(self,firstidx,lastidx):
    if   ((self.shape.nd != int(len(firstidx))) or (self.shape.nd != int(len(lastidx)))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = 1

    # src/fusion/Constraint.mbi(350:9-357:9)
    i = 0

    while (i < self.shape.nd):
      if   (((firstidx[i] > lastidx[i]) or (firstidx[i] < 0)) or (lastidx[i] > ( self.shape._dim_I(i) ))):
        raise mosek.fusion.SliceError("Slice index out of bound")
      num = (num * (lastidx[i] - firstidx[i]))
      i += 1
    res = ([ 0.0 for _autovar_80 in xrange(num) ])

    if   (num > 0):
      dims = ([ 0 for _autovar_81 in xrange(self.shape.nd) ])

      strides = ([ 0l for _autovar_82 in xrange(self.shape.nd) ])

      # src/fusion/Constraint.mbi(364:11-65)
      for i in xrange(0,self.shape.nd):
        strides[i] = ( self.shape._stride_I(i) )
      # src/fusion/Constraint.mbi(365:11-74)
      for i in xrange(0,self.shape.nd):
        dims[i] = (lastidx[i] - firstidx[i])
      start = 0l

      # src/fusion/Constraint.mbi(368:11-369:60)
      for i in xrange(0,self.shape.nd):
        start = (start + (long(firstidx[i]) * strides[i]))
      ( self._level_1values_L_3I_3LI_3F(start,dims,strides,0,res) )
    return res
  @staticmethod
  def _matchargs_level_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Constraint.mbi(391:15-400:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level(int)")
  def _level_I(self,index):
    if   (((self.shape.nd != 1) or (index < 0)) or (index >= ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Invalid index.")
    idxs = ([ long(index)])

    res = ([ 0.0 for _autovar_83 in xrange(1) ])

    ( self._level_1values__3LI_3F(idxs,0,res) )
    return res[0]
  @staticmethod
  def _matchargs_level_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Constraint.mbi(411:15-418:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("level()")
  def _level_(self):
    res = ([ 0.0 for _autovar_84 in xrange(self.shape._size) ])

    if   (self.shape._size > 0):
      ( self._level_1values_I_3F(0,res) )
    return res
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(451:18-457:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    pass
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(460:18-464:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    pass
  @staticmethod
  def _matchargs_dual_1values_I_3F(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(468:18-481:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(int,[float])")
  def _dual_1values_I_3F(self,offset,target):
    nsize = ([ 0 for _autovar_85 in xrange(self.shape.nd) ])

    strides = ([ 0l for _autovar_86 in xrange(self.shape.nd) ])

    # src/fusion/Constraint.mbi(474:9-478:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/Constraint.mbi(475:9-478:9)
      nsize[i] = ( self.shape._dim_I(i) )
      strides[i] = ( self.shape._stride_I(i) )
      # } @ src/fusion/Constraint.mbi(475:9-478:9)
    ( self._dual_1values_L_3I_3LI_3F(0l,nsize,strides,offset,target) )
  @staticmethod
  def _matchargs_dual_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Constraint.mbi(492:15-496:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("dual()")
  def _dual_(self):
    res = ([ 0.0 for _autovar_87 in xrange(self.shape._size) ])

    ( self._dual_1values_I_3F(0,res) )
    return res
  @staticmethod
  def _matchargs_dual_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Constraint.mbi(516:15-529:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual(int,int)")
  def _dual_II(self,firstidx,lastidx):
    if   ((((self.shape.nd != 1) or (firstidx > lastidx)) or (firstidx < 0)) or (lastidx >= ( self.shape._dim_I(0) ))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = (lastidx - firstidx)

    res = ([ 0.0 for _autovar_88 in xrange(num) ])

    ( self._dual_1values_L_3I_3LI_3F(long(firstidx),([ num]),([ 1l]),0,res) )
    return res
  @staticmethod
  def _matchargs_dual__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(548:15-576:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual([int],[int])")
  def _dual__3I_3I(self,firstidx,lastidx):
    if   ((self.shape.nd != int(len(firstidx))) or (self.shape.nd != int(len(lastidx)))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    num = 1

    # src/fusion/Constraint.mbi(555:9-562:9)
    i = 0

    while (i < self.shape.nd):
      if   (((firstidx[i] > lastidx[i]) or (firstidx[i] < 0)) or (lastidx[i] >= ( self.shape._dim_I(i) ))):
        raise mosek.fusion.SliceError("Slice index out of bound")
      num = (num * (lastidx[i] * firstidx[i]))
      i += 1
    res = ([ 0.0 for _autovar_89 in xrange(num) ])

    nsize = ([ 0 for _autovar_90 in xrange(self.shape.nd) ])

    strides = ([ 0l for _autovar_91 in xrange(self.shape.nd) ])

    firstelm = 0l

    # src/fusion/Constraint.mbi(567:9-572:9)
    for i in xrange(0,self.shape.nd):
      # { @ src/fusion/Constraint.mbi(568:9-572:9)
      nsize[i] = (lastidx[i] - firstidx[i])
      strides[i] = ( self.shape._stride_I(i) )
      firstelm = (firstelm + (strides[i] * firstidx[i]))
      # } @ src/fusion/Constraint.mbi(568:9-572:9)
    ( self._dual_1values_L_3I_3LI_3F(firstelm,nsize,strides,0,res) )
    return res
  @staticmethod
  def _matchargs_add_1l__3L_3L_3I_3I_3I_3F_3FLII(args):
    if len(args) != 10:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[7],long): return False
    if not isinstance(args[8],int): return False
    if not isinstance(args[9],int): return False
    return True
  # origin: src/fusion/Constraint.mbi(607:18-620:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_l([long],[long],[int],[int],[int],[float],[float],long,int,int)")
  def _add_1l__3L_3L_3I_3I_3I_3F_3FLII(self,subi,ptrb,subj,subk,subl,cof,bfix,subibase,srcoffset,num):
    raise mosek.fusion.UnimplementedError("add_l not implemented")
  @staticmethod
  def _matchargs_add_Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Constraint.mbi(630:15-661:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Expression)")
  def _add_Omosek_fusion_Expression_2(self,expr):
    if   (not ( expr._shape._compare_Omosek_fusion_Set_2(self.shape) )):
      raise mosek.fusion.DimensionError("The added expression does not have the same shape as the constraint")
    e = ( expr._eval_() )

    nrows = (int(len(e.ptrb)) - 1)

    tmpsubj = ([ 0 for _autovar_92 in xrange(e.nnz) ])

    tmpsubk = ([ 0 for _autovar_93 in xrange(e.nnz) ])

    tmpsubl = ([ 0 for _autovar_94 in xrange(e.nnz) ])

    # src/fusion/Constraint.mbi(642:9-643:58)
    for i in xrange(0l,e.nnz):
      ( e.x._inst_LL_3I_3I_3I(e.subj[i],i,tmpsubj,tmpsubk,tmpsubl) )
    subi = e.inst

    if   (subi == None):
      subi = ( Utils.Tools._range_LL (0l,long(nrows)) )
    ( self._add_1l__3L_3L_3I_3I_3I_3F_3FLII(subi,e.ptrb,tmpsubj,tmpsubk,tmpsubl,e.cof,e.bfix,0l,0,nrows) )
    return self
  @staticmethod
  def _matchargs_add_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Constraint.mbi(671:15-704:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Variable)")
  def _add_Omosek_fusion_Variable_2(self,v):
    if   (not ( v.shape._compare_Omosek_fusion_Set_2(self.shape) )):
      raise mosek.fusion.DimensionError("The added variable does not have the same shape as the constraint")
    nrows = v.shape._size

    tmpsubj = ([ 0 for _autovar_95 in xrange(nrows) ])

    tmpsubk = ([ 0 for _autovar_96 in xrange(nrows) ])

    tmpsubl = ([ 0 for _autovar_97 in xrange(nrows) ])

    ptrb = ( Utils.Tools._range_LL (0l,(nrows + 1)) )

    cof = ([ 0.0 for _autovar_98 in xrange(nrows) ])

    # src/fusion/Constraint.mbi(682:9-686:9)
    for i in xrange(0l,nrows):
      # { @ src/fusion/Constraint.mbi(683:9-686:9)
      ( v._inst_LL_3I_3I_3I(i,i,tmpsubj,tmpsubk,tmpsubl) )
      cof[i] = 1.0
      # } @ src/fusion/Constraint.mbi(683:9-686:9)
    subi = ( Utils.Tools._range_LL (0l,nrows) )

    ( self._add_1l__3L_3L_3I_3I_3I_3F_3FLII(subi,ptrb,tmpsubj,tmpsubk,tmpsubk,cof,None,0l,0,int(nrows)) )
    return self
  @staticmethod
  def _matchargs_toStringArray__3LL_3S(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_basestring(a): return False
    return True
  # origin: src/fusion/Constraint.mbi(712:18-715:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("toStringArray([long],long,[basestring])")
  def _toStringArray__3LL_3S(self,subi,dstidx,result):
    pass
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Constraint.mbi(718:15-728:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    size = self.shape._size

    res = ([ None for _autovar_99 in xrange(size) ])

    ( self._toStringArray__3LL_3S(( Utils.Tools._range_L (size) ),0l,res) )
    sb = mosek.fusion.Utils.StringBuffer()

    ( sb._a_S(res[0]) )
    # src/fusion/Constraint.mbi(725:9-726:30)
    for i in xrange(1,int(len(res))):
      ( ( sb._a_S(",") )._a_S(res[i]) )
    return ( sb._toString_() )
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   Constraint._matchargs_slice_II(args):
      return Constraint._slice_II(self,*args)
    elif Constraint._matchargs_slice__3I_3I(args):
      return Constraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Constraint._matchargs_toString_(args):
      return Constraint._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/SliceConstraint.mbi(17:5-363:5)
class SliceConstraint(Constraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_ModelConstraint_2Omosek_fusion_Set_2L_3L(args):
    if len(args) != 4:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.ModelConstraint): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if not isinstance(args[2],long): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.ModelConstraint,mosek.fusion.Set,long,[long]) @ src/fusion/SliceConstraint.mbi(26:18-35:7)")
  def __constructor_Omosek_fusion_ModelConstraint_2Omosek_fusion_Set_2L_3L(self,origin_,shape_,first_,strides_):
    mosek.fusion.Constraint._Constraint__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,origin_._model,shape_)
    self._origin = origin_
    self._first = first_
    self._strides = strides_
  def __init__(self,*args):
    #self._protected_origin = None

    #self._protected_first = None

    #self._protected_strides = None

    self.__constructor_Omosek_fusion_ModelConstraint_2Omosek_fusion_Set_2L_3L(*args)
  @staticmethod
  def _matchargs_slice_1_Omosek_fusion_Set_2L_3L(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(38:18-43:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice_(mosek.fusion.Set,long,[long])")
  def _slice_1_Omosek_fusion_Set_2L_3L(self,shape_,first_,strides_):
    return mosek.fusion.SliceConstraint(self._origin,shape_,first_,strides_)
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(46:15-51:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,firstidx,lastidx):
    shp = ( self.shape._slice_II(firstidx,lastidx) )

    return ( self._slice_1_Omosek_fusion_Set_2L_3L(shp,(self._first + firstidx),self._strides) )
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(53:15-61:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int],[int])")
  def _slice__3I_3I(self,firstidx,lastidx):
    shp = ( self.shape._slice__3I_3I(firstidx,lastidx) )

    newfirst = self._first

    # src/fusion/SliceConstraint.mbi(58:9-59:62)
    i = 0

    while (i < int(len(firstidx))):
      newfirst = (newfirst + (long(firstidx[i]) * self._strides[i]))
      i += 1
    return ( self._slice_1_Omosek_fusion_Set_2L_3L(shp,newfirst,self._strides) )
  @staticmethod
  def _matchargs_size_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(67:15-69:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("size()")
  def _size_(self):
    return self.shape._size
  @staticmethod
  def _matchargs_toStringArray__3LL_3S(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_basestring(a): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(73:18-89:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("toStringArray([long],long,[basestring])")
  def _toStringArray__3LL_3S(self,subi,dstidx,result):
    tmpsubi = ([ 0l for _autovar_100 in xrange(int(len(subi))) ])

    # src/fusion/SliceConstraint.mbi(79:9-86:9)
    for i in xrange(0,int(len(subi))):
      # { @ src/fusion/SliceConstraint.mbi(80:9-86:9)
      key = ( self.shape._idxtokey_L(subi[i]) )

      tmpi = 0l

      # src/fusion/SliceConstraint.mbi(83:11-84:53)
      for j in xrange(0,self.shape.nd):
        tmpi = (tmpi + (long(key[j]) * self._strides[j]))
      tmpsubi[i] = tmpi
      # } @ src/fusion/SliceConstraint.mbi(80:9-86:9)
    ( self._origin._toStringArray__3LL_3S(tmpsubi,dstidx,result) )
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(97:18-113:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    tmpidxs = ([ 0l for _autovar_101 in xrange(int(len(idxs))) ])

    # src/fusion/SliceConstraint.mbi(103:9-110:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/SliceConstraint.mbi(104:9-110:9)
      index = ( self.shape._idxtokey_L(idxs[i]) )

      tmpi = 0l

      # src/fusion/SliceConstraint.mbi(107:11-108:55)
      for j in xrange(0,self.shape.nd):
        tmpi = (tmpi + (long(index[j]) * self._strides[j]))
      tmpidxs[i] = tmpi
      # } @ src/fusion/SliceConstraint.mbi(104:9-110:9)
    ( self._origin._level_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(116:18-191:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides_,offset,target):
    if   ((((start == 0l) and (int(len(nsize)) == 1)) and (nsize[0] == self.shape._size)) and (strides_[0] == 1)):
      tmp_nsize = ([ 0 for _autovar_102 in xrange(self.shape.nd) ])

      # src/fusion/SliceConstraint.mbi(127:43-96)
      for i in xrange(0,self.shape.nd):
        tmp_nsize[i] = ( self.shape._dim_I(i) )
      ( self._origin._level_1values_L_3I_3LI_3F(self._first,tmp_nsize,self._strides,offset,target) )
    else:
      n = int(len(nsize))

      is_compatible = (n == self.shape.nd)

      # src/fusion/SliceConstraint.mbi(134:11-135:59)
      i = 0

      while ((i < n) and is_compatible):
        is_compatible = (strides_[i] == ( self.shape._stride_I(i) ))
        i += 1
      if   is_compatible:
        slice_start = self._first

        # { @ src/fusion/SliceConstraint.mbi(140:13-148:13)
        tmp = start

        # src/fusion/SliceConstraint.mbi(142:15-147:15)
        for i in xrange(0,(self.shape.nd - 1)):
          # { @ src/fusion/SliceConstraint.mbi(143:15-147:15)
          dimiofs = (tmp / strides_[i])

          tmp = (tmp - (strides_[i] * dimiofs))
          slice_start = (slice_start + (( self.shape._stride_I(i) ) * dimiofs))
          # } @ src/fusion/SliceConstraint.mbi(143:15-147:15)
        # } @ src/fusion/SliceConstraint.mbi(140:13-148:13)
        ( self._origin._level_1values_L_3I_3LI_3F(slice_start,nsize,self._strides,offset,target) )
      else:
        totalsize = 1l

        # src/fusion/SliceConstraint.mbi(154:33-95)
        for i in xrange(0,int(len(nsize))):
          totalsize = (totalsize * nsize[i])
        tmpidxs = ([ 0l for _autovar_103 in xrange(totalsize) ])

        # { @ src/fusion/SliceConstraint.mbi(157:13-186:13)
        ii = ([ 0 for _autovar_104 in xrange(int(len(nsize))) ])

        st = ([ 0l for _autovar_105 in xrange(int(len(nsize))) ])

        # src/fusion/SliceConstraint.mbi(159:44-82)
        for j in xrange(0,int(len(nsize))):
          st[j] = 0l
        # src/fusion/SliceConstraint.mbi(160:15-185:15)
        for i in xrange(0l,totalsize):
          # { @ src/fusion/SliceConstraint.mbi(161:15-185:15)
          # { @ src/fusion/SliceConstraint.mbi(162:17-172:17)
          ofs = (start + st[0])

          oidx = 0l

          # src/fusion/SliceConstraint.mbi(165:19-170:19)
          for j in xrange(0,self.shape.nd):
            # { @ src/fusion/SliceConstraint.mbi(166:19-170:19)
            dimjofs = (ofs / ( self.shape._stride_I(j) ))

            oidx = (oidx + (self._strides[j] * dimjofs))
            ofs = (ofs - (dimjofs * ( self.shape._stride_I(j) )))
            # } @ src/fusion/SliceConstraint.mbi(166:19-170:19)
          tmpidxs[i] = oidx
          # } @ src/fusion/SliceConstraint.mbi(162:17-172:17)
          # { @ src/fusion/SliceConstraint.mbi(176:17-184:17)
          j = 0

          ii[0] += 1
          st[0] = (st[0] + strides_[(n - 1)])
          # src/fusion/SliceConstraint.mbi(178:20-182:20)
          while ((j < (n - 1)) and (ii[j] >= nsize[((n - j) - 1)])):
            st[j] = 0l
            st[j] = (st[j] + strides_[((n - j) - 1)])
            ii[j] = 0
            ii[(j + 1)] += 1
            j += 1
          # src/fusion/SliceConstraint.mbi(183:20-54)
          for k in xrange(0,j):
            st[k] = st[j]
          # } @ src/fusion/SliceConstraint.mbi(176:17-184:17)
          # } @ src/fusion/SliceConstraint.mbi(161:15-185:15)
        # } @ src/fusion/SliceConstraint.mbi(157:13-186:13)
        ( self._origin._level_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(199:18-215:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    tmpidxs = ([ 0l for _autovar_106 in xrange(int(len(idxs))) ])

    # src/fusion/SliceConstraint.mbi(205:9-212:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/SliceConstraint.mbi(206:9-212:9)
      index = ( self.shape._idxtokey_L(idxs[i]) )

      tmpi = 0l

      # src/fusion/SliceConstraint.mbi(209:11-210:55)
      for j in xrange(0,self.shape.nd):
        tmpi = (tmpi + (long(index[j]) * self._strides[j]))
      tmpidxs[i] = tmpi
      # } @ src/fusion/SliceConstraint.mbi(206:9-212:9)
    ( self._origin._dual_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(218:18-293:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides_,offset,target):
    if   ((((start == 0l) and (int(len(nsize)) == 1)) and (nsize[0] == self.shape._size)) and (strides_[0] == 1)):
      tmp_nsize = ([ 0 for _autovar_107 in xrange(self.shape.nd) ])

      # src/fusion/SliceConstraint.mbi(229:43-96)
      for i in xrange(0,self.shape.nd):
        tmp_nsize[i] = ( self.shape._dim_I(i) )
      ( self._origin._dual_1values_L_3I_3LI_3F(self._first,tmp_nsize,self._strides,offset,target) )
    else:
      n = int(len(nsize))

      is_compatible = (n == self.shape.nd)

      # src/fusion/SliceConstraint.mbi(236:11-237:59)
      i = 0

      while ((i < n) and is_compatible):
        is_compatible = (strides_[i] == ( self.shape._stride_I(i) ))
        i += 1
      if   is_compatible:
        slice_start = self._first

        # { @ src/fusion/SliceConstraint.mbi(242:13-250:13)
        tmp = start

        # src/fusion/SliceConstraint.mbi(244:15-249:15)
        for i in xrange(0,(self.shape.nd - 1)):
          # { @ src/fusion/SliceConstraint.mbi(245:15-249:15)
          dimiofs = (tmp / strides_[i])

          tmp = (tmp - (strides_[i] * dimiofs))
          slice_start = (slice_start + (( self.shape._stride_I(i) ) * dimiofs))
          # } @ src/fusion/SliceConstraint.mbi(245:15-249:15)
        # } @ src/fusion/SliceConstraint.mbi(242:13-250:13)
        ( self._origin._dual_1values_L_3I_3LI_3F(slice_start,nsize,self._strides,offset,target) )
      else:
        totalsize = 1l

        # src/fusion/SliceConstraint.mbi(256:33-95)
        for i in xrange(0,int(len(nsize))):
          totalsize = (totalsize * nsize[i])
        tmpidxs = ([ 0l for _autovar_108 in xrange(totalsize) ])

        # { @ src/fusion/SliceConstraint.mbi(259:13-288:13)
        ii = ([ 0 for _autovar_109 in xrange(int(len(nsize))) ])

        st = ([ 0l for _autovar_110 in xrange(int(len(nsize))) ])

        # src/fusion/SliceConstraint.mbi(261:44-82)
        for j in xrange(0,int(len(nsize))):
          st[j] = 0l
        # src/fusion/SliceConstraint.mbi(262:15-287:15)
        for i in xrange(0l,totalsize):
          # { @ src/fusion/SliceConstraint.mbi(263:15-287:15)
          # { @ src/fusion/SliceConstraint.mbi(264:17-274:17)
          ofs = (start + st[0])

          oidx = 0l

          # src/fusion/SliceConstraint.mbi(267:19-272:19)
          for j in xrange(0,self.shape.nd):
            # { @ src/fusion/SliceConstraint.mbi(268:19-272:19)
            dimjofs = (ofs / ( self.shape._stride_I(j) ))

            oidx = (oidx + (self._strides[j] * dimjofs))
            ofs = (ofs - (dimjofs * ( self.shape._stride_I(j) )))
            # } @ src/fusion/SliceConstraint.mbi(268:19-272:19)
          tmpidxs[i] = oidx
          # } @ src/fusion/SliceConstraint.mbi(264:17-274:17)
          # { @ src/fusion/SliceConstraint.mbi(278:17-286:17)
          j = 0

          ii[0] += 1
          st[0] = (st[0] + strides_[(n - 1)])
          # src/fusion/SliceConstraint.mbi(280:20-284:20)
          while ((j < (n - 1)) and (ii[j] >= nsize[((n - j) - 1)])):
            st[j] = 0l
            st[j] = (st[j] + strides_[((n - j) - 1)])
            ii[j] = 0
            ii[(j + 1)] += 1
            j += 1
          # src/fusion/SliceConstraint.mbi(285:20-54)
          for k in xrange(0,j):
            st[k] = st[j]
          # } @ src/fusion/SliceConstraint.mbi(278:17-286:17)
          # } @ src/fusion/SliceConstraint.mbi(263:15-287:15)
        # } @ src/fusion/SliceConstraint.mbi(259:13-288:13)
        ( self._origin._dual_1values__3LI_3F(tmpidxs,offset,target) )
  @staticmethod
  def _matchargs_add_1fx__3L_3FLII(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(296:18-318:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_fx([long],[float],long,int,int)")
  def _add_1fx__3L_3FLII(self,subi,bfix,subibase,srcoffset,num):
    sl_subi = ([ 0l for _autovar_111 in xrange(num) ])

    sl_bfix = ([ 0.0 for _autovar_112 in xrange(num) ])

    ( Utils.Tools._arraycopy__3FI_3FII (bfix,srcoffset,sl_bfix,0,num) )
    # src/fusion/SliceConstraint.mbi(308:9-315:9)
    for i in xrange(0,num):
      # { @ src/fusion/SliceConstraint.mbi(309:9-315:9)
      index = ( self.shape._idxtokey_L(subi[(srcoffset + i)]) )

      sl_index = 0l

      # src/fusion/SliceConstraint.mbi(312:11-89)
      for j in xrange(0,int(len(index))):
        sl_index = (sl_index + (long(index[j]) * self._strides[j]))
      sl_subi[i] = sl_index
      # } @ src/fusion/SliceConstraint.mbi(309:9-315:9)
    ( self._origin._add_1fx__3L_3FLII(sl_subi,sl_bfix,0l,0,num) )
  @staticmethod
  def _matchargs_add_1l__3L_3L_3I_3I_3I_3F_3FLII(args):
    if len(args) != 10:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[7],long): return False
    if not isinstance(args[8],int): return False
    if not isinstance(args[9],int): return False
    return True
  # origin: src/fusion/SliceConstraint.mbi(321:18-362:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_l([long],[long],[int],[int],[int],[float],[float],long,int,int)")
  def _add_1l__3L_3L_3I_3I_3I_3F_3FLII(self,subi,ptrb,subj,subk,subl,cof,bfix,subibase,srcoffset,num):
    numnz = (ptrb[(srcoffset + num)] - ptrb[srcoffset])

    sl_subi = ([ 0l for _autovar_113 in xrange(num) ])

    sl_ptrb = ([ 0l for _autovar_114 in xrange((num + 1)) ])

    sl_bfix = None

    if   (bfix != None):
      sl_bfix = ([ 0.0 for _autovar_115 in xrange(num) ])
    # src/fusion/SliceConstraint.mbi(339:9-62)
    for i in xrange(0,(num + 1)):
      sl_ptrb[i] = ptrb[(srcoffset + i)]
    if   (self.shape.nd == 1):
      # src/fusion/SliceConstraint.mbi(343:11-344:62)
      for i in xrange(0,num):
        sl_subi[i] = ((subi[(i + srcoffset)] - subibase) + self._first)
    else:
      # src/fusion/SliceConstraint.mbi(348:11-355:11)
      for i in xrange(0,num):
        # { @ src/fusion/SliceConstraint.mbi(349:11-355:11)
        index = ( self.shape._idxtokey_L((subi[(srcoffset + i)] - subibase)) )

        sl_index = 0l

        # src/fusion/SliceConstraint.mbi(352:13-91)
        for j in xrange(0,int(len(index))):
          sl_index = (sl_index + (long(index[j]) * self._strides[j]))
        sl_subi[i] = sl_index
        # } @ src/fusion/SliceConstraint.mbi(349:11-355:11)
    if   (bfix != None):
      ( Utils.Tools._arraycopy__3FI_3FII (bfix,srcoffset,sl_bfix,0,num) )
    ( self._origin._add_1l__3L_3L_3I_3I_3I_3F_3FLII(sl_subi,sl_ptrb,subj,subk,subl,cof,sl_bfix,0l,0,num) )
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   SliceConstraint._matchargs_slice_II(args):
      return SliceConstraint._slice_II(self,*args)
    elif SliceConstraint._matchargs_slice__3I_3I(args):
      return SliceConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Constraint._matchargs_toString_(args):
      return Constraint._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   SliceConstraint._matchargs_size_(args):
      return SliceConstraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/BoundInterfaceConstraint.mbi(21:5-71:5)
class BoundInterfaceConstraint(SliceConstraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_RangedConstraint_2Omosek_fusion_Set_2L_3LB(args):
    if len(args) != 5:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.RangedConstraint): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if not isinstance(args[2],long): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[4],bool): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.RangedConstraint,mosek.fusion.Set,long,[long],bool) @ src/fusion/BoundInterfaceConstraint.mbi(29:18-39:7)")
  def __constructor_Omosek_fusion_RangedConstraint_2Omosek_fusion_Set_2L_3LB(self,origin_,shape_,first_,strides_,islower_):
    mosek.fusion.SliceConstraint._SliceConstraint__constructor_Omosek_fusion_ModelConstraint_2Omosek_fusion_Set_2L_3L(self,origin_,shape_,first_,strides_)
    self.__origincon = origin_
    self.__islower = islower_
  def __init__(self,*args):
    #self.__islower = None

    #self.__origincon = None

    self.__constructor_Omosek_fusion_RangedConstraint_2Omosek_fusion_Set_2L_3LB(*args)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/BoundInterfaceConstraint.mbi(42:18-50:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    if   self.__islower:
      ( self.__origincon._dual_1l__3LI_3F(idxs,offset,target) )
    else:
      ( self.__origincon._dual_1u__3LI_3F(idxs,offset,target) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/BoundInterfaceConstraint.mbi(52:18-62:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides_,offset,target):
    if   self.__islower:
      ( self.__origincon._dual_1l_L_3I_3LI_3F(start,nsize,strides_,offset,target) )
    else:
      ( self.__origincon._dual_1u_L_3I_3LI_3F(start,nsize,strides_,offset,target) )
  @staticmethod
  def _matchargs_slice_1_Omosek_fusion_Set_2L_3L(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  # origin: src/fusion/BoundInterfaceConstraint.mbi(65:18-70:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice_(mosek.fusion.Set,long,[long])")
  def _slice_1_Omosek_fusion_Set_2L_3L(self,shape_,first_,strides_):
    return mosek.fusion.BoundInterfaceConstraint(self.__origincon,shape_,first_,strides_,self.__islower)
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   SliceConstraint._matchargs_slice_II(args):
      return SliceConstraint._slice_II(self,*args)
    elif SliceConstraint._matchargs_slice__3I_3I(args):
      return SliceConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Constraint._matchargs_toString_(args):
      return Constraint._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   SliceConstraint._matchargs_size_(args):
      return SliceConstraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/CompoundConstraint.mbi(17:5-438:5)
class CompoundConstraint(Constraint):
  @staticmethod
  def _matchargs_constructor__3Omosek_fusion_Constraint_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Constraint): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([mosek.fusion.Constraint]) @ src/fusion/CompoundConstraint.mbi(95:15-133:7)")
  def __constructor__3Omosek_fusion_Constraint_2(self,c):
    mosek.fusion.Constraint._Constraint__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,( CompoundConstraint.__model_1from_1con__3Omosek_fusion_Constraint_2 (c) ),( CompoundConstraint.__compute_1shape__3Omosek_fusion_Constraint_2I (c,0) ))
    dim = 0

    numnz = 0

    dimsize = 0

    # src/fusion/CompoundConstraint.mbi(102:9-114:9)
    i = 0

    while (i < int(len(c))):
      if   (c[i].shape._size == 1):
        numnz += 1
        dimsize += 1
      elif (c[i].shape._size > 1):
        numnz += 1
        dimsize = (dimsize + ( c[i].shape._dim_I(dim) ))
      i += 1
    self.__cons = ([ None for _autovar_116 in xrange(numnz) ])
    self.__consb = ([ 0 for _autovar_117 in xrange((numnz + 1)) ])
    self.__consb[0] = 0
    self.__stackdim = dim
    # { @ src/fusion/CompoundConstraint.mbi(121:9-132:9)
    j = 0

    # src/fusion/CompoundConstraint.mbi(123:11-133:12)
    i = 0

    while (i < int(len(c))):
      if   (c[i].shape._size > 0):
        self.__cons[j] = c[i]
        j += 1
        if   (c[i].shape._size == 1):
          self.__consb[(i + 1)] = (self.__consb[i] + 1)
        else:
          self.__consb[(i + 1)] = (self.__consb[i] + ( c[i].shape._dim_I(dim) ))
      i += 1
    # } @ src/fusion/CompoundConstraint.mbi(121:9-132:9)
  def __init__(self,*args):
    #self.__cons = None

    #self.__consb = None

    #self.__stackdim = None

    self.__constructor__3Omosek_fusion_Constraint_2(*args)
  @staticmethod
  def _matchargs_model_1from_1con__3Omosek_fusion_Constraint_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Constraint): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(30:16-33:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("model_from_con([mosek.fusion.Constraint])")
  def __model_1from_1con__3Omosek_fusion_Constraint_2(c):
    return c[0]._model
  @staticmethod
  def _matchargs_count_1numcon__3Omosek_fusion_Constraint_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Constraint): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(36:16-53:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("count_numcon([mosek.fusion.Constraint])")
  def __count_1numcon__3Omosek_fusion_Constraint_2(c):
    num = 0

    # src/fusion/CompoundConstraint.mbi(39:9-51:9)
    i = 0

    while (i < int(len(c))):
      ci = c[i]

      _autovar_118 = ci
      if   isinstance(_autovar_118,mosek.fusion.CompoundConstraint):
        cc = _autovar_118
        num = (num + int(len(cc.__cons)))
      else:
        cc = _autovar_118
        num += 1
      i += 1
    return num
  @staticmethod
  def _matchargs_compute_1shape__3Omosek_fusion_Constraint_2I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Constraint): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(56:16-84:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("compute_shape([mosek.fusion.Constraint],int)")
  def __compute_1shape__3Omosek_fusion_Constraint_2I(v,dim):
    s = v[0].shape

    sdsize = 0

    # src/fusion/CompoundConstraint.mbi(60:9-74:9)
    for i in xrange(0,int(len(v))):
      # { @ src/fusion/CompoundConstraint.mbi(61:9-74:9)
      if   (v[i].shape._size > 0):
        if   (v[i].shape.nd != s.nd):
          raise mosek.fusion.DimensionError("Mismatching variable shape")
        # src/fusion/CompoundConstraint.mbi(67:13-71:21)
        j = 0

        while (j < s.nd):
          if   ((j != dim) and (( s._dim_I(j) ) != ( v[i].shape._dim_I(j) ))):
            raise mosek.fusion.DimensionError("Mismatching variable shape")
          j += 1
        sdsize = (sdsize + ( v[i].shape._dim_I(dim) ))
      else:
        raise mosek.fusion.DimensionError("Empty element in compound variable")
      # } @ src/fusion/CompoundConstraint.mbi(61:9-74:9)
    if   (s.nd == 1):
      return mosek.fusion.IntSet(sdsize)
    else:
      d = ([ 0 for _autovar_119 in xrange(s.nd) ])

      # src/fusion/CompoundConstraint.mbi(80:11-57)
      i = 0

      while (i < s.nd):
        d[i] = ( s._dim_I(i) )
        i += 1
      d[dim] = sdsize
      return mosek.fusion.NDSet(d)
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(136:15-140:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    raise mosek.fusion.UnimplementedError("Compound constraints cannot be sliced")
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(143:15-147:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int],[int])")
  def _slice__3I_3I(self,first,last):
    raise mosek.fusion.UnimplementedError("Compound constraints cannot be sliced")
  @staticmethod
  def _matchargs_add__3L_3I_3F_3FI_3II(args):
    if len(args) != 7:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[4],int): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[6],int): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(151:18-161:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add([long],[int],[float],[float],int,[int],int)")
  def _add__3L_3I_3F_3FI_3II(self,eptrb,esubj,ecof,ebfix,firstrow,tgtidxs,num):
    raise mosek.fusion.UnimplementedError("Functionality not implemented yet.")
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(167:18-193:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    tmp_indexes = ([ 0l for _autovar_120 in xrange(1) ])

    index = ([ 0 for _autovar_121 in xrange(self.shape.nd) ])

    # src/fusion/CompoundConstraint.mbi(174:9-192:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/CompoundConstraint.mbi(175:9-192:9)
      # { @ src/fusion/CompoundConstraint.mbi(176:11-183:11)
      tmpval = long(idxs[i])

      # src/fusion/CompoundConstraint.mbi(178:13-182:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundConstraint.mbi(179:13-182:13)
        index[k] = int((tmpval / ( self.shape._stride_I(k) )))
        tmpval = (tmpval - (long(index[k]) * ( self.shape._stride_I(k) )))
        # } @ src/fusion/CompoundConstraint.mbi(179:13-182:13)
      # } @ src/fusion/CompoundConstraint.mbi(176:11-183:11)
      # { @ src/fusion/CompoundConstraint.mbi(185:11-191:11)
      vidx = 0

      # src/fusion/CompoundConstraint.mbi(187:13-60)
      while (index[self.__stackdim] >= self.__consb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__consb[vidx])
      tmp_indexes[0] = ( self.__cons[vidx].shape._linearidx__3I(index) )
      ( self.__cons[vidx]._level_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundConstraint.mbi(185:11-191:11)
      # } @ src/fusion/CompoundConstraint.mbi(175:9-192:9)
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(196:18-255:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    n = int(len(strides))

    totalsize = nsize[0]

    # src/fusion/CompoundConstraint.mbi(204:9-69)
    for i in xrange(1,int(len(nsize))):
      totalsize = (totalsize * nsize[i])
    st = ([ 0l for _autovar_122 in xrange(int(len(nsize))) ])

    # src/fusion/CompoundConstraint.mbi(213:36-77)
    for i in xrange(0,int(len(nsize))):
      st[i] = start
    ii = ([ 0 for _autovar_123 in xrange(int(len(nsize))) ])

    index = ([ 0 for _autovar_124 in xrange(self.shape.nd) ])

    cumdim = ([ 0l for _autovar_125 in xrange(self.shape.nd) ])

    cumdim[(self.shape.nd - 1)] = 1l
    # src/fusion/CompoundConstraint.mbi(216:62-155)
    for i in xrange(1,self.shape.nd):
      cumdim[((self.shape.nd - i) - 1)] = (cumdim[(self.shape.nd - i)] * ( self.shape._dim_I((self.shape.nd - i)) ))
    tmp_indexes = ([ 0l for _autovar_126 in xrange(1) ])

    # src/fusion/CompoundConstraint.mbi(220:9-254:9)
    for i in xrange(0,totalsize):
      # { @ src/fusion/CompoundConstraint.mbi(221:9-254:9)
      # { @ src/fusion/CompoundConstraint.mbi(223:11-230:11)
      tmpval = st[0]

      # src/fusion/CompoundConstraint.mbi(225:13-229:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundConstraint.mbi(226:13-229:13)
        index[k] = int((tmpval / cumdim[k]))
        tmpval = (tmpval - (long(index[k]) * cumdim[k]))
        # } @ src/fusion/CompoundConstraint.mbi(226:13-229:13)
      # } @ src/fusion/CompoundConstraint.mbi(223:11-230:11)
      # { @ src/fusion/CompoundConstraint.mbi(233:11-239:11)
      vidx = 0

      # src/fusion/CompoundConstraint.mbi(235:13-60)
      while (index[self.__stackdim] >= self.__consb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__consb[vidx])
      tmp_indexes[0] = ( self.__cons[vidx].shape._linearidx__3I(index) )
      ( self.__cons[vidx]._level_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundConstraint.mbi(233:11-239:11)
      # { @ src/fusion/CompoundConstraint.mbi(242:11-253:11)
      ii[0] += 1
      st[0] = (st[0] + strides[(n - 1)])
      j = 0

      # src/fusion/CompoundConstraint.mbi(246:13-249:13)
      j = 0
      while ((j < (n - 1)) and (ii[j] == nsize[j])):
        ii[j] = 0
        ii[(j + 1)] += 1
        j += 1
      # src/fusion/CompoundConstraint.mbi(251:13-252:27)
      for k in xrange(0,j):
        st[k] = st[j]
      # } @ src/fusion/CompoundConstraint.mbi(242:11-253:11)
      # } @ src/fusion/CompoundConstraint.mbi(221:9-254:9)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(261:18-287:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    tmp_indexes = ([ 0l for _autovar_127 in xrange(1) ])

    index = ([ 0 for _autovar_128 in xrange(self.shape.nd) ])

    # src/fusion/CompoundConstraint.mbi(268:9-286:9)
    for i in xrange(0,int(len(idxs))):
      # { @ src/fusion/CompoundConstraint.mbi(269:9-286:9)
      # { @ src/fusion/CompoundConstraint.mbi(270:11-277:11)
      tmpval = long(idxs[i])

      # src/fusion/CompoundConstraint.mbi(272:13-276:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundConstraint.mbi(273:13-276:13)
        index[k] = int((tmpval / ( self.shape._stride_I(k) )))
        tmpval = (tmpval - (long(index[k]) * ( self.shape._stride_I(k) )))
        # } @ src/fusion/CompoundConstraint.mbi(273:13-276:13)
      # } @ src/fusion/CompoundConstraint.mbi(270:11-277:11)
      # { @ src/fusion/CompoundConstraint.mbi(279:11-285:11)
      vidx = 0

      # src/fusion/CompoundConstraint.mbi(281:13-60)
      while (index[self.__stackdim] >= self.__consb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__consb[vidx])
      tmp_indexes[0] = ( self.__cons[vidx].shape._linearidx__3I(index) )
      ( self.__cons[vidx]._dual_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundConstraint.mbi(279:11-285:11)
      # } @ src/fusion/CompoundConstraint.mbi(269:9-286:9)
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(290:18-349:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    n = int(len(strides))

    totalsize = nsize[0]

    # src/fusion/CompoundConstraint.mbi(298:9-69)
    for i in xrange(1,int(len(nsize))):
      totalsize = (totalsize * nsize[i])
    st = ([ 0l for _autovar_129 in xrange(int(len(nsize))) ])

    # src/fusion/CompoundConstraint.mbi(307:36-77)
    for i in xrange(0,int(len(nsize))):
      st[i] = start
    ii = ([ 0 for _autovar_130 in xrange(int(len(nsize))) ])

    index = ([ 0 for _autovar_131 in xrange(self.shape.nd) ])

    cumdim = ([ 0l for _autovar_132 in xrange(self.shape.nd) ])

    cumdim[(self.shape.nd - 1)] = 1l
    # src/fusion/CompoundConstraint.mbi(310:62-155)
    for i in xrange(1,self.shape.nd):
      cumdim[((self.shape.nd - i) - 1)] = (cumdim[(self.shape.nd - i)] * ( self.shape._dim_I((self.shape.nd - i)) ))
    tmp_indexes = ([ 0l for _autovar_133 in xrange(1) ])

    # src/fusion/CompoundConstraint.mbi(314:9-348:9)
    for i in xrange(0,totalsize):
      # { @ src/fusion/CompoundConstraint.mbi(315:9-348:9)
      # { @ src/fusion/CompoundConstraint.mbi(317:11-324:11)
      tmpval = st[0]

      # src/fusion/CompoundConstraint.mbi(319:13-323:13)
      for k in xrange(0,self.shape.nd):
        # { @ src/fusion/CompoundConstraint.mbi(320:13-323:13)
        index[k] = int((tmpval / cumdim[k]))
        tmpval = (tmpval - (long(index[k]) * cumdim[k]))
        # } @ src/fusion/CompoundConstraint.mbi(320:13-323:13)
      # } @ src/fusion/CompoundConstraint.mbi(317:11-324:11)
      # { @ src/fusion/CompoundConstraint.mbi(327:11-333:11)
      vidx = 0

      # src/fusion/CompoundConstraint.mbi(329:13-60)
      while (index[self.__stackdim] >= self.__consb[(vidx + 1)]):
        vidx += 1
      index[self.__stackdim] = (index[self.__stackdim] - self.__consb[vidx])
      tmp_indexes[0] = ( self.__cons[vidx].shape._linearidx__3I(index) )
      ( self.__cons[vidx]._dual_1values__3LI_3F(tmp_indexes,(offset + i),target) )
      # } @ src/fusion/CompoundConstraint.mbi(327:11-333:11)
      # { @ src/fusion/CompoundConstraint.mbi(336:11-347:11)
      ii[0] += 1
      st[0] = (st[0] + strides[(n - 1)])
      j = 0

      # src/fusion/CompoundConstraint.mbi(340:13-343:13)
      j = 0
      while ((j < (n - 1)) and (ii[j] == nsize[j])):
        ii[j] = 0
        ii[(j + 1)] += 1
        j += 1
      # src/fusion/CompoundConstraint.mbi(345:13-346:27)
      for k in xrange(0,j):
        st[k] = st[j]
      # } @ src/fusion/CompoundConstraint.mbi(336:11-347:11)
      # } @ src/fusion/CompoundConstraint.mbi(315:9-348:9)
  @staticmethod
  def _matchargs_add_1l__3L_3L_3I_3I_3I_3F_3FLII(args):
    if len(args) != 10:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[7],long): return False
    if not isinstance(args[8],int): return False
    if not isinstance(args[9],int): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(352:17-428:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_l([long],[long],[int],[int],[int],[float],[float],long,int,int)")
  def _add_1l__3L_3L_3I_3I_3I_3F_3FLII(self,subi,ptrb,subj,subk,subl,cof,bfix,subibase,srcoffset,num):
    subi_ = ([ 0l for _autovar_134 in xrange(num) ])

    # src/fusion/CompoundConstraint.mbi(364:42-102)
    for i in xrange(0,num):
      subi_[i] = (subi[(srcoffset + i)] - subibase)
    perm = ([ 0l for _autovar_135 in xrange(num) ])

    # src/fusion/CompoundConstraint.mbi(365:42-84)
    for i in xrange(0,num):
      perm[i] = long(i)
    cdimiidx = ([ 0l for _autovar_136 in xrange(num) ])

    # src/fusion/CompoundConstraint.mbi(367:9-368:84)
    for i in xrange(0,num):
      cdimiidx[i] = long(( self.shape._idxtokey_L((subi[(srcoffset + i)] - subibase)) )[self.__stackdim])
    ( CommonTools._argQsort__3L_3L_3LLL (perm,cdimiidx,subi_,0l,long(num)) )
    csubi = ([ 0 for _autovar_137 in xrange(num) ])

    # { @ src/fusion/CompoundConstraint.mbi(372:9-380:9)
    ci = 0

    # src/fusion/CompoundConstraint.mbi(373:23-65)
    while (self.__consb[ci] < cdimiidx[perm[0]]):
      ci += 1
    csubi[0] = ci
    # src/fusion/CompoundConstraint.mbi(375:11-379:11)
    for i in xrange(1,num):
      # { @ src/fusion/CompoundConstraint.mbi(376:11-379:11)
      # src/fusion/CompoundConstraint.mbi(377:13-55)
      while (self.__consb[ci] < cdimiidx[perm[i]]):
        ci += 1
      csubi[i] = ci
      # } @ src/fusion/CompoundConstraint.mbi(376:11-379:11)
    # } @ src/fusion/CompoundConstraint.mbi(372:9-380:9)
    # { @ src/fusion/CompoundConstraint.mbi(383:9-427:9)
    sl_subi = ([ 0l for _autovar_138 in xrange(num) ])

    sl_ptrb = ([ 0l for _autovar_139 in xrange((num + 1)) ])

    nnz = (ptrb[(srcoffset + num)] - ptrb[srcoffset])

    sl_subj = ([ 0 for _autovar_140 in xrange(nnz) ])

    sl_subk = ([ 0 for _autovar_141 in xrange(nnz) ])

    sl_subl = ([ 0 for _autovar_142 in xrange(nnz) ])

    sl_cof = ([ 0.0 for _autovar_143 in xrange(nnz) ])

    sl_bfix = None

    if   (bfix != None):
      sl_bfix = ([ 0.0 for _autovar_144 in xrange(nnz) ])
    sl_ptrb[0] = 0l
    # src/fusion/CompoundConstraint.mbi(394:11-412:11)
    for i in xrange(0,num):
      # { @ src/fusion/CompoundConstraint.mbi(395:11-412:11)
      ci = csubi[i]

      if   (self.__cons[ci].shape._size == 1):
        sl_subi[i] = 0l
      else:
        subi_conidx = ( self.shape._idxtokey_L(subi_[perm[i]]) )

        subi_conidx[self.__stackdim] = (subi_conidx[self.__stackdim] - self.__consb[ci])
        sl_subi[i] = ( self.__cons[ci].shape._linearidx__3I(subi_conidx) )
      numinz = (ptrb[(perm[i] + 1)] - ptrb[perm[i]])

      sl_ptrb[(i + 1)] = (sl_ptrb[i] + numinz)
      ( Utils.Tools._arraycopy__3IL_3ILL (subj,ptrb[perm[i]],sl_subj,sl_ptrb[i],numinz) )
      ( Utils.Tools._arraycopy__3IL_3ILL (subk,ptrb[perm[i]],sl_subk,sl_ptrb[i],numinz) )
      ( Utils.Tools._arraycopy__3IL_3ILL (subl,ptrb[perm[i]],sl_subl,sl_ptrb[i],numinz) )
      ( Utils.Tools._arraycopy__3FL_3FLL (cof,ptrb[perm[i]],sl_cof,sl_ptrb[i],numinz) )
      # } @ src/fusion/CompoundConstraint.mbi(395:11-412:11)
    if   (bfix != None):
      # src/fusion/CompoundConstraint.mbi(414:13-415:41)
      for i in xrange(0,num):
        sl_bfix[i] = bfix[perm[i]]
    # { @ src/fusion/CompoundConstraint.mbi(418:11-426:11)
    i = 0

    # src/fusion/CompoundConstraint.mbi(420:13-425:13)
    while (i < num):
      istart = i

      i += 1
      # src/fusion/CompoundConstraint.mbi(422:36-85)
      while ((i < num) and (csubi[i] == csubi[istart])):
        i += 1
      ( self.__cons[csubi[istart]]._add_1l__3L_3L_3I_3I_3I_3F_3FLII(sl_subi,sl_ptrb,sl_subj,sl_subk,sl_subl,sl_cof,sl_bfix,0l,istart,(i - istart)) )
    # } @ src/fusion/CompoundConstraint.mbi(418:11-426:11)
    # } @ src/fusion/CompoundConstraint.mbi(383:9-427:9)
  @staticmethod
  def _matchargs_toStringArray__3LL_3S(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_basestring(a): return False
    return True
  # origin: src/fusion/CompoundConstraint.mbi(432:18-437:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("toStringArray([long],long,[basestring])")
  def _toStringArray__3LL_3S(self,subi,dstidx,result):
    raise mosek.fusion.UnimplementedError("SliceConstraint.toStringArray() not implemented")
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   CompoundConstraint._matchargs_slice_II(args):
      return CompoundConstraint._slice_II(self,*args)
    elif CompoundConstraint._matchargs_slice__3I_3I(args):
      return CompoundConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Constraint._matchargs_toString_(args):
      return Constraint._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/ModelConstraint.mbi(12:5-512:5)
class ModelConstraint(Constraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(args):
    if len(args) != 11:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[9]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[10]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,[int],[long],[int],[float],[float],[int],[int],[[int]]) @ src/fusion/ModelConstraint.mbi(42:18-83:7)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    mosek.fusion.Constraint._Constraint__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,model_,shape_)
    self._cache = mosek.fusion.ConstraintCache(ptrb,cof,subj,bfix)
    self._nativeindexes = nidxs_
    self._name = name_
    if   (bfix != None):
      self._cache_bfix = ( Utils.Tools._arraycopy__3F (bfix) )
    else:
      self._cache_bfix = ([ 0.0 for _autovar_145 in xrange(int(len(nidxs_))) ])
    if   (((barsubi_ != None) and (barsubj_ != None)) and (barsymmatidx_ != None)):
      self.__barsubi = barsubi_
      self.__barsubj = barsubj_
      self.__barsymmatidx = barsymmatidx_
    else:
      self.__barsubi = ([ 0 for _autovar_146 in xrange(0) ])
      self.__barsubj = ([ 0 for _autovar_147 in xrange(0) ])
      self.__barsymmatidx = ([ 0 for _autovar_148 in xrange(0) ])
  def __init__(self,*args):
    #self._protected_cache = None

    #self._protected_cache_bfix = None

    #self._protected_name = None

    #self._protected_nativeindexes = None

    #self.__barsubi = None

    #self.__barsubj = None

    #self.__barsymmatidx = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(*args)
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/ModelConstraint.mbi(86:15-92:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    strides = ([ 1l])

    return mosek.fusion.SliceConstraint(self,( self.shape._slice_II(first,last) ),long(first),strides)
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/ModelConstraint.mbi(95:15-113:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int],[int])")
  def _slice__3I_3I(self,first,last):
    if   (int(len(first)) != int(len(last))):
      raise mosek.fusion.LengthError("Mismatching array lengths")
    shp = ( self.shape._slice__3I_3I(first,last) )

    strides = ([ 0l for _autovar_149 in xrange(self.shape.nd) ])

    strides[(self.shape.nd - 1)] = 1l
    # src/fusion/ModelConstraint.mbi(101:9-102:51)
    i = (self.shape.nd - 1)

    while (i > 0):
      strides[(i - 1)] = (strides[i] * ( self.shape._dim_I(i) ))
      i = (i - 1)
    firstidx = 0l

    # src/fusion/ModelConstraint.mbi(106:9-107:54)
    for i in xrange(0,int(len(strides))):
      firstidx = (firstidx + (strides[i] * first[i]))
    return mosek.fusion.SliceConstraint(self,shp,firstidx,strides)
  @staticmethod
  def _matchargs_add_1fx__3L_3FLII(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    return True
  # origin: src/fusion/ModelConstraint.mbi(118:18-125:7)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_fx([long],[float],long,int,int)")
  def _add_1fx__3L_3FLII(self,subi,bfix,subibase,srcoffset,num):
    pass
  @staticmethod
  def _matchargs_add_1l__3L_3L_3I_3I_3I_3F_3FLII(args):
    if len(args) != 10:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[7],long): return False
    if not isinstance(args[8],int): return False
    if not isinstance(args[9],int): return False
    return True
  # origin: src/fusion/ModelConstraint.mbi(129:18-438:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_l([long],[long],[int],[int],[int],[float],[float],long,int,int)")
  def _add_1l__3L_3L_3I_3I_3I_3F_3FLII(self,subi,ptrb,subj,subk,subl,cof,bfix,subibase,srcoffset,num):
    # src/fusion/ModelConstraint.mbi(156:9-161:14)
    for i in xrange(1,int(len(subi))):
      if   (subi[(i - 1)] >= subi[i]):
        raise mosek.fusion.UnimplementedError("Not supported: Non-contiguous index ranges in ModelConstraint.add_l")
    perm = ([ 0l for _autovar_150 in xrange((ptrb[(srcoffset + num)] - ptrb[srcoffset])) ])

    # src/fusion/ModelConstraint.mbi(163:9-90)
    for i in xrange(0l,(ptrb[(srcoffset + num)] - ptrb[srcoffset])):
      perm[i] = (ptrb[srcoffset] + i)
    # src/fusion/ModelConstraint.mbi(164:9-165:109)
    for i in xrange(0,num):
      ( CommonTools._argQsort__3L_3I_3ILL (perm,subj,None,ptrb[(srcoffset + i)],(ptrb[((srcoffset + i) + 1)] - ptrb[(srcoffset + i)])) )
    numlnz = 0

    numbarnz = 0

    # src/fusion/ModelConstraint.mbi(170:9-174:23)
    for k in xrange(ptrb[srcoffset],ptrb[(srcoffset + num)]):
      if   (subj[k] >= 0):
        numlnz += 1
      else:
        numbarnz += 1
    if   ((numlnz > 0) or (bfix != None)):
      lptrb = ([ 0l for _autovar_151 in xrange((self._cache.nrows + 1)) ])

      lsubj = ([ 0 for _autovar_152 in xrange(numlnz) ])

      lcof = ([ 0.0 for _autovar_153 in xrange(numlnz) ])

      lbfix = None

      if   (bfix != None):
        lbfix = ([ 0.0 for _autovar_154 in xrange(self._cache.nrows) ])
        # src/fusion/ModelConstraint.mbi(187:13-188:68)
        for i in xrange(0,num):
          lbfix[(subi[(i + srcoffset)] - subibase)] = bfix[(srcoffset + i)]
      lptrb[0] = 0l
      ii = srcoffset

      # src/fusion/ModelConstraint.mbi(193:11-212:11)
      for i in xrange(0,self._cache.nrows):
        # { @ src/fusion/ModelConstraint.mbi(194:11-212:11)
        if   ((ii < num) and ((subi[ii] - subibase) == i)):
          b = lptrb[i]

          # src/fusion/ModelConstraint.mbi(198:15-206:22)
          for l in xrange(ptrb[ii],ptrb[(ii + 1)]):
            if   (subj[l] >= 0):
              lsubj[b] = subj[l]
              lcof[b] = cof[l]
              b += 1
          lptrb[(i + 1)] = b
          ii += 1
        else:
          lptrb[(i + 1)] = lptrb[i]
        # } @ src/fusion/ModelConstraint.mbi(194:11-212:11)
      ( self._cache._add__3L_3I_3F_3F(lptrb,lsubj,lcof,lbfix) )
      # { @ src/fusion/ModelConstraint.mbi(217:11-233:11)
      nrows = self._cache.nrows

      nn = int(( self._cache._numUnsorted_() ))

      nsubi = ([ 0 for _autovar_155 in xrange(nn) ])

      nsubj = ([ 0 for _autovar_156 in xrange(nn) ])

      ncof = ([ 0.0 for _autovar_157 in xrange(nn) ])

      nx = ( self._cache._flush__3I_3I_3F_3F(nsubi,nsubj,ncof,None) )

      # src/fusion/ModelConstraint.mbi(226:13-227:49)
      for i in xrange(0l,nx):
        nsubi[i] = self._nativeindexes[nsubi[i]]
      ( self._model._task_1putaijlist__3I_3I_3FL(nsubi,nsubj,ncof,nx) )
      if   (bfix != None):
        ( self._add_1fx__3L_3FLII(subi,self._cache.bfix,subibase,srcoffset,num) )
      # } @ src/fusion/ModelConstraint.mbi(217:11-233:11)
    if   (numbarnz > 0):
      numbaraentry = 0

      # { @ src/fusion/ModelConstraint.mbi(242:11-256:11)
      pbase = ptrb[srcoffset]

      # src/fusion/ModelConstraint.mbi(244:13-255:13)
      for i in xrange(0,num):
        # { @ src/fusion/ModelConstraint.mbi(245:13-255:13)
        if   (subj[perm[(ptrb[srcoffset] - pbase)]] < 0):
          ne = 1

          # src/fusion/ModelConstraint.mbi(249:17-254:31)
          for k in xrange(((ptrb[(srcoffset + i)] - pbase) + 1),(ptrb[((srcoffset + i) + 1)] - pbase)):
            if   ((subj[perm[k]] < 0) and (subj[perm[k]] != subj[perm[(k - 1)]])):
              ne += 1
          numbaraentry = (numbaraentry + ne)
        # } @ src/fusion/ModelConstraint.mbi(245:13-255:13)
      # } @ src/fusion/ModelConstraint.mbi(242:11-256:11)
      nbaraijsubi = ([ 0 for _autovar_158 in xrange(numbaraentry) ])

      nbaraijsubj = ([ 0 for _autovar_159 in xrange(numbaraentry) ])

      nbaraijidx = ([ 0 for _autovar_160 in xrange(numbaraentry) ])

      # { @ src/fusion/ModelConstraint.mbi(262:11-334:11)
      pbase = ptrb[srcoffset]

      l = 0

      # src/fusion/ModelConstraint.mbi(265:13-333:13)
      for i in xrange(0,num):
        # { @ src/fusion/ModelConstraint.mbi(266:13-333:13)
        k = (ptrb[(srcoffset + i)] - pbase)

        kend = (ptrb[((srcoffset + i) + 1)] - pbase)

        if   (subj[perm[k]] < 0):
          # src/fusion/ModelConstraint.mbi(272:17-331:17)
          while ((k < kend) and (subj[perm[k]] < 0)):
            nbaraijsubi[l] = int(subi[(srcoffset + i)])
            nbaraijsubj[l] = ((- subj[perm[k]]) - 1)
            kbase = k

            # src/fusion/ModelConstraint.mbi(278:19-281:24)
            while (((k < kend) and (subj[perm[k]] < 0)) and (subj[perm[k]] == subj[perm[kbase]])):
              k += 1



            numbaraijnumnz = 1

            if   ((k - kbase) > 1):
              ( CommonTools._argQsort__3L_3I_3ILL (perm,subk,subl,long(kbase),long((k - kbase))) )
              numaijsymmatnz = 1

              # src/fusion/ModelConstraint.mbi(295:21-301:30)
              for z in xrange(1l,(k - kbase)):
                if   ((subk[perm[((k + z) - 1)]] != subk[perm[(k + z)]]) or (subl[perm[((k + z) - 1)]] != subl[perm[(k + z)]])):
                  numaijsymmatnz += 1
              aijsubk = ([ 0 for _autovar_161 in xrange(numaijsymmatnz) ])
              aijsubl = ([ 0 for _autovar_162 in xrange(numaijsymmatnz) ])
              aijcof = ([ 0.0 for _autovar_163 in xrange(numaijsymmatnz) ])
              aijsubk[0] = subk[perm[0]]
              aijsubl[0] = subl[perm[0]]
              aijcof[0] = cof[perm[0]]
              kp = 0

              # src/fusion/ModelConstraint.mbi(308:21-319:21)
              for z in xrange(1l,(k - kbase)):
                # { @ src/fusion/ModelConstraint.mbi(309:21-319:21)
                if   ((aijsubk[perm[((k + z) - 1)]] != aijsubk[perm[(k + z)]]) or (aijsubl[perm[((k + z) - 1)]] != aijsubl[perm[(k + z)]])):
                  kp += 1
                  aijsubk[kp] = subk[perm[(k + z)]]
                  aijsubl[kp] = subl[perm[(k + z)]]
                aijcof[kp] = (aijcof[kp] + cof[perm[(k + z)]])
                # } @ src/fusion/ModelConstraint.mbi(309:21-319:21)
            else:
              aijsubk = ([ subk[perm[kbase]]])
              aijsubl = ([ subl[perm[kbase]]])
              aijcof = ([ cof[perm[kbase]]])
            idx = ( self._model._task_1append_1barmatrix_I_3I_3I_3F(( self._model._task_1barvardim_I(nbaraijsubj[l]) ),aijsubk,aijsubl,aijcof) )

            nbaraijidx[l] = idx
            l += 1
        # } @ src/fusion/ModelConstraint.mbi(266:13-333:13)
      # } @ src/fusion/ModelConstraint.mbi(262:11-334:11)
      # { @ src/fusion/ModelConstraint.mbi(337:11-436:11)
      numunique = 0

      # { @ src/fusion/ModelConstraint.mbi(339:13-360:13)
      kold = 0

      knew = 0

      # src/fusion/ModelConstraint.mbi(342:15-358:15)
      while ((kold < int(len(self.__barsubi))) and (knew < int(len(nbaraijsubi)))):
        if   ((self.__barsubi[kold] < nbaraijsubi[knew]) or ((self.__barsubi[kold] == nbaraijsubi[knew]) and (self.__barsubj[kold] < nbaraijsubj[knew]))):
          kold += 1
        elif ((self.__barsubi[kold] > nbaraijsubi[knew]) or ((self.__barsubi[kold] == nbaraijsubi[knew]) and (self.__barsubj[kold] > nbaraijsubj[knew]))):
          knew += 1
        else:
          kold += 1
          knew += 1
        numunique += 1
      numunique = ((numunique + (int(len(self.__barsubi)) - kold)) + (int(len(nbaraijsubi)) - knew))
      # } @ src/fusion/ModelConstraint.mbi(339:13-360:13)
      oldbarsubi = self.__barsubi

      oldbarsubj = self.__barsubj

      oldbarmatidx = self.__barsymmatidx

      if   (numunique > int(len(self.__barsubi))):
        self.__barsubi = ([ 0 for _autovar_164 in xrange(numunique) ])
        self.__barsubj = ([ 0 for _autovar_165 in xrange(numunique) ])
        self.__barsymmatidx = ([ 0 for _autovar_166 in xrange(numunique) ])
      if   (numunique > 0):
        kold = 0

        knew = 0

        i = 0

        # src/fusion/ModelConstraint.mbi(376:15-416:15)
        while ((kold < int(len(oldbarsubi))) and (knew < int(len(nbaraijsubi)))):
          if   ((oldbarsubi[kold] < nbaraijsubi[knew]) or ((oldbarsubi[kold] == nbaraijsubi[knew]) and (oldbarsubj[kold] < nbaraijsubj[knew]))):
            self.__barsubi[i] = oldbarsubi[kold]
            self.__barsubj[i] = oldbarsubj[kold]
            self.__barsymmatidx[i] = oldbarmatidx[kold]
            kold += 1
          elif ((oldbarsubi[kold] > nbaraijsubi[knew]) or ((oldbarsubi[kold] == nbaraijsubi[knew]) and (oldbarsubj[kold] > nbaraijsubj[knew]))):
            self.__barsubi[i] = nbaraijsubi[knew]
            self.__barsubj[i] = nbaraijsubj[knew]
            self.__barsymmatidx[i] = ([ nbaraijidx[knew]])
            ( self._model._task_1putbaraij_II_3I(self.__barsubi[i],self.__barsubj[i],self.__barsymmatidx[i]) )
            knew += 1
          else:
            self.__barsubi[i] = nbaraijsubi[knew]
            self.__barsubj[i] = nbaraijsubj[knew]
            self.__barsymmatidx[i] = ([ 0 for _autovar_167 in xrange((int(len(oldbarmatidx[kold])) + 1)) ])
            # src/fusion/ModelConstraint.mbi(406:19-407:63)
            for j in xrange(0,int(len(oldbarmatidx[kold]))):
              self.__barsymmatidx[i][j] = oldbarmatidx[kold][j]
            self.__barsymmatidx[i][int(len(oldbarmatidx[kold]))] = nbaraijidx[knew]
            ( self._model._task_1putbaraij_II_3I(self.__barsubi[i],self.__barsubj[i],self.__barsymmatidx[i]) )
            kold += 1
            knew += 1
          i += 1
        # src/fusion/ModelConstraint.mbi(417:15-423:15)
        for k in xrange(kold,int(len(oldbarsubi))):
          # { @ src/fusion/ModelConstraint.mbi(418:15-423:15)
          self.__barsubi[i] = oldbarsubi[k]
          self.__barsubj[i] = oldbarsubj[k]
          self.__barsymmatidx[i] = oldbarmatidx[k]
          i += 1
          # } @ src/fusion/ModelConstraint.mbi(418:15-423:15)
        # src/fusion/ModelConstraint.mbi(424:15-433:15)
        for k in xrange(knew,int(len(nbaraijsubi))):
          # { @ src/fusion/ModelConstraint.mbi(425:15-433:15)
          self.__barsubi[i] = nbaraijsubi[k]
          self.__barsubj[i] = nbaraijsubj[k]
          self.__barsymmatidx[i] = ([ nbaraijidx[k]])
          ( self._model._task_1putbaraij_II_3I(self.__barsubi[i],self.__barsubj[i],self.__barsymmatidx[i]) )
          i += 1
          # } @ src/fusion/ModelConstraint.mbi(425:15-433:15)
      # } @ src/fusion/ModelConstraint.mbi(337:11-436:11)
  @staticmethod
  def _matchargs_domainToString_LOmosek_fusion_Utils_StringBuffer_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],long): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Utils.StringBuffer): return False
    return True
  # origin: src/fusion/ModelConstraint.mbi(441:18-440:86)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("domainToString(long,mosek.fusion.Utils.StringBuffer)")
  def _domainToString_LOmosek_fusion_Utils_StringBuffer_2(self,i,sb):
    pass
  @staticmethod
  def _matchargs_toStringArray__3LL_3S(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_basestring(a): return False
    return True
  # origin: src/fusion/ModelConstraint.mbi(443:18-498:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("toStringArray([long],long,[basestring])")
  def _toStringArray__3LL_3S(self,subi,dstidx,result):
    # src/fusion/ModelConstraint.mbi(444:9-448:13)
    for i in xrange(0,int(len(subi))):
      if   ((subi[i] < 0) or (subi[i] >= self.shape._size)):
        raise mosek.fusion.IndexError("Constraint index out of bounds")
    if   ((long(len(subi)) + dstidx) > long(len(result))):
      raise mosek.fusion.LengthError("Result array is too small to hold the result")
    sb = mosek.fusion.Utils.StringBuffer()

    p = 0

    if   True:
      # src/fusion/ModelConstraint.mbi(459:11-489:11)
      for k in xrange(0,int(len(subi))):
        # { @ src/fusion/ModelConstraint.mbi(460:11-489:11)
        i = subi[k]

        ni = self._nativeindexes[i]

        b = p

        # src/fusion/ModelConstraint.mbi(465:13-67)
        while ((p < int(len(self._cache.subi))) and (self._cache.subi[p] == i)):
          p += 1
        ( ( ( ( ( sb._clear_() )._a_S(self._name) )._a_S("[") )._a_S(( self.shape._indexToString_L(i) )) )._a_S("] : ") )
        # src/fusion/ModelConstraint.mbi(469:13-478:13)
        for j in xrange(b,p):
          # { @ src/fusion/ModelConstraint.mbi(470:13-478:13)
          c = self._cache.cof[j]

          if   (c > 0):
            ( ( ( sb._a_S(" + ") )._a_F(c) )._a_S(" ") )
          elif (c < 0):
            ( ( ( sb._a_S(" - ") )._a_F((- c)) )._a_S(" ") )
          ( self._model._nativeVarToStr_IOmosek_fusion_Utils_StringBuffer_2(self._cache.subj[j],sb) )
          # } @ src/fusion/ModelConstraint.mbi(470:13-478:13)
        if   (self._cache_bfix != None):
          if   (self._cache_bfix[i] > 0):
            ( ( sb._a_S(" + ") )._a_F(self._cache_bfix[i]) )
          elif (self._cache_bfix[i] < 0):
            ( ( sb._a_S(" + ") )._a_F(self._cache_bfix[i]) )
        ( sb._a_S(" ") )
        ( self._domainToString_LOmosek_fusion_Utils_StringBuffer_2(i,sb) )
        result[(long(k) + dstidx)] = ( sb._toString_() )
        # } @ src/fusion/ModelConstraint.mbi(460:11-489:11)
    else:
      perm = ([ 0l for _autovar_168 in xrange(int(len(subi))) ])

      ( CommonTools._argQsort__3L_3L_3LLL (perm,subi,None,0l,long(len(subi))) )
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/ModelConstraint.mbi(501:15-511:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    r = ([ None for _autovar_169 in xrange(self.shape._size) ])

    ( self._toStringArray__3LL_3S(( Utils.Tools._range_L (self.shape._size) ),0l,r) )
    sb = mosek.fusion.Utils.StringBuffer()

    ( sb._a_S(r[0]) )
    # src/fusion/ModelConstraint.mbi(508:9-509:29)
    for i in xrange(1,int(len(r))):
      ( ( sb._a_S("\n") )._a_S(r[i]) )
    return ( sb._toString_() )
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   ModelConstraint._matchargs_slice_II(args):
      return ModelConstraint._slice_II(self,*args)
    elif ModelConstraint._matchargs_slice__3I_3I(args):
      return ModelConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   ModelConstraint._matchargs_toString_(args):
      return ModelConstraint._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(2,"\tlevel(int,int)"),(0,"\tlevel()"),(2,"\tlevel([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/ConicConstraint.mbi(18:5-244:5)
class ConicConstraint(ModelConstraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IIIIII_3L_3I_3F_3F_3I_3I_3_3I(args):
    if len(args) != 17:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Set): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[5],int): return False
    if not isinstance(args[6],int): return False
    if not isinstance(args[7],int): return False
    if not isinstance(args[8],int): return False
    if not isinstance(args[9],int): return False
    a = args[10]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[11]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[12]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[13]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[14]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[15]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[16]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Domain,mosek.fusion.Set,[int],int,int,int,int,int,[long],[int],[float],[float],[int],[int],[[int]]) @ src/fusion/ConicConstraint.mbi(37:18-73:7)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IIIIII_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,dom_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    mosek.fusion.ModelConstraint._ModelConstraint__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,shape_,nativeidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
    self.__first_slack = first_slack_
    self.__last_slack = last_slack_
    self.__first = firstcone_
    self.__last = (firstcone_ + numcone_)
    self.__dom = dom_
    self.__conesize = conesize_
    self.__coneidx = firstcone_
  def __init__(self,*args):
    #self.__coneidx = None

    #self.__first_slack = None

    #self.__last_slack = None

    #self.__first = None

    #self.__last = None

    #self.__conesize = None

    #self.__dom = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3IIIIII_3L_3I_3F_3F_3I_3I_3_3I(*args)
  @staticmethod
  def _matchargs_domainToString_LOmosek_fusion_Utils_StringBuffer_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],long): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Utils.StringBuffer): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(80:18-82:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("domainToString(long,mosek.fusion.Utils.StringBuffer)")
  def _domainToString_LOmosek_fusion_Utils_StringBuffer_2(self,i,sb):
    ( self.__dom._domainToString_LOmosek_fusion_Utils_StringBuffer_2(i,sb) )
  @staticmethod
  def _matchargs_dual_1values__3I_3II_3F(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[2],int): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(89:18-120:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([int],[int],int,[float])")
  def _dual_1values__3I_3II_3F(self,first__,last__,offset,tgt):
    if   ((int(len(first__)) != 1) or (int(len(last__)) != 1)):
      raise mosek.fusion.SliceError("Invalid slice dimensions")
    first_ = first__[0]

    last_ = last__[0]

    if   ((last_ - first_) > (int(len(tgt)) - offset)):
      raise mosek.fusion.SliceError("Wrong target array length")
    elif ((last_ < first_) or (last_ > (self.__last_slack - self.__first_slack))):
      raise mosek.fusion.SliceError("Slice indexes out of bounds")

    snx = ( self._model._getSolution_1snx_Omosek_fusion_SolutionType_2(SolutionType.Default) )
    # src/fusion/ConicConstraint.mbi(116:11-119:11)
    i = 0

    while (i < (last_ - first_)):
      tgt[(i + offset)] = snx[((first_ + i) + self.__first_slack)]
      i += 1
  @staticmethod
  def _matchargs_dual__3IIII_3F(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(123:18-144:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual([int],int,int,int,[float])")
  def _dual__3IIII_3F(self,idxs,first_,last_,offset,tgt):
    if   ((last_ - first_) > (int(len(tgt)) - offset)):
      raise mosek.fusion.SliceError("Wrong target array length")
    elif ((last_ < first_) or (last_ >= int(len(idxs)))):
      raise mosek.fusion.SliceError("Slice indexes out of bounds")
    snx = ( self._model._getSolution_1snx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicConstraint.mbi(140:11-143:11)
    i = 0

    while (i < (last_ - first_)):
      tgt[(i + offset)] = snx[(self.__first_slack + idxs[(first_ + i)])]
      i += 1
  @staticmethod
  def _matchargs_add_1fx__3L_3FLII(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(151:18-170:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_fx([long],[float],long,int,int)")
  def _add_1fx__3L_3FLII(self,subi,bfix,subibase,srcoffset,num):

    boundval = ([ 0.0 for _autovar_170 in xrange(num) ])
    idxs = ([ 0 for _autovar_171 in xrange(num) ])

    # src/fusion/ConicConstraint.mbi(163:9-164:62)
    for i in xrange(0,num):
      idxs[i] = self._nativeindexes[(subi[(srcoffset + i)] - subibase)]
    # src/fusion/ConicConstraint.mbi(166:9-167:59)
    for i in xrange(0,int(len(boundval))):
      boundval[i] = (- bfix[(subi[(srcoffset + i)] - subibase)])
    ( self._model._task_1con_1putboundlist_1fx__3I_3F(idxs,boundval) )
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(177:18-185:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicConstraint.mbi(183:9-184:62)
    for i in xrange(0,int(len(idxs))):
      target[(offset + i)] = xx[(long(self.__first_slack) + idxs[i])]
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(188:18-208:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1xx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicConstraint.mbi(202:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/ConicConstraint.mbi(203:9-207:9)
    for i in xrange(0l,tlen):
      # { @ src/fusion/ConicConstraint.mbi(204:9-207:9)
      target[(i + offset)] = xx[(long(self.__first_slack) + ( cnt._get_() ))]
      ( cnt._inc_() )
      # } @ src/fusion/ConicConstraint.mbi(204:9-207:9)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(214:18-222:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1snx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicConstraint.mbi(220:9-221:62)
    for i in xrange(0,int(len(idxs))):
      target[(offset + i)] = xx[(long(self.__first_slack) + idxs[i])]
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConicConstraint.mbi(225:18-243:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1snx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/ConicConstraint.mbi(237:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/ConicConstraint.mbi(238:9-242:9)
    for i in xrange(0l,tlen):
      # { @ src/fusion/ConicConstraint.mbi(239:9-242:9)
      target[(i + offset)] = xx[(long(self.__first_slack) + ( cnt._get_() ))]
      ( cnt._inc_() )
      # } @ src/fusion/ConicConstraint.mbi(239:9-242:9)
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   ModelConstraint._matchargs_slice_II(args):
      return ModelConstraint._slice_II(self,*args)
    elif ModelConstraint._matchargs_slice__3I_3I(args):
      return ModelConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   ModelConstraint._matchargs_toString_(args):
      return ModelConstraint._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/SemidefiniteConstraint.mbi(12:5-297:5)
class PSDConstraint(ModelConstraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIII_3L_3I_3F_3F_3I_3I_3_3I(args):
    if len(args) != 14:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[4],int): return False
    if not isinstance(args[5],int): return False
    if not isinstance(args[6],int): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[9]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[10]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[11]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[12]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[13]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,[int],int,int,int,[long],[int],[float],[float],[int],[int],[[int]]) @ src/fusion/SemidefiniteConstraint.mbi(23:18-51:7)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIII_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    mosek.fusion.ModelConstraint._ModelConstraint__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,shape_,nativeidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_)
    self.__coneidx = firstcone_
    self.__conesize = conesize_
    self.__numcones = numcone_
  def __init__(self,*args):
    #self.__coneidx = None

    #self.__conesize = None

    #self.__numcones = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3IIII_3L_3I_3F_3F_3I_3I_3_3I(*args)
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteConstraint.mbi(57:18-76:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    barx = ( self._model._getSolution_1barx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteConstraint.mbi(64:9-75:9)
    for p in xrange(0,int(len(idxs))):
      # { @ src/fusion/SemidefiniteConstraint.mbi(65:9-75:9)
      k = ((idxs[p] / blocksize) + self.__coneidx)

      lidx = (idxs[p] - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = barx[k][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = barx[k][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteConstraint.mbi(65:9-75:9)
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteConstraint.mbi(80:18-124:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    ii = ([ 0 for _autovar_172 in xrange(n) ])

    st = ([ 0l for _autovar_173 in xrange(n) ])

    barx = ( self._model._getSolution_1barx_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteConstraint.mbi(94:9-41)
    for i in xrange(0,n):
      st[i] = start
    # src/fusion/SemidefiniteConstraint.mbi(95:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/SemidefiniteConstraint.mbi(96:9-123:9)
    for p in xrange(0l,tlen):
      # { @ src/fusion/SemidefiniteConstraint.mbi(97:9-123:9)
      # { @ src/fusion/SemidefiniteConstraint.mbi(98:11-108:11)
      k = (st[0] / blocksize)

      lidx = (st[0] - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = barx[(long(self.__coneidx) + k)][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = barx[(long(self.__coneidx) + k)][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteConstraint.mbi(98:11-108:11)
      # { @ src/fusion/SemidefiniteConstraint.mbi(110:11-122:11)
      ii[0] += 1
      st[0] = (st[0] + strides[(n - 1)])
      l = 0

      # src/fusion/SemidefiniteConstraint.mbi(114:13-118:13)
      l = 0
      while ((l < (n - 1)) and (ii[l] == nsize[l])):
        ii[l] = 0
        ii[(l + 1)] += 1
        st[(l + 1)] = (st[(l + 1)] + strides[((n - 2) - l)])
        l += 1
      # src/fusion/SemidefiniteConstraint.mbi(120:13-121:28)
      for k in xrange(0,l):
        st[k] = st[l]
      # } @ src/fusion/SemidefiniteConstraint.mbi(110:11-122:11)
      # } @ src/fusion/SemidefiniteConstraint.mbi(97:9-123:9)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteConstraint.mbi(129:18-148:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    barx = ( self._model._getSolution_1bars_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteConstraint.mbi(136:9-147:9)
    for p in xrange(0,int(len(idxs))):
      # { @ src/fusion/SemidefiniteConstraint.mbi(137:9-147:9)
      k = ((idxs[p] / blocksize) + self.__coneidx)

      lidx = (idxs[p] - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = barx[k][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = barx[k][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteConstraint.mbi(137:9-147:9)
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/SemidefiniteConstraint.mbi(151:18-195:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    ii = ([ 0 for _autovar_174 in xrange(n) ])

    st = ([ 0l for _autovar_175 in xrange(n) ])

    barx = ( self._model._getSolution_1bars_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    blocksize = (self.__conesize * self.__conesize)

    # src/fusion/SemidefiniteConstraint.mbi(165:9-41)
    for i in xrange(0,n):
      st[i] = start
    # src/fusion/SemidefiniteConstraint.mbi(166:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    # src/fusion/SemidefiniteConstraint.mbi(167:9-194:9)
    for p in xrange(0l,tlen):
      # { @ src/fusion/SemidefiniteConstraint.mbi(168:9-194:9)
      # { @ src/fusion/SemidefiniteConstraint.mbi(169:11-179:11)
      k = (st[0] / blocksize)

      lidx = (st[0] - (k * blocksize))

      i = (lidx / self.__conesize)

      j = (lidx - (i * self.__conesize))

      if   (j > i):
        target[p] = barx[(long(self.__coneidx) + k)][(((i * self.__conesize) + j) - ((i * (i + 1)) / 2))]
      else:
        target[p] = barx[(long(self.__coneidx) + k)][(((j * self.__conesize) + i) - ((j * (j + 1)) / 2))]
      # } @ src/fusion/SemidefiniteConstraint.mbi(169:11-179:11)
      # { @ src/fusion/SemidefiniteConstraint.mbi(181:11-193:11)
      ii[0] += 1
      st[0] = (st[0] + strides[(n - 1)])
      l = 0

      # src/fusion/SemidefiniteConstraint.mbi(185:13-189:13)
      l = 0
      while ((l < (n - 1)) and (ii[l] == nsize[l])):
        ii[l] = 0
        ii[(l + 1)] += 1
        st[(l + 1)] = (st[(l + 1)] + strides[((n - 2) - l)])
        l += 1
      # src/fusion/SemidefiniteConstraint.mbi(191:13-192:28)
      for k in xrange(0,l):
        st[k] = st[l]
      # } @ src/fusion/SemidefiniteConstraint.mbi(181:11-193:11)
      # } @ src/fusion/SemidefiniteConstraint.mbi(168:9-194:9)
  @staticmethod
  def _matchargs_add_1fx__3L_3FLII(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    return True
  # origin: src/fusion/SemidefiniteConstraint.mbi(198:18-217:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_fx([long],[float],long,int,int)")
  def _add_1fx__3L_3FLII(self,subi,bfix,subibase,srcoffset,num):

    boundval = ([ 0.0 for _autovar_176 in xrange(num) ])
    idxs = ([ 0 for _autovar_177 in xrange(num) ])

    # src/fusion/SemidefiniteConstraint.mbi(210:9-211:62)
    for i in xrange(0,num):
      idxs[i] = self._nativeindexes[(subi[(srcoffset + i)] - subibase)]
    # src/fusion/SemidefiniteConstraint.mbi(213:9-214:59)
    for i in xrange(0,int(len(boundval))):
      boundval[i] = (- bfix[(subi[(srcoffset + i)] - subibase)])
    ( self._model._task_1con_1putboundlist_1fx__3I_3F(idxs,boundval) )
  @staticmethod
  def _matchargs_toStringArray__3LL_3S(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],long): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_basestring(a): return False
    return True
  # origin: src/fusion/SemidefiniteConstraint.mbi(221:18-283:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("toStringArray([long],long,[basestring])")
  def _toStringArray__3LL_3S(self,subi,dstidx,result):
    # src/fusion/SemidefiniteConstraint.mbi(222:9-226:13)
    for i in xrange(0,int(len(subi))):
      if   ((subi[i] < 0) or (subi[i] >= self.shape._size)):
        raise mosek.fusion.IndexError("Constraint index out of bounds")
    if   ((long(len(subi)) + dstidx) > long(len(result))):
      raise mosek.fusion.LengthError("Result array is too small to hold the result")
    sb = mosek.fusion.Utils.StringBuffer()

    p = 0

    if   True:
      # src/fusion/SemidefiniteConstraint.mbi(236:11-274:11)
      for k in xrange(0,int(len(subi))):
        # { @ src/fusion/SemidefiniteConstraint.mbi(237:11-274:11)
        ll = (subi[k] % (self.__conesize * self.__conesize))

        kk = (subi[k] / (self.__conesize * self.__conesize))

        ii = (ll % self.__conesize)

        jj = (ll / self.__conesize)


        if   (jj > ii):
          i = (((jj * (jj + 1)) / 2) + ii)
        else:
          i = (((ii * (ii + 1)) / 2) + jj)
        ni = self._nativeindexes[i]

        b = p

        # src/fusion/SemidefiniteConstraint.mbi(250:13-67)
        while ((p < int(len(self._cache.subi))) and (self._cache.subi[p] == i)):
          p += 1
        ( ( ( ( ( sb._clear_() )._a_S(self._name) )._a_S("[") )._a_S(( self.shape._indexToString_L(subi[k]) )) )._a_S("] : ") )
        # src/fusion/SemidefiniteConstraint.mbi(254:13-263:13)
        for j in xrange(b,p):
          # { @ src/fusion/SemidefiniteConstraint.mbi(255:13-263:13)
          c = self._cache.cof[j]

          if   (c > 0):
            ( ( ( sb._a_S(" + ") )._a_F(c) )._a_S(" ") )
          elif (c < 0):
            ( ( ( sb._a_S(" - ") )._a_F((- c)) )._a_S(" ") )
          ( self._model._nativeVarToStr_IOmosek_fusion_Utils_StringBuffer_2(self._cache.subj[j],sb) )
          # } @ src/fusion/SemidefiniteConstraint.mbi(255:13-263:13)
        if   (self._cache_bfix != None):
          if   (self._cache_bfix[i] > 0):
            ( ( sb._a_S(" + ") )._a_F(self._cache_bfix[i]) )
          elif (self._cache_bfix[i] < 0):
            ( ( sb._a_S(" + ") )._a_F(self._cache_bfix[i]) )
        ( sb._a_S(" ") )
        ( self._domainToString_LOmosek_fusion_Utils_StringBuffer_2(i,sb) )
        result[(long(k) + dstidx)] = ( sb._toString_() )
        # } @ src/fusion/SemidefiniteConstraint.mbi(237:11-274:11)
    else:
      perm = ([ 0l for _autovar_178 in xrange(int(len(subi))) ])

      ( CommonTools._argQsort__3L_3L_3LLL (perm,subi,None,0l,long(len(subi))) )
  @staticmethod
  def _matchargs_domainToString_LOmosek_fusion_Utils_StringBuffer_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],long): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Utils.StringBuffer): return False
    return True
  # origin: src/fusion/SemidefiniteConstraint.mbi(289:18-296:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("domainToString(long,mosek.fusion.Utils.StringBuffer)")
  def _domainToString_LOmosek_fusion_Utils_StringBuffer_2(self,i,sb):
    k = ( self.shape._idxtokey_L(i) )

    ( ( sb._a_S(" : element (") )._a_I(k[0]) )
    # src/fusion/SemidefiniteConstraint.mbi(292:9-50)
    for j in xrange(1,int(len(k))):
      ( ( sb._a_S(",") )._a_I(k[j]) )
    ( ( sb._a_S(") in a positive semi-definite cone of size (") )._a_I(( self.shape._dim_I(0) )) )
    # src/fusion/SemidefiniteConstraint.mbi(294:9-58)
    for j in xrange(1,int(len(k))):
      ( ( sb._a_S(",") )._a_I(( self.shape._dim_I(j) )) )
    ( sb._a_S(")") )
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   ModelConstraint._matchargs_slice_II(args):
      return ModelConstraint._slice_II(self,*args)
    elif ModelConstraint._matchargs_slice__3I_3I(args):
      return ModelConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   ModelConstraint._matchargs_toString_(args):
      return ModelConstraint._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/RangedConstraint.mbi(18:5-374:5)
class RangedConstraint(ModelConstraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3I_3L_3I_3F_3F(args):
    if len(args) != 9:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Set): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.RangeDomain): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,[int],[long],[int],[float],[float]) @ src/fusion/RangedConstraint.mbi(27:18-48:7)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3I_3L_3I_3F_3F(self,model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix):
    mosek.fusion.ModelConstraint._ModelConstraint__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,None,None,None)
    self.__dom = dom_
    self.__idxmap = None
  def __init__(self,*args):
    #self.__dom = None

    #self.__idxmap = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2_3I_3L_3I_3F_3F(*args)
  @staticmethod
  def _matchargs_lowerBoundCon_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(56:15-65:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("lowerBoundCon()")
  def _lowerBoundCon_(self):
    strides = ([ 0l for _autovar_179 in xrange(self.shape.nd) ])

    strides[(self.shape.nd - 1)] = 1l
    # src/fusion/RangedConstraint.mbi(59:9-62:9)
    i = (self.shape.nd - 1)

    while (i > 0):
      strides[(i - 1)] = (strides[i] * ( self.shape._dim_I(i) ))
      i -= 1
    return mosek.fusion.BoundInterfaceConstraint(self,self.shape,0l,strides,True)
  @staticmethod
  def _matchargs_upperBoundCon_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(71:15-79:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("upperBoundCon()")
  def _upperBoundCon_(self):
    strides = ([ 0l for _autovar_180 in xrange(self.shape.nd) ])

    strides[(self.shape.nd - 1)] = 1l
    # src/fusion/RangedConstraint.mbi(74:9-77:9)
    i = (self.shape.nd - 1)

    while (i > 0):
      strides[(i - 1)] = (strides[i] * ( self.shape._dim_I(i) ))
      i -= 1
    return mosek.fusion.BoundInterfaceConstraint(self,self.shape,0l,strides,False)
  @staticmethod
  def _matchargs_domainToString_LOmosek_fusion_Utils_StringBuffer_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],long): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Utils.StringBuffer): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(82:18-84:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("domainToString(long,mosek.fusion.Utils.StringBuffer)")
  def _domainToString_LOmosek_fusion_Utils_StringBuffer_2(self,i,sb):
    ( self.__dom._domainToString_LOmosek_fusion_Utils_StringBuffer_2(i,sb) )
  @staticmethod
  def _matchargs_add_1l__3L_3L_3I_3I_3I_3F_3FIII(args):
    if len(args) != 10:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[7],int): return False
    if not isinstance(args[8],int): return False
    if not isinstance(args[9],int): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(88:18-117:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_l([long],[long],[int],[int],[int],[float],[float],int,int,int)")
  def _add_1l__3L_3L_3I_3I_3I_3F_3FIII(self,esubi,eptrb,esubj,esubk,esubl,ecof,ebfix,subibase,srcoffset,num):
    ( self._add_1l__3L_3L_3I_3I_3I_3F_3FIII(esubi,eptrb,esubj,esubk,esubl,ecof,ebfix,subibase,srcoffset,num) )
    if   (ebfix != None):
      nrows = self.__dom._shape._size

      real_bl = ([ 0.0 for _autovar_181 in xrange(nrows) ])

      real_bu = ([ 0.0 for _autovar_182 in xrange(nrows) ])

      idxs = ([ 0 for _autovar_183 in xrange(num) ])

      # src/fusion/RangedConstraint.mbi(109:11-114:11)
      for i in xrange(0,num):
        # { @ src/fusion/RangedConstraint.mbi(110:11-114:11)
        real_bl[i] = (( self.__dom._get_1lb_1item_L(esubi[i]) ) - self._cache.bfix[i])
        real_bu[i] = (( self.__dom._get_1ub_1item_L(esubi[i]) ) - self._cache.bfix[i])
        idxs[i] = self._nativeindexes[esubi[i]]
        # } @ src/fusion/RangedConstraint.mbi(110:11-114:11)
      ( self._model._task_1con_1putboundlist_1ra__3I_3F_3F(idxs,real_bl,real_bu) )
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(130:18-145:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1xc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(137:11-138:80)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = (xx[self._nativeindexes[idxs[i]]] + self._cache.bfix[idxs[i]])
    else:
      # src/fusion/RangedConstraint.mbi(140:11-144:58)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = (xx[( self.__idxmap._getItem_L(idxs[i]) )] + self._cache.bfix[idxs[i]])
        else:
          target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(148:18-180:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1xc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedConstraint.mbi(160:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(163:11-167:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(164:11-167:11)
        target[(i + offset)] = (xx[self._nativeindexes[( cnt._get_() )]] + self._cache.bfix[( cnt._get_() )])
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(164:11-167:11)
    else:
      # src/fusion/RangedConstraint.mbi(171:11-178:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(172:11-178:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = (xx[( self.__idxmap._getItem_L(( cnt._get_() )) )] + self._cache.bfix[( cnt._get_() )])
        else:
          target[i] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(172:11-178:11)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(185:18-200:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1y_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(192:11-193:80)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = (xx[self._nativeindexes[idxs[i]]] + self._cache.bfix[idxs[i]])
    else:
      # src/fusion/RangedConstraint.mbi(195:11-199:58)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = (xx[( self.__idxmap._getItem_L(idxs[i]) )] + self._cache.bfix[idxs[i]])
        else:
          target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(203:18-235:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1y_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedConstraint.mbi(215:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(218:11-222:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(219:11-222:11)
        target[(i + offset)] = (xx[self._nativeindexes[( cnt._get_() )]] + self._cache.bfix[( cnt._get_() )])
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(219:11-222:11)
    else:
      # src/fusion/RangedConstraint.mbi(226:11-233:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(227:11-233:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = (xx[( self.__idxmap._getItem_L(( cnt._get_() )) )] + self._cache.bfix[( cnt._get_() )])
        else:
          target[i] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(227:11-233:11)
  @staticmethod
  def _matchargs_dual_1l__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(242:18-257:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_l([long],int,[float])")
  def _dual_1l__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1slc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(249:11-250:80)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = (xx[self._nativeindexes[idxs[i]]] + self._cache.bfix[idxs[i]])
    else:
      # src/fusion/RangedConstraint.mbi(252:11-256:58)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = (xx[( self.__idxmap._getItem_L(idxs[i]) )] + self._cache.bfix[idxs[i]])
        else:
          target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
  @staticmethod
  def _matchargs_dual_1l_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(260:18-292:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_l(long,[int],[long],int,[float])")
  def _dual_1l_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1slc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedConstraint.mbi(272:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(275:11-279:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(276:11-279:11)
        target[(i + offset)] = (xx[self._nativeindexes[( cnt._get_() )]] + self._cache.bfix[( cnt._get_() )])
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(276:11-279:11)
    else:
      # src/fusion/RangedConstraint.mbi(283:11-290:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(284:11-290:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = (xx[( self.__idxmap._getItem_L(( cnt._get_() )) )] + self._cache.bfix[( cnt._get_() )])
        else:
          target[i] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(284:11-290:11)
  @staticmethod
  def _matchargs_dual_1u__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(298:18-313:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_u([long],int,[float])")
  def _dual_1u__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1suc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(305:11-306:80)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = (xx[self._nativeindexes[idxs[i]]] + self._cache.bfix[idxs[i]])
    else:
      # src/fusion/RangedConstraint.mbi(308:11-312:58)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = (xx[( self.__idxmap._getItem_L(idxs[i]) )] + self._cache.bfix[idxs[i]])
        else:
          target[(offset + i)] = ( self.__dom._get_1ub_1item_L(idxs[i]) )
  @staticmethod
  def _matchargs_dual_1u_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(316:18-348:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_u(long,[int],[long],int,[float])")
  def _dual_1u_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1suc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/RangedConstraint.mbi(328:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self._nativeindexes != None):
      # src/fusion/RangedConstraint.mbi(331:11-335:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(332:11-335:11)
        target[(i + offset)] = (xx[self._nativeindexes[( cnt._get_() )]] + self._cache.bfix[( cnt._get_() )])
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(332:11-335:11)
    else:
      # src/fusion/RangedConstraint.mbi(339:11-346:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/RangedConstraint.mbi(340:11-346:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = (xx[( self.__idxmap._getItem_L(( cnt._get_() )) )] + self._cache.bfix[( cnt._get_() )])
        else:
          target[i] = ( self.__dom._get_1ub_1item_L(( cnt._get_() )) )
        ( cnt._inc_() )
        # } @ src/fusion/RangedConstraint.mbi(340:11-346:11)
  @staticmethod
  def _matchargs_add_1fx__3L_3FLII(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    return True
  # origin: src/fusion/RangedConstraint.mbi(351:18-372:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_fx([long],[float],long,int,int)")
  def _add_1fx__3L_3FLII(self,subi,bfix,subibase,srcoffset,num):
    boundvallo = ([ 0.0 for _autovar_184 in xrange(num) ])

    boundvalup = ([ 0.0 for _autovar_185 in xrange(num) ])

    idxs = ([ 0 for _autovar_186 in xrange(num) ])

    # src/fusion/RangedConstraint.mbi(362:9-363:62)
    for i in xrange(0,num):
      idxs[i] = self._nativeindexes[(subi[(srcoffset + i)] - subibase)]
    # src/fusion/RangedConstraint.mbi(365:9-369:9)
    for i in xrange(0,int(len(boundvallo))):
      # { @ src/fusion/RangedConstraint.mbi(366:9-369:9)
      boundvallo[i] = (( self.__dom._get_1lb_1item_L((subi[(srcoffset + i)] - subibase)) ) - bfix[(subi[(srcoffset + i)] - subibase)])
      boundvalup[i] = (( self.__dom._get_1ub_1item_L((subi[(srcoffset + i)] - subibase)) ) - bfix[(subi[(srcoffset + i)] - subibase)])
      # } @ src/fusion/RangedConstraint.mbi(366:9-369:9)
    ( self._model._task_1con_1putboundlist_1ra__3I_3F_3F(idxs,boundvallo,boundvalup) )
  @_cliptrace
  def upperBoundCon(self,*args):
    if   RangedConstraint._matchargs_upperBoundCon_(args):
      return RangedConstraint._upperBoundCon_(self,*args)
    else:
      argtypestr = "upperBoundCon(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tupperBoundCon()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   ModelConstraint._matchargs_slice__3I_3I(args):
      return ModelConstraint._slice__3I_3I(self,*args)
    elif ModelConstraint._matchargs_slice_II(args):
      return ModelConstraint._slice_II(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice([int],[int])"),(2,"\tslice(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   ModelConstraint._matchargs_toString_(args):
      return ModelConstraint._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def lowerBoundCon(self,*args):
    if   RangedConstraint._matchargs_lowerBoundCon_(args):
      return RangedConstraint._lowerBoundCon_(self,*args)
    else:
      argtypestr = "lowerBoundCon(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tlowerBoundCon()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/LinearConstraint.mbi(23:5-229:5)
class LinearConstraint(ModelConstraint):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(args):
    if len(args) != 12:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Set): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[9]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[10]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[11]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,basestring,mosek.fusion.Domain,mosek.fusion.Set,[int],[long],[int],[float],[float],[int],[int],[[int]]) @ src/fusion/LinearConstraint.mbi(31:18-52:7)")
  def __constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    mosek.fusion.ModelConstraint._ModelConstraint__constructor_Omosek_fusion_Model_2SOmosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
    self.__dom = dom_
    self.__idxmap = None
  def __init__(self,*args):
    #self.__idxmap = None

    #self.__dom = None

    self.__constructor_Omosek_fusion_Model_2SOmosek_fusion_Domain_2Omosek_fusion_Set_2_3I_3L_3I_3F_3F_3I_3I_3_3I(*args)
  @staticmethod
  def _matchargs_domainToString_LOmosek_fusion_Utils_StringBuffer_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],long): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Utils.StringBuffer): return False
    return True
  # origin: src/fusion/LinearConstraint.mbi(64:18-66:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("domainToString(long,mosek.fusion.Utils.StringBuffer)")
  def _domainToString_LOmosek_fusion_Utils_StringBuffer_2(self,i,sb):
    ( self.__dom._domainToString_LOmosek_fusion_Utils_StringBuffer_2(i,sb) )
  @staticmethod
  def _matchargs_level_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearConstraint.mbi(74:18-91:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values([long],int,[float])")
  def _level_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1xc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self._nativeindexes != None):
      # src/fusion/LinearConstraint.mbi(81:11-83:80)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = (xx[self._nativeindexes[idxs[i]]] + self._cache_bfix[idxs[i]])
    else:
      # src/fusion/LinearConstraint.mbi(85:11-90:59)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = (xx[( self.__idxmap._getItem_L(idxs[i]) )] + self._cache_bfix[idxs[i]])
        else:
          target[(offset + i)] = ( self.__dom._get_1rhs_1item_L(idxs[i]) )
  @staticmethod
  def _matchargs_level_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearConstraint.mbi(94:18-128:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("level_values(long,[int],[long],int,[float])")
  def _level_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1xc_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/LinearConstraint.mbi(107:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self._nativeindexes != None):
      # src/fusion/LinearConstraint.mbi(111:11-115:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/LinearConstraint.mbi(112:11-115:11)
        target[(i + offset)] = (xx[self._nativeindexes[( cnt._get_() )]] + self._cache_bfix[( cnt._get_() )])
        ( cnt._inc_() )
        # } @ src/fusion/LinearConstraint.mbi(112:11-115:11)
    else:
      # src/fusion/LinearConstraint.mbi(119:11-126:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/LinearConstraint.mbi(120:11-126:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = (xx[( self.__idxmap._getItem_L(( cnt._get_() )) )] + self._cache_bfix[( cnt._get_() )])
        else:
          target[i] = ( self.__dom._get_1rhs_1item_L(( cnt._get_() )) )
        ( cnt._inc_() )
        # } @ src/fusion/LinearConstraint.mbi(120:11-126:11)
  @staticmethod
  def _matchargs_dual_1values__3LI_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearConstraint.mbi(137:18-152:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values([long],int,[float])")
  def _dual_1values__3LI_3F(self,idxs,offset,target):
    xx = ( self._model._getSolution_1y_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    if   (self._nativeindexes != None):
      # src/fusion/LinearConstraint.mbi(144:11-145:58)
      for i in xrange(0,int(len(idxs))):
        target[(offset + i)] = xx[self._nativeindexes[idxs[i]]]
    else:
      # src/fusion/LinearConstraint.mbi(147:11-151:59)
      for i in xrange(0,int(len(idxs))):
        if   ( self.__idxmap._hasItem_L(idxs[i]) ):
          target[(offset + i)] = xx[( self.__idxmap._getItem_L(idxs[i]) )]
        else:
          target[(offset + i)] = ( self.__dom._get_1rhs_1item_L(idxs[i]) )
  @staticmethod
  def _matchargs_dual_1values_L_3I_3LI_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],int): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/LinearConstraint.mbi(155:18-187:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dual_values(long,[int],[long],int,[float])")
  def _dual_1values_L_3I_3LI_3F(self,start,nsize,strides,offset,target):
    tlen = 1l

    n = int(len(strides))

    cnt = mosek.fusion.IndexCounter(start,nsize,strides)

    xx = ( self._model._getSolution_1y_Omosek_fusion_SolutionType_2(SolutionType.Default) )

    # src/fusion/LinearConstraint.mbi(167:9-50)
    for i in xrange(0,n):
      tlen = (tlen * nsize[i])
    if   (self._nativeindexes != None):
      # src/fusion/LinearConstraint.mbi(170:11-174:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/LinearConstraint.mbi(171:11-174:11)
        target[(i + offset)] = xx[self._nativeindexes[( cnt._get_() )]]
        ( cnt._inc_() )
        # } @ src/fusion/LinearConstraint.mbi(171:11-174:11)
    else:
      # src/fusion/LinearConstraint.mbi(178:11-185:11)
      for i in xrange(0l,tlen):
        # { @ src/fusion/LinearConstraint.mbi(179:11-185:11)
        if   ( self.__idxmap._hasItem_L(( cnt._get_() )) ):
          target[i] = xx[( self.__idxmap._getItem_L(( cnt._get_() )) )]
        else:
          target[i] = ( self.__dom._get_1rhs_1item_L(( cnt._get_() )) )
        ( cnt._inc_() )
        # } @ src/fusion/LinearConstraint.mbi(179:11-185:11)
  @staticmethod
  def _matchargs_add_1fx__3L_3FLII(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    return True
  # origin: src/fusion/LinearConstraint.mbi(190:18-228:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add_fx([long],[float],long,int,int)")
  def _add_1fx__3L_3FLII(self,subi,bfix,subibase,srcoffset,num):

    if   (self.__dom._key == RelationKey.IsFree):
      pass
    else:
      boundval = ([ 0.0 for _autovar_187 in xrange(num) ])
      idxs = ([ 0 for _autovar_188 in xrange(num) ])

      # src/fusion/LinearConstraint.mbi(208:11-209:64)
      for i in xrange(0,num):
        idxs[i] = self._nativeindexes[(subi[(srcoffset + i)] - subibase)]
      # src/fusion/LinearConstraint.mbi(211:11-212:106)
      for i in xrange(0,int(len(boundval))):
        boundval[i] = (( self.__dom._get_1rhs_1item_L((subi[(srcoffset + i)] - subibase)) ) - bfix[(subi[(srcoffset + i)] - subibase)])
      if   (self.__dom._key == RelationKey.EqualsTo):
        ( self._model._task_1con_1putboundlist_1fx__3I_3F(idxs,boundval) )
      elif (self.__dom._key == RelationKey.LessThan):
        ( self._model._task_1con_1putboundlist_1up__3I_3F(idxs,boundval) )
      elif (self.__dom._key == RelationKey.GreaterThan):
        ( self._model._task_1con_1putboundlist_1up__3I_3F(idxs,boundval) )
  @_cliptrace
  def get_model(self,*args):
    if   Constraint._matchargs_get_1model_(args):
      return Constraint._get_1model_(self,*args)
    else:
      argtypestr = "get_model(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_model()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def index(self,*args):
    if   Constraint._matchargs_index__3I(args):
      return Constraint._index__3I(self,*args)
    elif Constraint._matchargs_index_I(args):
      return Constraint._index_I(self,*args)
    else:
      argtypestr = "index(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindex([int])"),(1,"\tindex(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def add(self,*args):
    if   Constraint._matchargs_add_Omosek_fusion_Expression_2(args):
      return Constraint._add_Omosek_fusion_Expression_2(self,*args)
    elif Constraint._matchargs_add_Omosek_fusion_Variable_2(args):
      return Constraint._add_Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tadd(mosek.fusion.Expression)"),(1,"\tadd(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   ModelConstraint._matchargs_slice_II(args):
      return ModelConstraint._slice_II(self,*args)
    elif ModelConstraint._matchargs_slice__3I_3I(args):
      return ModelConstraint._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   ModelConstraint._matchargs_toString_(args):
      return ModelConstraint._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dual(self,*args):
    if   Constraint._matchargs_dual__3I_3I(args):
      return Constraint._dual__3I_3I(self,*args)
    elif Constraint._matchargs_dual_II(args):
      return Constraint._dual_II(self,*args)
    elif Constraint._matchargs_dual_(args):
      return Constraint._dual_(self,*args)
    else:
      argtypestr = "dual(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdual([int],[int])"),(2,"\tdual(int,int)"),(0,"\tdual()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def level(self,*args):
    if   Constraint._matchargs_level_I(args):
      return Constraint._level_I(self,*args)
    elif Constraint._matchargs_level_(args):
      return Constraint._level_(self,*args)
    elif Constraint._matchargs_level__3I_3I(args):
      return Constraint._level__3I_3I(self,*args)
    elif Constraint._matchargs_level_II(args):
      return Constraint._level_II(self,*args)
    else:
      argtypestr = "level(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlevel(int)"),(0,"\tlevel()"),(2,"\tlevel([int],[int])"),(2,"\tlevel(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get_nd(self,*args):
    if   Constraint._matchargs_get_1nd_(args):
      return Constraint._get_1nd_(self,*args)
    else:
      argtypestr = "get_nd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget_nd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Constraint._matchargs_stack__3Omosek_fusion_Constraint_2(args):
      return Constraint._stack__3Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    elif Constraint._matchargs_stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(args):
      return Constraint._stack_Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2Omosek_fusion_Constraint_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([mosek.fusion.Constraint])"),(2,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint)"),(3,"\tstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Constraint._matchargs_size_(args):
      return Constraint._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(14:5-19:5)
class FusionRuntimeException(Exception):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(18:15-17:68)")
  def __constructor_S(self,msg_):
    Exception.__init__(self,msg_)
    self.__msg = msg_
  def __init__(self,*args):
    #self.__msg = None

    self.__constructor_S(*args)
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Errors.mbi(19:15-18:53)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    return self.__msg
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(68:5-72:5)
class IndexError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(72:17-71:56)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(30:5-37:5)
class ExpressionError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(34:15-36:7)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(187:5-194:5)
class SparseFormatError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(191:17-193:9)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(116:5-123:5)
class ModelError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(120:17-122:9)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(157:5-169:5)
class SliceError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(161:17-163:9)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  @staticmethod
  def _matchargs_constructor_(args):
    if len(args) != 0:
      return False
    return True
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("__init__() @ src/fusion/Errors.mbi(166:17-168:9)")
  def __constructor_(self):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,"Invalid slice range")
    pass
  def __init__(self,*args):
    if   self._matchargs_constructor_S(args):
      self.__constructor_S(*args)
    elif self._matchargs_constructor_(args):
      self.__constructor_(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(23:5-27:5)
class IOError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(27:17-26:56)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(85:5-89:5)
class LengthError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(89:17-88:56)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(75:5-78:5)
class RangeError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(78:17-77:56)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(97:5-101:5)
class DimensionError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(101:17-100:56)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(50:5-57:5)
class ValueConversionError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(54:15-56:7)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(126:5-133:5)
class NameError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(130:17-132:9)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(147:5-154:5)
class SetDefinitionError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(151:17-153:9)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(136:5-143:5)
class OptimizeError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(140:17-142:9)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(61:5-65:5)
class DomainError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(65:15-64:54)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(107:5-111:5)
class MatrixError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(111:17-110:55)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(40:5-47:5)
class ParameterError(FusionRuntimeException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(44:15-46:7)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionRuntimeException._FusionRuntimeException__constructor_S(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  @_cliptrace
  def toString(self,*args):
    if   FusionRuntimeException._matchargs_toString_(args):
      return FusionRuntimeException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Set.mbi(11:5-238:5)
class Set:
  @staticmethod
  def _matchargs_constructor_IL(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,long) @ src/fusion/Set.mbi(24:15-31:7)")
  def __constructor_IL(self,nd_,size_):
    self.nd = nd_
    self._nd_p = nd_
    self._size = size_
  def __init__(self,*args):
    #self.nd = None

    #self._protected_nd_p = None

    #self._protected_size = None

    self.__constructor_IL(*args)
  @staticmethod
  def _matchargs_compare_Omosek_fusion_Set_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/Set.mbi(41:15-58:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("compare(mosek.fusion.Set)")
  def _compare_Omosek_fusion_Set_2(self,other):
    if   ((self._size != other._size) or (( self._realnd_() ) != ( other._realnd_() ))):
      return False
    i0 = 0

    i1 = 0

    # src/fusion/Set.mbi(46:9-56:9)
    while ((i0 < self.nd) and (i1 < other.nd)):
      if   (( self._dim_I(i0) ) == 1):
        i0 += 1
      elif (( other._dim_I(i1) ) == 1):
        i1 += 1
      elif (( self._dim_I(i0) ) != ( other._dim_I(i1) )):
        return False
      else:
        i0 += 1
        i1 += 1
    return True
  @staticmethod
  def _matchargs_getSize_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Set.mbi(63:15-65:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getSize()")
  def _getSize_(self):
    return self._size
  @staticmethod
  def _matchargs_realnd_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Set.mbi(70:15-81:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("realnd()")
  def _realnd_(self):
    if   (self.nd == 1):
      return 1
    else:
      r = 0

      # src/fusion/Set.mbi(75:11-79:15)
      i = 0

      while (i < self.nd):
        if   (( self._dim_I(i) ) > 1):
          r += 1
        i += 1
      if   (r == 0):
        r += 1
      return r
  @staticmethod
  def _matchargs_make__3S(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_basestring(a): return False
    return True
  # origin: src/fusion/Set.mbi(84:15-86:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("make([basestring])")
  def _make__3S(names):
    return mosek.fusion.StringSet(names)
  @staticmethod
  def _matchargs_make_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Set.mbi(89:15-91:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("make(int)")
  def _make_I(sz):
    return mosek.fusion.IntSet(sz)
  @staticmethod
  def _matchargs_make_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Set.mbi(94:15-96:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("make(int,int)")
  def _make_II(s1,s2):
    return mosek.fusion.NDSet(([ s1,s2]))
  @staticmethod
  def _matchargs_make_III(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    return True
  # origin: src/fusion/Set.mbi(99:15-101:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("make(int,int,int)")
  def _make_III(s1,s2,s3):
    return mosek.fusion.NDSet(([ s1,s2,s3]))
  @staticmethod
  def _matchargs_make__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Set.mbi(104:15-106:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("make([int])")
  def _make__3I(sizes):
    return mosek.fusion.NDSet(sizes)
  @staticmethod
  def _matchargs_make_Omosek_fusion_Set_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/Set.mbi(109:15-111:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("make(mosek.fusion.Set,mosek.fusion.Set)")
  def _make_Omosek_fusion_Set_2Omosek_fusion_Set_2(s1,s2):
    return mosek.fusion.ProductSet(([ s1,s2]))
  @staticmethod
  def _matchargs_make__3Omosek_fusion_Set_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Set): return False
    return True
  # origin: src/fusion/Set.mbi(114:15-116:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("make([mosek.fusion.Set])")
  def _make__3Omosek_fusion_Set_2(ss):
    return mosek.fusion.ProductSet(ss)
  @staticmethod
  def _matchargs_dim_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Set.mbi(126:15-127:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dim(int)")
  def _dim_I(self,i):
    pass
  @staticmethod
  def _matchargs_stride_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Set.mbi(134:15-8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stride(int)")
  def _stride_I(self,i):
    pass
  @staticmethod
  def _matchargs_getname_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/Set.mbi(141:15-142:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname(long)")
  def _getname_L(self,key):
    pass
  @staticmethod
  def _matchargs_getname__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Set.mbi(149:15-150:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname([int])")
  def _getname__3I(self,key):
    pass
  @staticmethod
  def _matchargs_idxtokey_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/Set.mbi(158:15-167:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("idxtokey(long)")
  def _idxtokey_L(self,idx):
    key = ([ 0 for _autovar_189 in xrange(self._nd_p) ])

    # src/fusion/Set.mbi(161:9-165:9)
    i = 0

    while (i < self._nd_p):
      key[i] = int((idx / ( self._stride_I(i) )))
      idx = (idx % ( self._stride_I(i) ))
      i += 1
    return key
  @staticmethod
  def _matchargs_linearidx__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Set.mbi(177:18-184:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("linearidx([int])")
  def _linearidx__3I(self,key):
    res = long(key[0])

    # src/fusion/Set.mbi(179:9-182:9)
    i = 1

    while (i < int(len(key))):
      res = ((res * long(( self._dim_I(i) ))) + long(key[i]))
      i += 1
    return res
  @staticmethod
  def _matchargs_linearidx_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Set.mbi(187:18-191:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("linearidx(int,int)")
  def _linearidx_II(self,key0,key1):
    return long(((key0 * ( self._dim_I(1) )) + key1))
  @staticmethod
  def _matchargs_linearidx_III(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    return True
  # origin: src/fusion/Set.mbi(194:18-199:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("linearidx(int,int,int)")
  def _linearidx_III(self,key0,key1,key2):
    return long(((((key0 * ( self._dim_I(1) )) + key1) * ( self._dim_I(2) )) + key2))
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Set.mbi(208:15-210:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    pass
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Set.mbi(220:15-8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int],[int])")
  def _slice__3I_3I(self,first,last):
    pass
  @staticmethod
  def _matchargs_indexToString_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/Set.mbi(224:15-223:66)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("indexToString(long)")
  def _indexToString_L(self,index):
    pass
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Set.mbi(230:15-237:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( ( sb._a_S("Set(dimensions={") )._a_I(( self._dim_I(0) )) )
    # src/fusion/Set.mbi(233:9-234:30)
    i = 1

    while (i < self.nd):
      ( ( sb._a_S(",") )._a_I(( self._dim_I(i) )) )
      i += 1
    ( sb._a_S("})") )
    return ( sb._toString_() )
  @_cliptrace
  def dim(self,*args):
    if   Set._matchargs_dim_I(args):
      return Set._dim_I(self,*args)
    else:
      argtypestr = "dim(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdim(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compare(self,*args):
    if   Set._matchargs_compare_Omosek_fusion_Set_2(args):
      return Set._compare_Omosek_fusion_Set_2(self,*args)
    else:
      argtypestr = "compare(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tcompare(mosek.fusion.Set)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   Set._matchargs_slice_II(args):
      return Set._slice_II(self,*args)
    elif Set._matchargs_slice__3I_3I(args):
      return Set._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def realnd(self,*args):
    if   Set._matchargs_realnd_(args):
      return Set._realnd_(self,*args)
    else:
      argtypestr = "realnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\trealnd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getname(self,*args):
    if   Set._matchargs_getname__3I(args):
      return Set._getname__3I(self,*args)
    elif Set._matchargs_getname_L(args):
      return Set._getname_L(self,*args)
    else:
      argtypestr = "getname(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetname([int])"),(1,"\tgetname(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getSize(self,*args):
    if   Set._matchargs_getSize_(args):
      return Set._getSize_(self,*args)
    else:
      argtypestr = "getSize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetSize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def stride(self,*args):
    if   Set._matchargs_stride_I(args):
      return Set._stride_I(self,*args)
    else:
      argtypestr = "stride(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstride(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def idxtokey(self,*args):
    if   Set._matchargs_idxtokey_L(args):
      return Set._idxtokey_L(self,*args)
    else:
      argtypestr = "idxtokey(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tidxtokey(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Set._matchargs_toString_(args):
      return Set._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def indexToString(self,*args):
    if   Set._matchargs_indexToString_L(args):
      return Set._indexToString_L(self,*args)
    else:
      argtypestr = "indexToString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindexToString(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def make(*args):
    if   Set._matchargs_make__3Omosek_fusion_Set_2(args):
      return Set._make__3Omosek_fusion_Set_2(*args)
    elif Set._matchargs_make__3I(args):
      return Set._make__3I(*args)
    elif Set._matchargs_make_II(args):
      return Set._make_II(*args)
    elif Set._matchargs_make_I(args):
      return Set._make_I(*args)
    elif Set._matchargs_make__3S(args):
      return Set._make__3S(*args)
    elif Set._matchargs_make_III(args):
      return Set._make_III(*args)
    elif Set._matchargs_make_Omosek_fusion_Set_2Omosek_fusion_Set_2(args):
      return Set._make_Omosek_fusion_Set_2Omosek_fusion_Set_2(*args)
    else:
      argtypestr = "make(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tmake([mosek.fusion.Set])"),(1,"\tmake([int])"),(2,"\tmake(int,int)"),(1,"\tmake(int)"),(1,"\tmake([basestring])"),(3,"\tmake(int,int,int)"),(2,"\tmake(mosek.fusion.Set,mosek.fusion.Set)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/NDSet.mbi(10:5-308:5)
class NDSet(Set):
  @staticmethod
  def _matchargs_constructor__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([int],[int]) @ src/fusion/NDSet.mbi(91:15-113:7)")
  def __constructor__3I_3I(self,startx,stopx):
    mosek.fusion.Set._Set__constructor_IL(self,int(len(startx)),( NDSet.__sumdims__3I_3I (startx,stopx) ))
    if   (int(len(startx)) != int(len(stopx))):
      raise mosek.fusion.LengthError("Array lengths do not match.")
    # src/fusion/NDSet.mbi(99:9-104:16)
    i = 0

    while (i < self.nd):
      if   (stopx[i] < startx[i]):
        raise mosek.fusion.SliceError("Indexes define a range with negative length.")
      i += 1
    self.__start = ( Utils.Tools._arraycopy__3I (startx) )
    self.__stop = ( Utils.Tools._arraycopy__3I (stopx) )
    self.__strides = ([ 0l for _autovar_190 in xrange(self.nd) ])
    self.__strides[(self.nd - 1)] = 1l
    # src/fusion/NDSet.mbi(109:9-112:9)
    i = (self.nd - 1)

    while (i > 0):
      self.__strides[(i - 1)] = (self.__strides[i] * (self.__stop[i] - self.__start[i]))
      i -= 1
  @staticmethod
  def _matchargs_constructor__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([int]) @ src/fusion/NDSet.mbi(124:15-138:7)")
  def __constructor__3I(self,sizes):
    mosek.fusion.Set._Set__constructor_IL(self,int(len(sizes)),( NDSet.__sumdims__3I (sizes) ))
    self.__start = ( Utils.Tools._makevector_II (0,int(len(sizes))) )
    self.__stop = ([ 0 for _autovar_191 in xrange(self.nd) ])
    self.__strides = ([ 0l for _autovar_192 in xrange(self.nd) ])
    # src/fusion/NDSet.mbi(131:9-132:30)
    for i in xrange(0,self.nd):
      self.__stop[i] = sizes[i]
    self.__strides[(self.nd - 1)] = 1l
    # src/fusion/NDSet.mbi(136:9-137:47)
    i = (self.nd - 1)

    while (i > 0):
      self.__strides[(i - 1)] = (self.__strides[i] * sizes[i])
      i -= 1
  @staticmethod
  def _matchargs_constructor_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int) @ src/fusion/NDSet.mbi(149:15-155:7)")
  def __constructor_II(self,size0,size1):
    mosek.fusion.Set._Set__constructor_IL(self,2,long((size0 * size1)))
    self.__start = ( Utils.Tools._makevector_II (0,2) )
    self.__stop = ([ size0,size1])
    self.__strides = ([ long(size1),1l])
  @staticmethod
  def _matchargs_constructor_III(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int,int) @ src/fusion/NDSet.mbi(168:15-177:7)")
  def __constructor_III(self,size0,size1,size2):
    mosek.fusion.Set._Set__constructor_IL(self,3,long(((size0 * size1) * size2)))
    self.__start = ([ 0,0,0])
    self.__stop = ([ size0,size1,size2])
    self.__strides = ([ long((size1 * size2)),long(size2),1l])
  def __init__(self,*args):
    #self.__start = None

    #self.__stop = None

    #self.__strides = None

    if   self._matchargs_constructor__3I_3I(args):
      self.__constructor__3I_3I(*args)
    elif self._matchargs_constructor__3I(args):
      self.__constructor__3I(*args)
    elif self._matchargs_constructor_II(args):
      self.__constructor_II(*args)
    elif self._matchargs_constructor_III(args):
      self.__constructor_III(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_stride_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/NDSet.mbi(26:15-28:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stride(int)")
  def _stride_I(self,i):
    return self.__strides[i]
  @staticmethod
  def _matchargs_sumdims__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/NDSet.mbi(31:16-45:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sumdims([int],[int])")
  def __sumdims__3I_3I(startx,stopx):
    if   (int(len(startx)) != int(len(stopx))):
      raise mosek.fusion.SetDefinitionError("invalid range arrays")
    res = 1l

    # src/fusion/NDSet.mbi(37:9-43:9)
    for i in xrange(0,int(len(startx))):
      # { @ src/fusion/NDSet.mbi(38:9-43:9)
      if   (stopx[i] < startx[i]):
        raise mosek.fusion.SetDefinitionError("invalid range arrays")
      res = (res * long((stopx[i] - startx[i])))
      # } @ src/fusion/NDSet.mbi(38:9-43:9)
    return res
  @staticmethod
  def _matchargs_sumdims__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/NDSet.mbi(50:16-59:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("sumdims([int])")
  def __sumdims__3I(stopx):
    res = 1l

    # src/fusion/NDSet.mbi(52:9-57:9)
    for i in xrange(0,int(len(stopx))):
      # { @ src/fusion/NDSet.mbi(53:9-57:9)
      if   (stopx[i] < 0):
        raise mosek.fusion.SetDefinitionError("invalid size definition")
      res = (res * long(stopx[i]))
      # } @ src/fusion/NDSet.mbi(53:9-57:9)
    return res
  @staticmethod
  def _matchargs_lookup_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/NDSet.mbi(62:16-76:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("lookup(int,int)")
  def __lookup_II(self,dim,idx):
    if   ((((dim < 0) or (dim >= self.nd)) or (idx < self.__start[dim])) or (idx > self.__stop[dim])):
      raise mosek.fusion.IndexError("index out of bounds")
    else:
      return (idx - self.__start[dim])
  @staticmethod
  def _matchargs_linear_1index_1in_1dim_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/NDSet.mbi(180:18-193:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("linear_index_in_dim(int,int)")
  def _linear_1index_1in_1dim_II(self,dim,key):
    if   ((dim < 0) or (dim >= int(len(self.__start)))):
      raise mosek.fusion.IndexError("dimension index out of bounds")
    if   ((key < self.__start[dim]) or (key >= self.__stop[dim])):
      raise mosek.fusion.IndexError("key out of bounds")
    else:
      return (key - self.__start[dim])
  @staticmethod
  def _matchargs_linear_1index_1in_1dim_I_3I(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/NDSet.mbi(196:18-198:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("linear_index_in_dim(int,[int])")
  def _linear_1index_1in_1dim_I_3I(self,dim,key):
    raise mosek.fusion.IndexError("invalid key type")
  @staticmethod
  def _matchargs_selectidxs__3S(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_basestring(a): return False
    return True
  # origin: src/fusion/NDSet.mbi(202:18-204:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("selectidxs([basestring])")
  def _selectidxs__3S(self,key):
    raise mosek.fusion.IndexError("invalid key type")
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/NDSet.mbi(207:15-214:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first,last):
    if   (self.nd != 1):
      raise mosek.fusion.SliceError("Slice dimensions do not match set dimensions.")
    elif (((first < 0) or (last < first)) or (long(last) > self._size)):
      raise mosek.fusion.SliceError("Slice dimensions do not match set dimensions.")
    return mosek.fusion.IntSet((first + self.__start[0]),(last + self.__start[0]))
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/NDSet.mbi(217:15-239:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int],[int])")
  def _slice__3I_3I(self,first,last):
    if   ((self.nd != int(len(first))) or (self.nd != int(len(last)))):
      raise mosek.fusion.SliceError("Slice dimensions do not match set dimensions.")
    # src/fusion/NDSet.mbi(222:9-228:9)
    i = 0

    while (i < self.nd):
      if   (((first[i] < 0) or (last[i] < first[i])) or ((last[i] + self.__start[i]) > self.__stop[i])):
        raise mosek.fusion.SliceError("Slice is out of bounds.")
      i += 1
    start_ = ([ 0 for _autovar_193 in xrange(self.nd) ])

    stop_ = ([ 0 for _autovar_194 in xrange(self.nd) ])

    # src/fusion/NDSet.mbi(232:9-236:9)
    i = 0

    while (i < self.nd):
      start_[i] = (self.__start[i] + first[i])
      stop_[i] = (self.__start[i] + last[i])
      i += 1
    return mosek.fusion.NDSet(start_,stop_)
  @staticmethod
  def _matchargs_dim_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/NDSet.mbi(242:15-247:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dim(int)")
  def _dim_I(self,i):
    if   (i >= int(len(self.__stop))):
      return 1
    else:
      return (self.__stop[i] - self.__start[i])
  @staticmethod
  def _matchargs_getname_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/NDSet.mbi(250:15-270:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname(long)")
  def _getname_L(self,key):
    if   (self.nd == 1):
      ndidx = ([ 0l for _autovar_195 in xrange(self.nd) ])

      keyremainder = key

      # src/fusion/NDSet.mbi(256:11-260:11)
      i = 0

      while (i < self.nd):
        ndidx[i] = (keyremainder / self.__strides[i])
        keyremainder = (keyremainder - (ndidx[i] * self.__strides[i]))
        i += 1
      tmp = mosek.fusion.Utils.StringBuffer()

      ( tmp._a_L((key + self.__start[0])) )
      return ( tmp._toString_() )
    else:
      return ( self._getname__3I(( self._idxtokey_L(key) )) )
  @staticmethod
  def _matchargs_getname__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/NDSet.mbi(273:15-295:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname([int])")
  def _getname__3I(self,key):
    if   (self.nd != int(len(key))):
      raise mosek.fusion.DimensionError("Key dimensions do not match set dimensions.")
    # src/fusion/NDSet.mbi(279:9-286:9)
    i = 0

    while (i < self.nd):
      if   ((key[i] < 0) or (key[i] >= ((self.__stop[i] - self.__start[i]) + 1))):
        raise mosek.fusion.IndexError("Key dimensions do not match set dimensions.")
      i += 1
    sb = mosek.fusion.Utils.StringBuffer()

    ( sb._a_I((key[0] + self.__start[0])) )
    # src/fusion/NDSet.mbi(290:9-293:9)
    i = 1

    while (i < self.nd):
      ( sb._a_S(",") )
      ( sb._a_I((key[i] + self.__start[i])) )
      i += 1
    return ( sb._toString_() )
  @staticmethod
  def _matchargs_indexToString_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/NDSet.mbi(298:15-305:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("indexToString(long)")
  def _indexToString_L(self,index):
    sb = mosek.fusion.Utils.StringBuffer()

    key = ( self._idxtokey_L(index) )

    ( sb._a_I(key[0]) )
    # src/fusion/NDSet.mbi(302:9-303:30)
    for i in xrange(1,int(len(key))):
      ( ( sb._a_S(",") )._a_I(key[i]) )
    return ( sb._toString_() )
  @_cliptrace
  def dim(self,*args):
    if   NDSet._matchargs_dim_I(args):
      return NDSet._dim_I(self,*args)
    else:
      argtypestr = "dim(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdim(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compare(self,*args):
    if   Set._matchargs_compare_Omosek_fusion_Set_2(args):
      return Set._compare_Omosek_fusion_Set_2(self,*args)
    else:
      argtypestr = "compare(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tcompare(mosek.fusion.Set)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   NDSet._matchargs_slice__3I_3I(args):
      return NDSet._slice__3I_3I(self,*args)
    elif NDSet._matchargs_slice_II(args):
      return NDSet._slice_II(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice([int],[int])"),(2,"\tslice(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def realnd(self,*args):
    if   Set._matchargs_realnd_(args):
      return Set._realnd_(self,*args)
    else:
      argtypestr = "realnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\trealnd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getname(self,*args):
    if   NDSet._matchargs_getname__3I(args):
      return NDSet._getname__3I(self,*args)
    elif NDSet._matchargs_getname_L(args):
      return NDSet._getname_L(self,*args)
    else:
      argtypestr = "getname(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetname([int])"),(1,"\tgetname(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getSize(self,*args):
    if   Set._matchargs_getSize_(args):
      return Set._getSize_(self,*args)
    else:
      argtypestr = "getSize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetSize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def stride(self,*args):
    if   NDSet._matchargs_stride_I(args):
      return NDSet._stride_I(self,*args)
    else:
      argtypestr = "stride(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstride(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def idxtokey(self,*args):
    if   Set._matchargs_idxtokey_L(args):
      return Set._idxtokey_L(self,*args)
    else:
      argtypestr = "idxtokey(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tidxtokey(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Set._matchargs_toString_(args):
      return Set._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def indexToString(self,*args):
    if   NDSet._matchargs_indexToString_L(args):
      return NDSet._indexToString_L(self,*args)
    else:
      argtypestr = "indexToString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindexToString(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def make(*args):
    if   Set._matchargs_make__3Omosek_fusion_Set_2(args):
      return Set._make__3Omosek_fusion_Set_2(*args)
    elif Set._matchargs_make__3I(args):
      return Set._make__3I(*args)
    elif Set._matchargs_make_II(args):
      return Set._make_II(*args)
    elif Set._matchargs_make_I(args):
      return Set._make_I(*args)
    elif Set._matchargs_make_III(args):
      return Set._make_III(*args)
    elif Set._matchargs_make__3S(args):
      return Set._make__3S(*args)
    elif Set._matchargs_make_Omosek_fusion_Set_2Omosek_fusion_Set_2(args):
      return Set._make_Omosek_fusion_Set_2Omosek_fusion_Set_2(*args)
    else:
      argtypestr = "make(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tmake([mosek.fusion.Set])"),(1,"\tmake([int])"),(2,"\tmake(int,int)"),(1,"\tmake(int)"),(3,"\tmake(int,int,int)"),(1,"\tmake([basestring])"),(2,"\tmake(mosek.fusion.Set,mosek.fusion.Set)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/ProductSet.mbi(9:5-63:5)
class ProductSet(NDSet):
  @staticmethod
  def _matchargs_constructor__3Omosek_fusion_Set_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Set): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([mosek.fusion.Set]) @ src/fusion/ProductSet.mbi(34:15-38:7)")
  def __constructor__3Omosek_fusion_Set_2(self,ss):
    mosek.fusion.NDSet._NDSet__constructor__3I(self,( ProductSet.__computedims__3Omosek_fusion_Set_2 (ss) ))
    self.__sets = ([ None for _autovar_196 in xrange(int(len(ss))) ])
    # src/fusion/ProductSet.mbi(37:9-49)
    for i in xrange(0,int(len(ss))):
      self.__sets[i] = ss[i]
  def __init__(self,*args):
    #self.__sets = None

    self.__constructor__3Omosek_fusion_Set_2(*args)
  @staticmethod
  def _matchargs_computedims__3Omosek_fusion_Set_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Set): return False
    return True
  # origin: src/fusion/ProductSet.mbi(14:16-26:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("computedims([mosek.fusion.Set])")
  def __computedims__3Omosek_fusion_Set_2(ss):
    ndims = 0

    # src/fusion/ProductSet.mbi(16:9-58)
    for i in xrange(0,int(len(ss))):
      ndims = (ndims + ss[i].nd)
    res = ([ 0 for _autovar_197 in xrange(ndims) ])

    p = 0

    # src/fusion/ProductSet.mbi(19:9-24:11)
    for i in xrange(0,int(len(ss))):
      # src/fusion/ProductSet.mbi(20:11-24:11)
      for j in xrange(0,ss[i].nd):
        # { @ src/fusion/ProductSet.mbi(21:11-24:11)
        res[p] = ( ss[i]._dim_I(j) )
        p += 1
        # } @ src/fusion/ProductSet.mbi(21:11-24:11)
    return res
  @staticmethod
  def _matchargs_indexToString_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/ProductSet.mbi(41:15-62:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("indexToString(long)")
  def _indexToString_L(self,index):
    key = ( self._idxtokey_L(index) )

    sb = mosek.fusion.Utils.StringBuffer()

    # { @ src/fusion/ProductSet.mbi(45:9-49:9)
    k = ([ 0 for _autovar_198 in xrange(self.__sets[0].nd) ])

    # src/fusion/ProductSet.mbi(47:11-48)
    for j in xrange(0,int(len(k))):
      k[j] = key[j]
    ( sb._a_S(( self.__sets[0]._indexToString_L(( self.__sets[0]._linearidx__3I(k) )) )) )
    # } @ src/fusion/ProductSet.mbi(45:9-49:9)
    p = self.__sets[0].nd

    # src/fusion/ProductSet.mbi(52:9-59:9)
    for i in xrange(1,int(len(self.__sets))):
      # { @ src/fusion/ProductSet.mbi(53:9-59:9)
      b = p

      p = (p + self.__sets[i].nd)
      k = ([ 0 for _autovar_199 in xrange((p - b)) ])

      # src/fusion/ProductSet.mbi(56:11-50)
      for j in xrange(0,int(len(k))):
        k[j] = key[(j + b)]
      ( ( sb._a_S(",") )._a_S(( self.__sets[i]._indexToString_L(( self.__sets[i]._linearidx__3I(k) )) )) )
      # } @ src/fusion/ProductSet.mbi(53:9-59:9)
    return ( sb._toString_() )
  @_cliptrace
  def dim(self,*args):
    if   NDSet._matchargs_dim_I(args):
      return NDSet._dim_I(self,*args)
    else:
      argtypestr = "dim(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdim(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compare(self,*args):
    if   Set._matchargs_compare_Omosek_fusion_Set_2(args):
      return Set._compare_Omosek_fusion_Set_2(self,*args)
    else:
      argtypestr = "compare(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tcompare(mosek.fusion.Set)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   NDSet._matchargs_slice_II(args):
      return NDSet._slice_II(self,*args)
    elif NDSet._matchargs_slice__3I_3I(args):
      return NDSet._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def realnd(self,*args):
    if   Set._matchargs_realnd_(args):
      return Set._realnd_(self,*args)
    else:
      argtypestr = "realnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\trealnd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getname(self,*args):
    if   NDSet._matchargs_getname__3I(args):
      return NDSet._getname__3I(self,*args)
    elif NDSet._matchargs_getname_L(args):
      return NDSet._getname_L(self,*args)
    else:
      argtypestr = "getname(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetname([int])"),(1,"\tgetname(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getSize(self,*args):
    if   Set._matchargs_getSize_(args):
      return Set._getSize_(self,*args)
    else:
      argtypestr = "getSize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetSize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def stride(self,*args):
    if   NDSet._matchargs_stride_I(args):
      return NDSet._stride_I(self,*args)
    else:
      argtypestr = "stride(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstride(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def idxtokey(self,*args):
    if   Set._matchargs_idxtokey_L(args):
      return Set._idxtokey_L(self,*args)
    else:
      argtypestr = "idxtokey(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tidxtokey(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Set._matchargs_toString_(args):
      return Set._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def indexToString(self,*args):
    if   ProductSet._matchargs_indexToString_L(args):
      return ProductSet._indexToString_L(self,*args)
    else:
      argtypestr = "indexToString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindexToString(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def make(*args):
    if   Set._matchargs_make__3Omosek_fusion_Set_2(args):
      return Set._make__3Omosek_fusion_Set_2(*args)
    elif Set._matchargs_make__3I(args):
      return Set._make__3I(*args)
    elif Set._matchargs_make_II(args):
      return Set._make_II(*args)
    elif Set._matchargs_make_I(args):
      return Set._make_I(*args)
    elif Set._matchargs_make__3S(args):
      return Set._make__3S(*args)
    elif Set._matchargs_make_III(args):
      return Set._make_III(*args)
    elif Set._matchargs_make_Omosek_fusion_Set_2Omosek_fusion_Set_2(args):
      return Set._make_Omosek_fusion_Set_2Omosek_fusion_Set_2(*args)
    else:
      argtypestr = "make(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tmake([mosek.fusion.Set])"),(1,"\tmake([int])"),(2,"\tmake(int,int)"),(1,"\tmake(int)"),(1,"\tmake([basestring])"),(3,"\tmake(int,int,int)"),(2,"\tmake(mosek.fusion.Set,mosek.fusion.Set)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/BaseSet.mbi(8:5-26:5)
class BaseSet(Set):
  @staticmethod
  def _matchargs_constructor_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(long) @ src/fusion/BaseSet.mbi(15:15-17:7)")
  def __constructor_L(self,size_):
    mosek.fusion.Set._Set__constructor_IL(self,1,size_)
    pass
  def __init__(self,*args):
    self.__constructor_L(*args)
  @staticmethod
  def _matchargs_dim_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/BaseSet.mbi(20:15-25:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dim(int)")
  def _dim_I(self,i):
    if   (i != 0):
      return 1
    else:
      return int(self._size)
  @_cliptrace
  def dim(self,*args):
    if   BaseSet._matchargs_dim_I(args):
      return BaseSet._dim_I(self,*args)
    else:
      argtypestr = "dim(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdim(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compare(self,*args):
    if   Set._matchargs_compare_Omosek_fusion_Set_2(args):
      return Set._compare_Omosek_fusion_Set_2(self,*args)
    else:
      argtypestr = "compare(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tcompare(mosek.fusion.Set)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   Set._matchargs_slice__3I_3I(args):
      return Set._slice__3I_3I(self,*args)
    elif Set._matchargs_slice_II(args):
      return Set._slice_II(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice([int],[int])"),(2,"\tslice(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def realnd(self,*args):
    if   Set._matchargs_realnd_(args):
      return Set._realnd_(self,*args)
    else:
      argtypestr = "realnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\trealnd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getname(self,*args):
    if   Set._matchargs_getname__3I(args):
      return Set._getname__3I(self,*args)
    elif Set._matchargs_getname_L(args):
      return Set._getname_L(self,*args)
    else:
      argtypestr = "getname(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetname([int])"),(1,"\tgetname(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getSize(self,*args):
    if   Set._matchargs_getSize_(args):
      return Set._getSize_(self,*args)
    else:
      argtypestr = "getSize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetSize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def stride(self,*args):
    if   Set._matchargs_stride_I(args):
      return Set._stride_I(self,*args)
    else:
      argtypestr = "stride(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstride(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def idxtokey(self,*args):
    if   Set._matchargs_idxtokey_L(args):
      return Set._idxtokey_L(self,*args)
    else:
      argtypestr = "idxtokey(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tidxtokey(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Set._matchargs_toString_(args):
      return Set._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def indexToString(self,*args):
    if   Set._matchargs_indexToString_L(args):
      return Set._indexToString_L(self,*args)
    else:
      argtypestr = "indexToString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindexToString(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def make(*args):
    if   Set._matchargs_make__3Omosek_fusion_Set_2(args):
      return Set._make__3Omosek_fusion_Set_2(*args)
    elif Set._matchargs_make__3I(args):
      return Set._make__3I(*args)
    elif Set._matchargs_make_II(args):
      return Set._make_II(*args)
    elif Set._matchargs_make_I(args):
      return Set._make_I(*args)
    elif Set._matchargs_make__3S(args):
      return Set._make__3S(*args)
    elif Set._matchargs_make_III(args):
      return Set._make_III(*args)
    elif Set._matchargs_make_Omosek_fusion_Set_2Omosek_fusion_Set_2(args):
      return Set._make_Omosek_fusion_Set_2Omosek_fusion_Set_2(*args)
    else:
      argtypestr = "make(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tmake([mosek.fusion.Set])"),(1,"\tmake([int])"),(2,"\tmake(int,int)"),(1,"\tmake(int)"),(1,"\tmake([basestring])"),(3,"\tmake(int,int,int)"),(2,"\tmake(mosek.fusion.Set,mosek.fusion.Set)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/StringSet.mbi(7:5-92:5)
class StringSet(BaseSet):
  @staticmethod
  def _matchargs_constructor__3S(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_basestring(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([basestring]) @ src/fusion/StringSet.mbi(15:15-18:7)")
  def __constructor__3S(self,ks):
    mosek.fusion.BaseSet._BaseSet__constructor_L(self,long(int(len(ks))))
    self.__keys = ( Utils.Tools._arraycopy__3S (ks) )
  def __init__(self,*args):
    #self.__keys = None

    self.__constructor__3S(*args)
  @staticmethod
  def _matchargs_stride_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/StringSet.mbi(21:15-23:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stride(int)")
  def _stride_I(self,i):
    return 1l
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/StringSet.mbi(25:15-35:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( ( ( sb._a_S("{'") )._a_S(self.__keys[0]) )._a_S("'") )
    # src/fusion/StringSet.mbi(29:9-32:9)
    i = 1

    while (i < int(len(self.__keys))):
      ( ( ( sb._a_S(",'") )._a_S(self.__keys[i]) )._a_S("'") )
      i += 1
    ( sb._a_S("}") )
    return ( sb._toString_() )
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/StringSet.mbi(38:15-40:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,first_,last_):
    return ( self._slice_1_II(first_,last_) )
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/StringSet.mbi(43:15-45:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int],[int])")
  def _slice__3I_3I(self,first_,last_):
    return ( self._slice_1__3I_3I(first_,last_) )
  @staticmethod
  def _matchargs_slice_1_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/StringSet.mbi(48:18-57:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice_(int,int)")
  def _slice_1_II(self,first,last):
    if   (((first < 0) or (first > last)) or (last > int(len(self.__keys)))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    res = ([ None for _autovar_200 in xrange((last - first)) ])

    # src/fusion/StringSet.mbi(55:9-68)
    i = 0

    while (i < (last - first)):
      res[i] = self.__keys[(i + first)]
      i += 1
    return mosek.fusion.StringSet(res)
  @staticmethod
  def _matchargs_slice_1__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/StringSet.mbi(59:18-71:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice_([int],[int])")
  def _slice_1__3I_3I(self,first,last):
    if   (((((int(len(first)) != 1) or (int(len(last)) != 1)) or (first[0] < 0)) or (first[0] > last[0])) or (last[0] >= int(len(self.__keys)))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    res = ([ None for _autovar_201 in xrange(((last[0] - first[0]) + 1)) ])

    return mosek.fusion.StringSet(res)
  @staticmethod
  def _matchargs_getname_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/StringSet.mbi(74:15-76:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname(long)")
  def _getname_L(self,key):
    return self.__keys[key]
  @staticmethod
  def _matchargs_getname__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/StringSet.mbi(79:15-85:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname([int])")
  def _getname__3I(self,key):
    if   (int(len(key)) != 1):
      raise mosek.fusion.IndexError("Invalid key specification")
    return self.__keys[key[0]]
  @staticmethod
  def _matchargs_indexToString_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/StringSet.mbi(88:15-90:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("indexToString(long)")
  def _indexToString_L(self,index):
    return self.__keys[index]
  @_cliptrace
  def dim(self,*args):
    if   BaseSet._matchargs_dim_I(args):
      return BaseSet._dim_I(self,*args)
    else:
      argtypestr = "dim(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdim(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compare(self,*args):
    if   Set._matchargs_compare_Omosek_fusion_Set_2(args):
      return Set._compare_Omosek_fusion_Set_2(self,*args)
    else:
      argtypestr = "compare(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tcompare(mosek.fusion.Set)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   StringSet._matchargs_slice_II(args):
      return StringSet._slice_II(self,*args)
    elif StringSet._matchargs_slice__3I_3I(args):
      return StringSet._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def realnd(self,*args):
    if   Set._matchargs_realnd_(args):
      return Set._realnd_(self,*args)
    else:
      argtypestr = "realnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\trealnd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getname(self,*args):
    if   StringSet._matchargs_getname__3I(args):
      return StringSet._getname__3I(self,*args)
    elif StringSet._matchargs_getname_L(args):
      return StringSet._getname_L(self,*args)
    else:
      argtypestr = "getname(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetname([int])"),(1,"\tgetname(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getSize(self,*args):
    if   Set._matchargs_getSize_(args):
      return Set._getSize_(self,*args)
    else:
      argtypestr = "getSize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetSize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def stride(self,*args):
    if   StringSet._matchargs_stride_I(args):
      return StringSet._stride_I(self,*args)
    else:
      argtypestr = "stride(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstride(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def idxtokey(self,*args):
    if   Set._matchargs_idxtokey_L(args):
      return Set._idxtokey_L(self,*args)
    else:
      argtypestr = "idxtokey(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tidxtokey(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   StringSet._matchargs_toString_(args):
      return StringSet._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def indexToString(self,*args):
    if   StringSet._matchargs_indexToString_L(args):
      return StringSet._indexToString_L(self,*args)
    else:
      argtypestr = "indexToString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindexToString(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def make(*args):
    if   Set._matchargs_make__3Omosek_fusion_Set_2(args):
      return Set._make__3Omosek_fusion_Set_2(*args)
    elif Set._matchargs_make__3I(args):
      return Set._make__3I(*args)
    elif Set._matchargs_make_II(args):
      return Set._make_II(*args)
    elif Set._matchargs_make_I(args):
      return Set._make_I(*args)
    elif Set._matchargs_make__3S(args):
      return Set._make__3S(*args)
    elif Set._matchargs_make_III(args):
      return Set._make_III(*args)
    elif Set._matchargs_make_Omosek_fusion_Set_2Omosek_fusion_Set_2(args):
      return Set._make_Omosek_fusion_Set_2Omosek_fusion_Set_2(*args)
    else:
      argtypestr = "make(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tmake([mosek.fusion.Set])"),(1,"\tmake([int])"),(2,"\tmake(int,int)"),(1,"\tmake(int)"),(1,"\tmake([basestring])"),(3,"\tmake(int,int,int)"),(2,"\tmake(mosek.fusion.Set,mosek.fusion.Set)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/IntSet.mbi(9:5-93:5)
class IntSet(BaseSet):
  @staticmethod
  def _matchargs_constructor_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int) @ src/fusion/IntSet.mbi(20:15-24:7)")
  def __constructor_II(self,first_,last_):
    mosek.fusion.BaseSet._BaseSet__constructor_L(self,long((last_ - first_)))
    self.__first = first_
    self.__last = last_
  @staticmethod
  def _matchargs_constructor_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int) @ src/fusion/IntSet.mbi(31:15-35:7)")
  def __constructor_I(self,length):
    mosek.fusion.BaseSet._BaseSet__constructor_L(self,long(length))
    self.__first = 0
    self.__last = length
  def __init__(self,*args):
    #self.__first = None

    #self.__last = None

    if   self._matchargs_constructor_II(args):
      self.__constructor_II(*args)
    elif self._matchargs_constructor_I(args):
      self.__constructor_I(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_stride_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/IntSet.mbi(38:15-40:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stride(int)")
  def _stride_I(self,i):
    return 1l
  @staticmethod
  def _matchargs_getidx_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/IntSet.mbi(43:15-49:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getidx(int)")
  def _getidx_I(self,key):
    if   ((key < self.__first) or (key > self.__last)):
      raise mosek.fusion.IndexError("Index out of bounds")
    return (key - self.__first)
  @staticmethod
  def _matchargs_slice_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/IntSet.mbi(52:15-62:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice(int,int)")
  def _slice_II(self,firstidx,lastidx):
    if   (((firstidx < 0) or (firstidx > lastidx)) or (lastidx > (self.__last - self.__first))):
      raise mosek.fusion.SliceError("Invalid slice specification")
    return mosek.fusion.IntSet((self.__first + firstidx),(self.__first + lastidx))
  @staticmethod
  def _matchargs_slice__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/IntSet.mbi(65:15-74:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("slice([int],[int])")
  def _slice__3I_3I(self,firstidx,lastidx):
    if   ((int(len(firstidx)) != 1) or (int(len(lastidx)) != 1)):
      raise mosek.fusion.SliceError("Invalid slice specification")
    return ( self._slice_II(firstidx[0],lastidx[0]) )
  @staticmethod
  def _matchargs_getname_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/IntSet.mbi(77:15-79:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname(long)")
  def _getname_L(self,key):
    return ( Utils.Tools._stringvalue_L (key) )
  @staticmethod
  def _matchargs_getname__3I(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/IntSet.mbi(82:15-87:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getname([int])")
  def _getname__3I(self,key):
    if   (int(len(key)) != 1):
      raise mosek.fusion.IndexError("Invalid key specification")
    return ( Utils.Tools._stringvalue_I (key[0]) )
  @staticmethod
  def _matchargs_indexToString_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/IntSet.mbi(90:15-92:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("indexToString(long)")
  def _indexToString_L(self,index):
    return ( ( mosek.fusion.Utils.StringBuffer()._a_L(index) )._toString_() )
  @_cliptrace
  def dim(self,*args):
    if   BaseSet._matchargs_dim_I(args):
      return BaseSet._dim_I(self,*args)
    else:
      argtypestr = "dim(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tdim(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def compare(self,*args):
    if   Set._matchargs_compare_Omosek_fusion_Set_2(args):
      return Set._compare_Omosek_fusion_Set_2(self,*args)
    else:
      argtypestr = "compare(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tcompare(mosek.fusion.Set)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def slice(self,*args):
    if   IntSet._matchargs_slice_II(args):
      return IntSet._slice_II(self,*args)
    elif IntSet._matchargs_slice__3I_3I(args):
      return IntSet._slice__3I_3I(self,*args)
    else:
      argtypestr = "slice(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tslice(int,int)"),(2,"\tslice([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def realnd(self,*args):
    if   Set._matchargs_realnd_(args):
      return Set._realnd_(self,*args)
    else:
      argtypestr = "realnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\trealnd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getname(self,*args):
    if   IntSet._matchargs_getname__3I(args):
      return IntSet._getname__3I(self,*args)
    elif IntSet._matchargs_getname_L(args):
      return IntSet._getname_L(self,*args)
    else:
      argtypestr = "getname(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetname([int])"),(1,"\tgetname(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getSize(self,*args):
    if   Set._matchargs_getSize_(args):
      return Set._getSize_(self,*args)
    else:
      argtypestr = "getSize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetSize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def stride(self,*args):
    if   IntSet._matchargs_stride_I(args):
      return IntSet._stride_I(self,*args)
    else:
      argtypestr = "stride(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstride(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def idxtokey(self,*args):
    if   Set._matchargs_idxtokey_L(args):
      return Set._idxtokey_L(self,*args)
    else:
      argtypestr = "idxtokey(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tidxtokey(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Set._matchargs_toString_(args):
      return Set._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def indexToString(self,*args):
    if   IntSet._matchargs_indexToString_L(args):
      return IntSet._indexToString_L(self,*args)
    else:
      argtypestr = "indexToString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tindexToString(long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def make(*args):
    if   Set._matchargs_make__3Omosek_fusion_Set_2(args):
      return Set._make__3Omosek_fusion_Set_2(*args)
    elif Set._matchargs_make__3I(args):
      return Set._make__3I(*args)
    elif Set._matchargs_make_II(args):
      return Set._make_II(*args)
    elif Set._matchargs_make_I(args):
      return Set._make_I(*args)
    elif Set._matchargs_make__3S(args):
      return Set._make__3S(*args)
    elif Set._matchargs_make_III(args):
      return Set._make_III(*args)
    elif Set._matchargs_make_Omosek_fusion_Set_2Omosek_fusion_Set_2(args):
      return Set._make_Omosek_fusion_Set_2Omosek_fusion_Set_2(*args)
    else:
      argtypestr = "make(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tmake([mosek.fusion.Set])"),(1,"\tmake([int])"),(2,"\tmake(int,int)"),(1,"\tmake(int)"),(1,"\tmake([basestring])"),(3,"\tmake(int,int,int)"),(2,"\tmake(mosek.fusion.Set,mosek.fusion.Set)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getidx(self,*args):
    if   IntSet._matchargs_getidx_I(args):
      return IntSet._getidx_I(self,*args)
    else:
      argtypestr = "getidx(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetidx(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Expression.mbi(11:5-87:5)
class Expression:
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Model,mosek.fusion.Set) @ src/fusion/Expression.mbi(20:15-23:7)")
  def __constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,m,s):
    self._model = m
    self._shape = s
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Variable,mosek.fusion.Set) @ src/fusion/Expression.mbi(28:15-32:7)")
  def __constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2(self,v,s):
    if   (v == None):
      self._model = None
    else:
      self._model = v._model
    self._shape = s
  def __init__(self,*args):
    #self._protected_model = None

    #self._protected_shape = None

    if   self._matchargs_constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(args):
      self.__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(*args)
    elif self._matchargs_constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2(args):
      self.__constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_getShape_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(26:15-25:53)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getShape()")
  def _getShape_(self):
    return self._shape
  @staticmethod
  def _matchargs_getModel_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(40:15-41:24)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getModel()")
  def _getModel_(self):
    return self._model
  @staticmethod
  def _matchargs_eval_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(49:15-50:10)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("eval()")
  def _eval_(self):
    pass
  @staticmethod
  def _matchargs_size_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(61:15-62:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("size()")
  def _size_(self):
    pass
  @staticmethod
  def _matchargs_numNonzeros_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(73:15-74:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numNonzeros()")
  def _numNonzeros_(self):
    pass
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expression.mbi(81:15-86:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( sb._a_S("Expression(size=") )
    ( sb._a_L(( self._size_() )) )
    ( sb._a_S(")") )
    return ( sb._toString_() )
  @_cliptrace
  def getShape(self,*args):
    if   Expression._matchargs_getShape_(args):
      return Expression._getShape_(self,*args)
    else:
      argtypestr = "getShape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetShape()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Expression._matchargs_toString_(args):
      return Expression._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def eval(self,*args):
    if   Expression._matchargs_eval_(args):
      return Expression._eval_(self,*args)
    else:
      argtypestr = "eval(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\teval()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getModel(self,*args):
    if   Expression._matchargs_getModel_(args):
      return Expression._getModel_(self,*args)
    else:
      argtypestr = "getModel(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetModel()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def numNonzeros(self,*args):
    if   Expression._matchargs_numNonzeros_(args):
      return Expression._numNonzeros_(self,*args)
    else:
      argtypestr = "numNonzeros(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumNonzeros()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Expression._matchargs_size_(args):
      return Expression._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Expr.mbi(177:5-6317:5)
class Expr(Expression):
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Expression) @ src/fusion/Expr.mbi(221:18-235:7)")
  def __constructor_Omosek_fusion_Expression_2(self,e):
    mosek.fusion.Expression._Expression__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,e._model,e._shape)
    fe = ( e._eval_() )

    self.__ptrb = fe.ptrb
    self.__subj = fe.subj
    self.__x = fe.x
    self.__cof_v = fe.cof
    self.__bfix = fe.bfix
    self.__inst = fe.inst
  @staticmethod
  def _matchargs_constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3LI(args):
    if len(args) != 8:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[5] is not None and not isinstance(args[5],mosek.fusion.Set): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[7],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([long],mosek.fusion.Variable,[long],[float],[float],mosek.fusion.Set,[long],int) @ src/fusion/Expr.mbi(244:18-262:7)")
  def __constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3LI(self,ptrb_,v,subj_,cof_,bfix_,shape_,inst_,unchecked_):
    mosek.fusion.Expression._Expression__constructor_Omosek_fusion_Variable_2Omosek_fusion_Set_2(self,v,shape_)
    self.__x = v
    self.__ptrb = ptrb_
    self.__subj = subj_
    self.__cof_v = cof_
    self.__bfix = bfix_
    if   (shape_ == None):
      self._shape = mosek.fusion.IntSet((int(len(ptrb_)) - 1))
    else:
      self._shape = shape_
    self.__inst = inst_
  @staticmethod
  def _matchargs_constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3L(args):
    if len(args) != 7:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[5] is not None and not isinstance(args[5],mosek.fusion.Set): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([long],mosek.fusion.Variable,[long],[float],[float],mosek.fusion.Set,[long]) @ src/fusion/Expr.mbi(310:15-398:7)")
  def __constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3L(self,ptrb_,v,subj_,cof_,bfix_,shape_,inst_):
    mosek.fusion.Expression._Expression__constructor_Omosek_fusion_Model_2Omosek_fusion_Set_2(self,( Expr.__model_1from_Omosek_fusion_Variable_2 (v) ),shape_)
    self.__x = v
    exprnume = (int(len(ptrb_)) - 1)

    numelm = ptrb_[(int(len(ptrb_)) - 1)]

    numvar = 0l

    if   (v != None):
      numvar = v.shape._size
    if   (int(len(ptrb_)) < 1):
      raise mosek.fusion.ExpressionError("Array 'ptrb' in expression is too short")
    if   (numelm > int(len(subj_))):
      raise mosek.fusion.ExpressionError("Array 'subj' in expression is too short")
    if   (numelm > int(len(cof_))):
      raise mosek.fusion.ExpressionError("Array 'cof' in expression is too short")
    if   ((bfix_ != None) and (exprnume != int(len(bfix_)))):
      raise mosek.fusion.ExpressionError("Array 'bfix' in expression has wrong length")
    if   (shape_ != None):
      if   (inst_ != None):
        self.__inst = inst_
        if   (int(len(self.__inst)) != (int(len(ptrb_)) - 1)):
          raise mosek.fusion.ExpressionError("Array 'inst' in expression has wrong length")
        if   (int(len(self.__inst)) > 0):
          if   ((self.__inst[0] < 0) or (self.__inst[0] >= shape_._size)):
            raise mosek.fusion.ExpressionError("Array 'inst' contains an invalid index")
          # src/fusion/Expr.mbi(348:15-354:15)
          i = 1

          while (i < int(len(inst_))):
            if   ((self.__inst[i] < 0) or (self.__inst[i] >= shape_._size)):
              raise mosek.fusion.ExpressionError("Array 'inst' contains an invalid index")
            elif (self.__inst[i] <= self.__inst[(i - 1)]):
              raise mosek.fusion.ExpressionError("Array 'inst' is not correctly ordered")
            i += 1
      else:
        self.__inst = None
        if   (shape_._size != (long(len(ptrb_)) - 1l)):
          raise mosek.fusion.ExpressionError("Array 'ptrb' in expression has wrong length")
    else:
      self.__inst = None
      self._shape = mosek.fusion.IntSet((int(len(ptrb_)) - 1))
    # src/fusion/Expr.mbi(371:9-375:9)
    i = 0

    while (i < exprnume):
      if   (ptrb_[i] > ptrb_[(i + 1)]):
        raise mosek.fusion.ExpressionError("Invalid 'ptrb' argument in expression")
      i += 1
    # src/fusion/Expr.mbi(377:9-383:9)
    i = 0l

    while (i < numelm):
      if   (subj_[i] > numvar):
        raise mosek.fusion.ExpressionError("Invalid 'subj' argument in expression")
      i += 1
    self.__ptrb = ( Utils.Tools._arraycopy__3L (ptrb_) )
    self.__subj = ([ 0l for _autovar_202 in xrange(numelm) ])
    ( Utils.Tools._arraycopy__3LL_3LLL (subj_,0l,self.__subj,0l,numelm) )
    self.__cof_v = ([ 0.0 for _autovar_203 in xrange(numelm) ])
    ( Utils.Tools._arraycopy__3FL_3FLL (cof_,0l,self.__cof_v,0l,numelm) )
    self.__bfix = None
    if   (bfix_ != None):
      self.__bfix = ( Utils.Tools._arraycopy__3F (bfix_) )
    else:
      self.__bfix = None
  def __init__(self,*args):
    #self.__bfix = None

    #self.__ptrb = None

    #self.__subj = None

    #self.__x = None

    #self.__cof_v = None

    #self.__inst = None

    if   self._matchargs_constructor_Omosek_fusion_Expression_2(args):
      self.__constructor_Omosek_fusion_Expression_2(*args)
    elif self._matchargs_constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3LI(args):
      self.__constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3LI(*args)
    elif self._matchargs_constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3L(args):
      self.__constructor__3LOmosek_fusion_Variable_2_3L_3F_3FOmosek_fusion_Set_2_3L(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_model_1from_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(266:16-265:110)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("model_from(mosek.fusion.Variable)")
  def __model_1from_Omosek_fusion_Variable_2(v):
    if   (v == None):
      return None
    else:
      return v._model
  @staticmethod
  def _matchargs_stack_1x_1vars_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(401:16-423:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stack_x_vars(mosek.fusion.Variable,mosek.fusion.Variable)")
  def __stack_1x_1vars_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(x1,x2):

    if   (x1 != None):
      if   (x2 != None):
        x = mosek.fusion.CompoundVariable(([ ( x1._flatten_() ),( x2._flatten_() )]),0)
      else:
        x = x1
    else:
      if   (x2 != None):
        x = x2
      else:
        x = None
    return x
  @staticmethod
  def _matchargs_add2_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(427:16-621:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add2(mosek.fusion.Expression,mosek.fusion.Expression)")
  def __add2_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(ex1,ex2):
    fe1 = ( ex1._eval_() )

    fe2 = ( ex2._eval_() )

    if   (((ex1._model != None) and (ex2._model != None)) and (ex1._model != ex2._model)):
      raise mosek.fusion.LengthError("Operands belong to different models")
    if   (not ( fe1.shape._compare_Omosek_fusion_Set_2(fe2.shape) )):
      raise mosek.fusion.LengthError("Operand shapes do not match")
    rnnz = 0l

    rnelm = (long(len(fe1.cof)) + long(len(fe2.cof)))

    if   ((fe1.inst != None) or (fe2.inst != None)):
      rnnz = (long(len(fe1.ptrb)) - 1)
    else:
      i1 = 0

      e1 = int(len(fe1.inst))

      i2 = 0

      e2 = int(len(fe2.inst))

      # src/fusion/Expr.mbi(448:11-463:13)
      while ((i1 < e1) and (i2 < e2)):
        if   (fe1.inst[i1] < fe2.inst[i2]):
          rnnz += 1
          i1 += 1
        elif (fe1.inst[i1] > fe2.inst[i2]):
          rnnz += 1
          i2 += 1
        else:
          rnnz += 1
          i1 += 1
          i2 += 1
    ptrb = ([ 0l for _autovar_204 in xrange((rnnz + 1)) ])

    inst = None

    subj = ([ 0l for _autovar_205 in xrange(rnelm) ])

    cof = ([ 0.0 for _autovar_206 in xrange(rnelm) ])

    bfix = None

    if   ((fe1.inst == None) and (fe2.inst == None)):
      x2_offset = fe1.x.shape._size

      subj_i = 0l

      ptrb_i = 0

      # src/fusion/Expr.mbi(477:11-492:11)
      for i in xrange(0,(int(len(fe1.ptrb)) - 1)):
        # { @ src/fusion/Expr.mbi(478:11-492:11)
        # src/fusion/Expr.mbi(479:13-484:13)
        for k in xrange(fe1.ptrb[i],fe1.ptrb[(i + 1)]):
          # { @ src/fusion/Expr.mbi(480:13-484:13)
          subj[subj_i] = fe1.subj[k]
          cof[subj_i] = fe1.cof[k]
          subj_i += 1
          # } @ src/fusion/Expr.mbi(480:13-484:13)
        # src/fusion/Expr.mbi(485:13-490:13)
        for k in xrange(fe2.ptrb[i],fe2.ptrb[(i + 1)]):
          # { @ src/fusion/Expr.mbi(486:13-490:13)
          subj[subj_i] = (fe2.subj[k] + x2_offset)
          cof[subj_i] = fe2.cof[k]
          subj_i += 1
          # } @ src/fusion/Expr.mbi(486:13-490:13)
        ptrb[(i + 1)] = subj_i
        # } @ src/fusion/Expr.mbi(478:11-492:11)
    else:
      inst = ([ 0l for _autovar_207 in xrange(rnnz) ])
      x2_offset = fe1.x.shape._size

      subj_i = 0l

      ptrb_i = 0

      i1 = 0

      e1 = int(len(fe1.inst))

      i2 = 0

      e2 = int(len(fe2.inst))

      inst1 = fe1.inst

      inst2 = fe2.inst

      if   (inst1 == None):
        inst1 = ( Utils.Tools._range_L (long(len(fe2.inst))) )
      if   (inst2 == None):
        inst2 = ( Utils.Tools._range_L (long(len(fe1.inst))) )
      # src/fusion/Expr.mbi(508:11-553:13)
      while ((i1 < e1) and (i2 < e2)):
        if   (inst1[i1] < inst2[i2]):
          # src/fusion/Expr.mbi(511:15-516:15)
          for k in xrange(fe1.ptrb[i1],fe1.ptrb[(i1 + 1)]):
            # { @ src/fusion/Expr.mbi(512:15-516:15)
            subj[subj_i] = fe1.subj[k]
            cof[subj_i] = fe1.cof[k]
            subj_i += 1
            # } @ src/fusion/Expr.mbi(512:15-516:15)
          ptrb[(ptrb_i + 1)] = subj_i
          inst[ptrb_i] = inst1[i1]
          ptrb_i += 1
          i1 += 1
        elif (inst1[i1] > inst2[i2]):
          # src/fusion/Expr.mbi(524:15-529:15)
          for k in xrange(fe2.ptrb[i2],fe2.ptrb[(i2 + 1)]):
            # { @ src/fusion/Expr.mbi(525:15-529:15)
            subj[subj_i] = (fe2.subj[k] + x2_offset)
            cof[subj_i] = fe2.cof[k]
            subj_i += 1
            # } @ src/fusion/Expr.mbi(525:15-529:15)
          ptrb[(ptrb_i + 1)] = subj_i
          inst[ptrb_i] = inst2[i2]
          ptrb_i += 1
          i2 += 1
        else:
          # src/fusion/Expr.mbi(537:15-542:15)
          for k in xrange(fe1.ptrb[i1],fe1.ptrb[(i1 + 1)]):
            # { @ src/fusion/Expr.mbi(538:15-542:15)
            subj[subj_i] = fe1.subj[k]
            cof[subj_i] = fe1.cof[k]
            subj_i += 1
            # } @ src/fusion/Expr.mbi(538:15-542:15)
          # src/fusion/Expr.mbi(543:15-548:15)
          for k in xrange(fe2.ptrb[i1],fe2.ptrb[(i2 + 1)]):
            # { @ src/fusion/Expr.mbi(544:15-548:15)
            subj[subj_i] = (fe2.subj[k] + x2_offset)
            cof[subj_i] = fe2.cof[k]
            subj_i += 1
            # } @ src/fusion/Expr.mbi(544:15-548:15)
          ptrb[(ptrb_i + 1)] = subj_i
          inst[ptrb_i] = inst1[i1]
          ptrb_i += 1
          i1 += 1
          i2 += 1
      if   (int(len(inst)) == fe1.shape._size):
        inst = None
    if   ((fe1.bfix != None) or (fe2.bfix != None)):
      if   ((((fe1.inst == None) and (fe2.inst == None)) and (fe1.bfix != None)) and (fe2.bfix != None)):
        bfix = ([ 0.0 for _autovar_208 in xrange(rnnz) ])
        # src/fusion/Expr.mbi(566:13-71)
        for i in xrange(0l,rnnz):
          bfix[i] = (fe1.bfix[i] + fe2.bfix[i])
      elif ((fe1.inst == None) and (fe1.bfix != None)):
        bfix = ( Utils.Tools._arraycopy__3F (fe1.bfix) )
        if   (fe2.bfix != None):
          # src/fusion/Expr.mbi(574:15-575:68)
          for i in xrange(0,int(len(fe2.bfix))):
            bfix[fe2.inst[i]] = (bfix[fe2.inst[i]] + fe2.bfix[i])
      elif ((fe2.inst == None) and (fe2.bfix != None)):
        bfix = ( Utils.Tools._arraycopy__3F (fe2.bfix) )
        if   (fe1.bfix != None):
          # src/fusion/Expr.mbi(584:15-585:68)
          for i in xrange(0,int(len(fe1.bfix))):
            bfix[fe1.inst[i]] = (bfix[fe1.inst[i]] + fe1.bfix[i])
      else:
        bfix = ([ 0.0 for _autovar_209 in xrange(rnnz) ])
        bfix1 = fe1.bfix

        bfix2 = fe2.bfix

        if   (bfix1 == None):
          bfix1 = ([ 0.0 for _autovar_210 in xrange((int(len(fe1.ptrb)) - 1)) ])
        if   (bfix2 == None):
          bfix2 = ([ 0.0 for _autovar_211 in xrange((int(len(fe2.ptrb)) - 1)) ])
        bfix_i = 0

        # { @ src/fusion/Expr.mbi(598:13-617:13)
        i1 = 0

        e1 = int(len(fe1.inst))

        i2 = 0

        e2 = int(len(fe2.inst))

        # src/fusion/Expr.mbi(601:15-616:17)
        while ((i1 < e1) and (i2 < e2)):
          if   (fe1.inst[i1] < fe2.inst[i2]):
            bfix[bfix_i] = bfix1[i1]
            bfix_i += 1
            i1 += 1
          elif (fe1.inst[i1] > fe2.inst[i2]):
            bfix[bfix_i] = bfix2[i2]
            bfix_i += 1
            i2 += 1
          else:
            bfix[bfix_i] = (bfix1[i1] + bfix2[i2])
            bfix_i += 1
            i1 += 1
            i2 += 1
        # } @ src/fusion/Expr.mbi(598:13-617:13)
    return mosek.fusion.Expr(ptrb,( Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2 (fe1.x,fe2.x) ),subj,cof,bfix,fe1.shape,inst)
  @staticmethod
  def _matchargs_sub2_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(624:16-820:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub2(mosek.fusion.Expression,mosek.fusion.Expression)")
  def __sub2_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(ex1,ex2):
    fe1 = ( ex1._eval_() )

    fe2 = ( ex2._eval_() )

    if   (((ex1._model != None) and (ex2._model != None)) and (ex1._model != ex2._model)):
      raise mosek.fusion.LengthError("Operands belong to different models")
    if   (not ( fe1.shape._compare_Omosek_fusion_Set_2(fe2.shape) )):
      raise mosek.fusion.LengthError("Operand shapes do not match")
    rnnz = 0l

    rnelm = (long(len(fe1.cof)) + long(len(fe2.cof)))

    if   ((fe1.inst != None) or (fe2.inst != None)):
      rnnz = long(len(fe1.ptrb))
    else:
      i1 = 0

      e1 = int(len(fe1.inst))

      i2 = 0

      e2 = int(len(fe2.inst))

      # src/fusion/Expr.mbi(645:11-660:13)
      while ((i1 < e1) and (i2 < e2)):
        if   (fe1.inst[i1] < fe2.inst[i2]):
          rnnz += 1
          i1 += 1
        elif (fe1.inst[i1] > fe2.inst[i2]):
          rnnz += 1
          i2 += 1
        else:
          rnnz += 1
          i1 += 1
          i2 += 1
    ptrb = ([ 0l for _autovar_212 in xrange((rnnz + 1)) ])

    inst = None

    subj = ([ 0l for _autovar_213 in xrange(rnelm) ])

    cof = ([ 0.0 for _autovar_214 in xrange(rnelm) ])

    bfix = None

    if   ((fe1.inst == None) and (fe2.inst == None)):
      x2_offset = fe1.x.shape._size

      subj_i = 0l

      ptrb_i = 0

      # src/fusion/Expr.mbi(674:11-689:11)
      for i in xrange(0,(int(len(fe1.ptrb)) - 1)):
        # { @ src/fusion/Expr.mbi(675:11-689:11)
        # src/fusion/Expr.mbi(676:13-681:13)
        for k in xrange(fe1.ptrb[i],fe1.ptrb[(i + 1)]):
          # { @ src/fusion/Expr.mbi(677:13-681:13)
          subj[subj_i] = fe1.subj[k]
          cof[subj_i] = fe1.cof[k]
          subj_i += 1
          # } @ src/fusion/Expr.mbi(677:13-681:13)
        # src/fusion/Expr.mbi(682:13-687:13)
        for k in xrange(fe2.ptrb[i],fe2.ptrb[(i + 1)]):
          # { @ src/fusion/Expr.mbi(683:13-687:13)
          subj[subj_i] = (fe2.subj[k] + x2_offset)
          cof[subj_i] = (- fe2.cof[k])
          subj_i += 1
          # } @ src/fusion/Expr.mbi(683:13-687:13)
        ptrb[(i + 1)] = subj_i
        # } @ src/fusion/Expr.mbi(675:11-689:11)
    else:
      inst = ([ 0l for _autovar_215 in xrange(rnnz) ])
      x2_offset = fe1.x.shape._size

      subj_i = 0l

      ptrb_i = 0

      i1 = 0

      e1 = int(len(fe1.inst))

      i2 = 0

      e2 = int(len(fe2.inst))

      inst1 = fe1.inst

      inst2 = fe2.inst

      if   (inst1 == None):
        inst1 = ( Utils.Tools._range_L (long(len(fe2.inst))) )
      if   (inst2 == None):
        inst2 = ( Utils.Tools._range_L (long(len(fe1.inst))) )
      # src/fusion/Expr.mbi(705:11-750:13)
      while ((i1 < e1) and (i2 < e2)):
        if   (inst1[i1] < inst2[i2]):
          # src/fusion/Expr.mbi(708:15-713:15)
          for k in xrange(fe1.ptrb[i1],fe1.ptrb[(i1 + 1)]):
            # { @ src/fusion/Expr.mbi(709:15-713:15)
            subj[subj_i] = fe1.subj[k]
            cof[subj_i] = fe1.cof[k]
            subj_i += 1
            # } @ src/fusion/Expr.mbi(709:15-713:15)
          ptrb[(ptrb_i + 1)] = subj_i
          inst[ptrb_i] = inst1[i1]
          ptrb_i += 1
          i1 += 1
        elif (inst1[i1] > inst2[i2]):
          # src/fusion/Expr.mbi(721:15-726:15)
          for k in xrange(fe2.ptrb[i2],fe2.ptrb[(i2 + 1)]):
            # { @ src/fusion/Expr.mbi(722:15-726:15)
            subj[subj_i] = (fe2.subj[k] + x2_offset)
            cof[subj_i] = (- fe2.cof[k])
            subj_i += 1
            # } @ src/fusion/Expr.mbi(722:15-726:15)
          ptrb[(ptrb_i + 1)] = subj_i
          inst[ptrb_i] = inst2[i2]
          ptrb_i += 1
          i2 += 1
        else:
          # src/fusion/Expr.mbi(734:15-739:15)
          for k in xrange(fe1.ptrb[i1],fe1.ptrb[(i1 + 1)]):
            # { @ src/fusion/Expr.mbi(735:15-739:15)
            subj[subj_i] = fe1.subj[k]
            cof[subj_i] = fe1.cof[k]
            subj_i += 1
            # } @ src/fusion/Expr.mbi(735:15-739:15)
          # src/fusion/Expr.mbi(740:15-745:15)
          for k in xrange(fe2.ptrb[i1],fe2.ptrb[(i2 + 1)]):
            # { @ src/fusion/Expr.mbi(741:15-745:15)
            subj[subj_i] = (fe2.subj[k] + x2_offset)
            cof[subj_i] = (- fe2.cof[k])
            subj_i += 1
            # } @ src/fusion/Expr.mbi(741:15-745:15)
          ptrb[(ptrb_i + 1)] = subj_i
          inst[ptrb_i] = inst1[i1]
          ptrb_i += 1
          i1 += 1
          i2 += 1
      if   (int(len(inst)) == fe1.shape._size):
        inst = None
    if   ((fe1.bfix != None) or (fe2.bfix != None)):
      if   ((((fe1.inst == None) and (fe2.inst == None)) and (fe1.bfix != None)) and (fe2.bfix != None)):
        bfix = ([ 0.0 for _autovar_216 in xrange(rnnz) ])
        # src/fusion/Expr.mbi(763:13-71)
        for i in xrange(0l,rnnz):
          bfix[i] = (fe1.bfix[i] - fe2.bfix[i])
      elif ((fe1.inst == None) and (fe1.bfix != None)):
        bfix = ( Utils.Tools._arraycopy__3F (fe1.bfix) )
        if   (fe2.bfix != None):
          # src/fusion/Expr.mbi(771:15-772:68)
          for i in xrange(0,int(len(fe2.bfix))):
            bfix[fe2.inst[i]] = (bfix[fe2.inst[i]] - fe2.bfix[i])
      elif ((fe2.inst == None) and (fe2.bfix != None)):
        bfix = ([ 0.0 for _autovar_217 in xrange(rnnz) ])
        # src/fusion/Expr.mbi(779:13-59)
        for i in xrange(0l,rnnz):
          bfix[i] = (- fe2.bfix[i])
        if   (fe1.bfix != None):
          # src/fusion/Expr.mbi(783:15-784:68)
          for i in xrange(0,int(len(fe1.bfix))):
            bfix[fe1.inst[i]] = (bfix[fe1.inst[i]] + fe1.bfix[i])
      else:
        bfix = ([ 0.0 for _autovar_218 in xrange(rnnz) ])
        bfix1 = fe1.bfix

        bfix2 = fe2.bfix

        if   (bfix1 == None):
          bfix1 = ([ 0.0 for _autovar_219 in xrange((int(len(fe1.ptrb)) - 1)) ])
        if   (bfix2 == None):
          bfix2 = ([ 0.0 for _autovar_220 in xrange((int(len(fe2.ptrb)) - 1)) ])
        bfix_i = 0

        # { @ src/fusion/Expr.mbi(797:13-816:13)
        i1 = 0

        e1 = int(len(fe1.inst))

        i2 = 0

        e2 = int(len(fe2.inst))

        # src/fusion/Expr.mbi(800:15-815:17)
        while ((i1 < e1) and (i2 < e2)):
          if   (fe1.inst[i1] < fe2.inst[i2]):
            bfix[bfix_i] = bfix1[i1]
            bfix_i += 1
            i1 += 1
          elif (fe1.inst[i1] > fe2.inst[i2]):
            bfix[bfix_i] = (- bfix2[i2])
            bfix_i += 1
            i2 += 1
          else:
            bfix[bfix_i] = (bfix1[i1] - bfix2[i2])
            bfix_i += 1
            i1 += 1
            i2 += 1
        # } @ src/fusion/Expr.mbi(797:13-816:13)
    return mosek.fusion.Expr(ptrb,( Variable._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2 (fe1.x,fe2.x) ),subj,cof,bfix,fe1.shape,inst)
  @staticmethod
  def _matchargs_addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if not isinstance(args[2],bool): return False
    return True
  # origin: src/fusion/Expr.mbi(824:16-1208:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("addsub_op(mosek.fusion.Expression,mosek.fusion.Expression,bool)")
  def __addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B(lhs_,rhs_,plus):
    if   (((lhs_._model != None) and (rhs_._model != None)) and (lhs_._model != rhs_._model)):
      raise mosek.fusion.LengthError("Operands belong to different models")
    if   ((lhs_._shape != None) or (rhs_._shape != None)):
      if   ((rhs_._shape == None) and (( lhs_._shape._realnd_() ) != 1)):
        raise mosek.fusion.LengthError("Operand shapes do not match")
      elif ((lhs_._shape == None) and (( rhs_._shape._realnd_() ) != 1)):
        raise mosek.fusion.LengthError("Operand shapes do not match")
      elif (not ( lhs_._shape._compare_Omosek_fusion_Set_2(rhs_._shape) )):
        raise mosek.fusion.LengthError("Operand shapes do not match")
    elif (( lhs_._size_() ) != ( rhs_._size_() )):
      raise mosek.fusion.LengthError("Operand dimensions do not match")
    lhs = ( lhs_._eval_() )

    rhs = ( rhs_._eval_() )


    if   (lhs.inst == None):
      num = (int(len(lhs.ptrb)) - 1)
    elif (rhs.inst == None):
      num = (int(len(rhs.ptrb)) - 1)
    else:
      num = 0
      i0 = 0

      i1 = 0

      # src/fusion/Expr.mbi(860:11-865:11)
      while ((i0 < int(len(lhs.inst))) and (i1 < int(len(rhs.inst)))):
        if   (lhs.inst[i0] < rhs.inst[i1]):
          i0 += 1
        elif (lhs.inst[i0] > rhs.inst[i1]):
          i1 += 1
        else:
          i0 += 1
          i1 += 1
        num += 1
      num = ((num + (int(len(lhs.inst)) - i0)) + (int(len(rhs.inst)) - i1))
    nnz = 0l

    if   (lhs.cof != None):
      nnz = (nnz + long(len(lhs.cof)))
    if   (rhs.cof != None):
      nnz = (nnz + long(len(rhs.cof)))
    subj = ([ 0l for _autovar_221 in xrange(nnz) ])

    cof = ([ 0.0 for _autovar_222 in xrange(nnz) ])

    ptrb = ([ 0l for _autovar_223 in xrange((num + 1)) ])

    bfix = None

    x = ( Expr.__stack_1x_1vars_Omosek_fusion_Variable_2Omosek_fusion_Variable_2 (lhs.x,rhs.x) )

    inst = None

    rhsnvar = 0l

    lhsnvar = 0l

    if   (lhs.x != None):
      lhsnvar = ( lhs.x._size_() )
    if   (rhs.x != None):
      rhsnvar = ( rhs.x._size_() )
    if   ((lhs.inst == None) or (rhs.inst == None)):
      if   (lhs.inst == None):
        # src/fusion/Expr.mbi(895:13-898:13)
        i = 0

        while (i < num):
          ptrb[i] = (lhs.ptrb[(i + 1)] - lhs.ptrb[i])
          i += 1
      else:
        # src/fusion/Expr.mbi(902:13-905:13)
        i = 0

        while (i < int(len(lhs.inst))):
          ptrb[lhs.inst[i]] = (lhs.ptrb[(i + 1)] - lhs.ptrb[i])
          i += 1
      if   (rhs.inst == None):
        # src/fusion/Expr.mbi(910:13-913:13)
        i = 0

        while (i < num):
          ptrb[i] = ((ptrb[i] + rhs.ptrb[(i + 1)]) - rhs.ptrb[i])
          i += 1
      else:
        # src/fusion/Expr.mbi(917:13-920:13)
        i = 0

        while (i < int(len(rhs.inst))):
          ptrb[rhs.inst[i]] = ((ptrb[rhs.inst[i]] + rhs.ptrb[(i + 1)]) - rhs.ptrb[i])
          i += 1
    else:
      i0 = 0

      i1 = 0

      i = 0

      # src/fusion/Expr.mbi(927:11-936:11)
      while ((i0 < int(len(lhs.inst))) and (i1 < int(len(rhs.inst)))):
        if   (lhs.inst[i0] < rhs.inst[i1]):
          ptrb[i] = (lhs.ptrb[(i0 + 1)] - lhs.ptrb[i0])
          i0 += 1
        elif (lhs.inst[i0] > rhs.inst[i1]):
          ptrb[i] = (rhs.ptrb[(i1 + 1)] - rhs.ptrb[i1])
          i1 += 1
        else:
          ptrb[i] = (((lhs.ptrb[(i0 + 1)] - lhs.ptrb[i0]) + rhs.ptrb[(i1 + 1)]) - rhs.ptrb[i1])
          i0 += 1
          i1 += 1
        i += 1
      # src/fusion/Expr.mbi(937:11-940:11)
      while (i0 < int(len(lhs.inst))):
        ptrb[i] = (lhs.ptrb[(i0 + 1)] - lhs.ptrb[i0])
        i0 += 1
        i += 1
      # src/fusion/Expr.mbi(942:11-945:11)
      while (i1 < int(len(rhs.inst))):
        ptrb[i] = (rhs.ptrb[(i1 + 1)] - rhs.ptrb[i0])
        i1 += 1
        i += 1
    # { @ src/fusion/Expr.mbi(949:9-957:9)
    tmp = ptrb[0]

    ptrb[0] = 0l
    # src/fusion/Expr.mbi(951:11-956:11)
    i = 0

    while (i < num):
      tmp2 = ptrb[(i + 1)]

      ptrb[(i + 1)] = (ptrb[i] + tmp)
      tmp = tmp2
      i += 1
    # } @ src/fusion/Expr.mbi(949:9-957:9)
    if   ((lhs.bfix != None) or (rhs.bfix != None)):
      bfix = ([ 0.0 for _autovar_224 in xrange((int(len(ptrb)) - 1)) ])
    if   ((lhs.inst != None) and (rhs.inst != None)):
      inst = ([ 0l for _autovar_225 in xrange(num) ])
      i0 = 0

      l0 = int(len(lhs.inst))

      i1 = 0

      l1 = int(len(rhs.inst))


      if   (lhs.x != None):
        xoffset = lhs.x.shape._size
      else:
        xoffset = 0l
      # src/fusion/Expr.mbi(984:11-1023:11)
      i = 0

      while (i < num):
        offset = ptrb[i]

        if   ((i1 >= l1) or ((i0 < l0) and (lhs.inst[i0] < rhs.inst[i1]))):
          n = (lhs.ptrb[(i0 + 1)] - lhs.ptrb[i0])

          inst[i] = lhs.inst[i0]
          ( Utils.Tools._arraycopy__3LL_3LLL (lhs.subj,lhs.ptrb[i0],subj,offset,n) )
          ( Utils.Tools._arraycopy__3FL_3FLL (lhs.cof,lhs.ptrb[i0],cof,offset,n) )
          i0 += 1
        elif ((i0 >= l0) or (lhs.inst[i0] > rhs.inst[i1])):
          n = (rhs.ptrb[(i1 + 1)] - rhs.ptrb[i1])

          inst[i] = rhs.inst[i1]
          ( Utils.Tools._arraycopy__3LL_3LLL (lhs.subj,lhs.ptrb[i0],subj,offset,n) )
          # src/fusion/Expr.mbi(1001:15-88)
          j = 0

          while (j < n):
            subj[(offset + j)] = (subj[(offset + j)] + xoffset)
            j += 1
          ( Utils.Tools._arraycopy__3FL_3FLL (rhs.cof,rhs.ptrb[i1],cof,offset,n) )
          i1 += 1
        else:
          n = (lhs.ptrb[(i0 + 1)] - lhs.ptrb[i0])

          n2 = (rhs.ptrb[(i1 + 1)] - rhs.ptrb[i1])

          inst[i] = lhs.inst[i0]
          ( Utils.Tools._arraycopy__3LL_3LLL (lhs.subj,lhs.ptrb[i0],subj,offset,n) )
          ( Utils.Tools._arraycopy__3LL_3LLL (rhs.subj,rhs.ptrb[i1],subj,(offset + n),n2) )
          ( Utils.Tools._arraycopy__3FL_3FLL (lhs.cof,lhs.ptrb[i0],cof,offset,n) )
          ( Utils.Tools._arraycopy__3FL_3FLL (rhs.cof,rhs.ptrb[i1],cof,(offset + n),n2) )
          # src/fusion/Expr.mbi(1015:15-85)
          for j in xrange(0l,n2):
            # { @ src/fusion/Expr.mbi(1015:36-85)
            subj[((offset + n) + j)] = (subj[((offset + n) + j)] + xoffset)
            # } @ src/fusion/Expr.mbi(1015:36-85)
          if   (not plus):
            # src/fusion/Expr.mbi(1019:17-77)
            for j in xrange(0l,n2):
              # { @ src/fusion/Expr.mbi(1019:38-77)
              cof[((offset + n) + j)] = (- cof[((offset + n) + j)])
              # } @ src/fusion/Expr.mbi(1019:38-77)
          i1 += 1
          i0 += 1
        i += 1
      if   (lhs.bfix != None):
        i0 = 0
        i1 = 0
        # src/fusion/Expr.mbi(1028:13-1033:13)
        i = 0

        while (i < num):
          if   ((i1 >= l1) or ((i0 < l0) and (lhs.inst[i0] < rhs.inst[i1]))):
            bfix[i] = lhs.bfix[i0]
            i0 += 1
          elif ((i0 >= l0) or (lhs.inst[i0] > rhs.inst[i1])):
            i1 += 1
          else:
            bfix[i] = lhs.bfix[i0]
            i1 += 1
            i0 += 1
          i += 1
      if   (rhs.bfix != None):
        i0 = 0
        i1 = 0
        if   plus:
          # src/fusion/Expr.mbi(1040:15-1045:15)
          i = 0

          while (i < num):
            if   ((i1 >= l1) or ((i0 < l0) and (lhs.inst[i0] < rhs.inst[i1]))):
              i0 += 1
            elif ((i0 >= l0) or (lhs.inst[i0] > rhs.inst[i1])):
              bfix[i] = rhs.bfix[i1]
              i1 += 1
            else:
              bfix[i] = (bfix[i] + rhs.bfix[i1])
              i1 += 1
              i0 += 1
            i += 1
        else:
          # src/fusion/Expr.mbi(1049:15-1054:15)
          i = 0

          while (i < num):
            if   ((i1 >= l1) or ((i0 < l0) and (lhs.inst[i0] < rhs.inst[i1]))):
              i0 += 1
            elif ((i0 >= l0) or (lhs.inst[i0] > rhs.inst[i1])):
              bfix[i] = (- rhs.bfix[i1])
              i1 += 1
            else:
              bfix[i] = (bfix[i] - rhs.bfix[i1])
              i1 += 1
              i0 += 1
            i += 1
    else:
      if   (lhs.inst == None):
        # src/fusion/Expr.mbi(1063:13-1070:13)
        i = 0

        while (i < num):
          n = (lhs.ptrb[(i + 1)] - lhs.ptrb[i])

          offset = ptrb[i]

          ( Utils.Tools._arraycopy__3LL_3LLL (lhs.subj,lhs.ptrb[i],subj,offset,n) )
          ( Utils.Tools._arraycopy__3FL_3FLL (lhs.cof,lhs.ptrb[i],cof,offset,n) )
          ptrb[i] = (offset + n)
          i += 1
        if   (lhs.bfix != None):
          ( Utils.Tools._arraycopy__3FI_3FII (lhs.bfix,0,bfix,0,int(len(bfix))) )
      else:
        # src/fusion/Expr.mbi(1079:13-1088:13)
        i = 0

        while (i < int(len(lhs.inst))):
          n = (lhs.ptrb[(i + 1)] - lhs.ptrb[i])

          tidx = lhs.inst[i]

          offset = ptrb[tidx]

          ( Utils.Tools._arraycopy__3LL_3LLL (lhs.subj,lhs.ptrb[i],subj,offset,n) )
          ( Utils.Tools._arraycopy__3FL_3FLL (lhs.cof,lhs.ptrb[i],cof,offset,n) )
          ptrb[tidx] = (offset + n)
          i += 1
        if   (lhs.bfix != None):
          # src/fusion/Expr.mbi(1092:15-1095:15)
          i = 0

          while (i < int(len(lhs.inst))):
            bfix[lhs.inst[i]] = lhs.bfix[i]
            i += 1
      xoffset = 0l

      if   (lhs.x != None):
        xoffset = lhs.x.shape._size
      if   plus:
        if   (rhs.inst == None):
          # src/fusion/Expr.mbi(1106:15-1116:15)
          i = 0

          while (i < num):
            n = (rhs.ptrb[(i + 1)] - rhs.ptrb[i])

            offset = ptrb[i]

            ( Utils.Tools._arraycopy__3LL_3LLL (rhs.subj,rhs.ptrb[i],subj,offset,n) )
            ( Utils.Tools._arraycopy__3FL_3FLL (rhs.cof,rhs.ptrb[i],cof,offset,n) )
            # src/fusion/Expr.mbi(1113:17-91)
            j = 0l

            while (j < n):
              subj[(j + offset)] = (subj[(j + offset)] + xoffset)
              j += 1
            ptrb[i] = (offset + n)
            i += 1
          if   (rhs.bfix != None):
            # src/fusion/Expr.mbi(1120:17-1123:17)
            i = 0

            while (i < int(len(rhs.bfix))):
              bfix[i] = (bfix[i] + rhs.bfix[i])
              i += 1
        else:
          # src/fusion/Expr.mbi(1128:15-1139:15)
          i = 0

          while (i < int(len(rhs.inst))):
            n = (rhs.ptrb[(i + 1)] - rhs.ptrb[i])

            tidx = rhs.inst[i]

            offset = ptrb[tidx]

            ( Utils.Tools._arraycopy__3LL_3LLL (rhs.subj,rhs.ptrb[i],subj,offset,n) )
            ( Utils.Tools._arraycopy__3FL_3FLL (rhs.cof,rhs.ptrb[i],cof,offset,n) )
            # src/fusion/Expr.mbi(1136:17-91)
            j = 0l

            while (j < n):
              subj[(j + offset)] = (subj[(j + offset)] + xoffset)
              j += 1
            ptrb[tidx] = (offset + n)
            i += 1
          if   (rhs.bfix != None):
            # src/fusion/Expr.mbi(1142:17-1145:17)
            i = 0

            while (i < int(len(lhs.inst))):
              bfix[rhs.inst[i]] = (bfix[rhs.inst[i]] + lhs.bfix[i])
              i += 1
      else:
        if   (rhs.inst == None):
          # src/fusion/Expr.mbi(1153:15-1163:15)
          for i in xrange(0,num):
            # { @ src/fusion/Expr.mbi(1154:15-1163:15)
            n = (rhs.ptrb[(i + 1)] - rhs.ptrb[i])

            offset = ptrb[i]

            ( Utils.Tools._arraycopy__3LL_3LLL (rhs.subj,rhs.ptrb[i],subj,offset,n) )
            ( Utils.Tools._arraycopy__3FL_3FLL (rhs.cof,rhs.ptrb[i],cof,offset,n) )
            # src/fusion/Expr.mbi(1160:17-91)
            j = 0l

            while (j < n):
              subj[(j + offset)] = (subj[(j + offset)] + xoffset)
              j += 1
            # src/fusion/Expr.mbi(1161:17-81)
            j = 0l

            while (j < n):
              cof[(j + offset)] = (- cof[(j + offset)])
              j += 1
            ptrb[i] = (offset + n)
            # } @ src/fusion/Expr.mbi(1154:15-1163:15)
          if   (rhs.bfix != None):
            # src/fusion/Expr.mbi(1167:17-1168:50)
            for i in xrange(0,int(len(rhs.bfix))):
              bfix[i] = (bfix[i] - rhs.bfix[i])
        else:
          # src/fusion/Expr.mbi(1173:15-1185:15)
          for i in xrange(0,int(len(rhs.inst))):
            # { @ src/fusion/Expr.mbi(1174:15-1185:15)
            n = (rhs.ptrb[(i + 1)] - rhs.ptrb[i])

            tidx = rhs.inst[i]

            offset = ptrb[tidx]

            ( Utils.Tools._arraycopy__3LL_3LLL (rhs.subj,rhs.ptrb[i],subj,offset,n) )
            ( Utils.Tools._arraycopy__3FL_3FLL (rhs.cof,rhs.ptrb[i],cof,offset,n) )
            # src/fusion/Expr.mbi(1181:17-91)
            j = 0l

            while (j < n):
              subj[(j + offset)] = (subj[(j + offset)] + xoffset)
              j += 1
            # src/fusion/Expr.mbi(1182:17-81)
            j = 0l

            while (j < n):
              cof[(j + offset)] = (- cof[(j + offset)])
              j += 1
            ptrb[tidx] = (offset + n)
            # } @ src/fusion/Expr.mbi(1174:15-1185:15)
          if   (rhs.bfix != None):
            if   (lhs.bfix != None):
              # src/fusion/Expr.mbi(1190:19-1191:72)
              for i in xrange(0,int(len(rhs.inst))):
                bfix[rhs.inst[i]] = (bfix[rhs.inst[i]] - lhs.bfix[i])
            else:
              # src/fusion/Expr.mbi(1195:19-1196:58)
              for i in xrange(0,int(len(rhs.inst))):
                bfix[rhs.inst[i]] = bfix[rhs.inst[i]]
      # src/fusion/Expr.mbi(1202:11-64)
      i = num

      while (i > 0):
        ptrb[i] = ptrb[(i - 1)]
        i -= 1
      ptrb[0] = 0l
    shape = lhs.shape

    return mosek.fusion.Expr(ptrb,x,subj,cof,bfix,lhs.shape,inst)
  @staticmethod
  def _matchargs_add__3Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(1227:15-1260:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("add([mosek.fusion.Variable])")
  def _add__3Omosek_fusion_Variable_2(vs):
    if   (vs == None):
      raise Exception("Argument vs may not be null")
    if   ((int(len(vs)) > 0) and (vs[0] == None)):
      raise Exception("Argument vs may contain null")
    s = vs[0].shape

    nd = s.nd

    sz = s._size

    num = s._size

    # src/fusion/Expr.mbi(1236:9-1242:14)
    for i in xrange(1,int(len(vs))):
      if   (vs[i] == None):
        raise Exception("Argument vs may not contain null")
      elif (not ( s._compare_Omosek_fusion_Set_2(vs[i].shape) )):
        raise mosek.fusion.DimensionError("Mismatching operand dimensions")
    nnz = (sz * int(len(vs)))

    ptrb = ( Utils.Tools._range_LLL (0l,(nnz + long(len(vs))),long(len(vs))) )

    v = ( Variable._vstack__3Omosek_fusion_Variable_2 (vs) )

    subj = ([ 0l for _autovar_226 in xrange(nnz) ])

    cof = ( Utils.Tools._ones_I (int(nnz)) )

    N = long(len(vs))

    k = 0

    # src/fusion/Expr.mbi(1250:9-1257:9)
    i = 0l

    while (i < sz):
      # src/fusion/Expr.mbi(1252:11-1256:11)
      j = 0l

      while (j < N):
        subj[k] = (i + (j * sz))
        k += 1
        j += 1
      i += 1
    return mosek.fusion.Expr(ptrb,v,subj,cof,None,s,None,1)
  @staticmethod
  def _matchargs_add__3Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1274:15-1571:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("add([mosek.fusion.Expression])")
  def _add__3Omosek_fusion_Expression_2(exps):
    if   (int(len(exps)) == 0):
      return mosek.fusion.Expr(([ 0l]),None,([ 0l for _autovar_227 in xrange(0) ]),([ 0.0 for _autovar_228 in xrange(0) ]),None,( Set._make_I (0) ),([ 0l for _autovar_229 in xrange(0) ]),1)
    if   (exps == None):
      raise Exception("Argument exps may not be null")
    if   ((int(len(exps)) > 0) and (exps[0] == None)):
      raise Exception("Argument exps may not contain null")
    sz = ( exps[0]._size_() )

    shp = exps[0]._shape

    fe = ([ None for _autovar_230 in xrange(int(len(exps))) ])

    nnz = 0l

    full = False

    hasbfix = False

    xoffset = ([ 0l for _autovar_231 in xrange(int(len(exps))) ])

    vs = ([ None for _autovar_232 in xrange(int(len(exps))) ])

    # src/fusion/Expr.mbi(1294:9-1306:9)
    for i in xrange(0,int(len(exps))):
      # { @ src/fusion/Expr.mbi(1295:9-1306:9)
      if   (exps[i] == None):
        raise Exception("Argument exps may not contain null")
      fe[i] = ( exps[i]._eval_() )
      if   (not ( fe[i].shape._compare_Omosek_fusion_Set_2(fe[0].shape) )):
        raise mosek.fusion.DimensionError("Mismatching operand dimensions")
      vs[i] = ( Variable._flatten_Omosek_fusion_Variable_2 (fe[i].x) )
      if   (fe[i].bfix != None):
        hasbfix = True
      nnz = (nnz + fe[i].nnz)
      full = (full or (fe[i].inst == None))
      # } @ src/fusion/Expr.mbi(1295:9-1306:9)
    # src/fusion/Expr.mbi(1308:9-84)
    for i in xrange(1,int(len(exps))):
      # { @ src/fusion/Expr.mbi(1308:36-84)
      xoffset[i] = (xoffset[(i - 1)] + ( fe[(i - 1)].x._size_() ))
      # } @ src/fusion/Expr.mbi(1308:36-84)
    shape = None

    inst = None

    if   (exps[0]._shape != None):
      shape = exps[0]._shape
    else:
      shape = mosek.fusion.IntSet(int(sz))

    if   (not full):
      totallen = 0

      b = 0

      # src/fusion/Expr.mbi(1327:11-77)
      for i in xrange(0,int(len(fe))):
        # { @ src/fusion/Expr.mbi(1327:36-77)
        totallen = (totallen + int(len(fe[i].inst)))
        # } @ src/fusion/Expr.mbi(1327:36-77)
      tempinst = ([ 0l for _autovar_233 in xrange(totallen) ])

      # src/fusion/Expr.mbi(1329:11-1333:11)
      for i in xrange(0,int(len(fe))):
        # { @ src/fusion/Expr.mbi(1330:11-1333:11)
        ( Utils.Tools._arraycopy__3LI_3LII (fe[i].inst,0,tempinst,b,int(len(fe[i].inst))) )
        b = (b + int(len(fe[i].inst)))
        # } @ src/fusion/Expr.mbi(1330:11-1333:11)
      ( Utils.Tools._sort__3LII (tempinst,0,totallen) )
      num = 1
      # src/fusion/Expr.mbi(1337:11-84)
      for i in xrange(1,totallen):
        # { @ src/fusion/Expr.mbi(1337:38-84)
        if   (tempinst[(i - 1)] < tempinst[i]):
          num += 1
        # } @ src/fusion/Expr.mbi(1337:38-84)
      if   (num == shape._size):
        full = True
      else:
        inst = ([ 0l for _autovar_234 in xrange(num) ])
        inst[0] = tempinst[0]
        j = 0

        # src/fusion/Expr.mbi(1347:13-1354:13)
        for i in xrange(0,totallen):
          # { @ src/fusion/Expr.mbi(1348:13-1354:13)
          if   (inst[j] != tempinst[i]):
            j += 1
            inst[j] = tempinst[i]
          # } @ src/fusion/Expr.mbi(1348:13-1354:13)
    else:
      num = int(shape._size)
    ptr = ([ 0l for _autovar_235 in xrange((num + 1)) ])

    bfix = None

    if   hasbfix:
      bfix = ([ 0.0 for _autovar_236 in xrange(num) ])
    if   (inst == None):
      # src/fusion/Expr.mbi(1370:11-1387:11)
      i = 0

      while (i < int(len(fe))):
        e = fe[i]

        if   (e.inst != None):
          # src/fusion/Expr.mbi(1375:15-1378:15)
          j = 0l

          while (j < long(len(e.inst))):
            ptr[(e.inst[j] + 1l)] = ((ptr[(e.inst[j] + 1l)] + e.ptrb[(j + 1l)]) - e.ptrb[j])
            j += 1
        else:
          # src/fusion/Expr.mbi(1382:15-1385:15)
          j = 0

          while (j < (int(len(e.ptrb)) - 1)):
            ptr[(j + 1)] = ((ptr[(j + 1)] + e.ptrb[(j + 1)]) - e.ptrb[j])
            j += 1
        i += 1
    else:
      # src/fusion/Expr.mbi(1400:11-1415:11)
      i = 0

      while (i < int(len(fe))):
        jj = 0

        # src/fusion/Expr.mbi(1407:13-1414:13)
        j = 0

        while ((j < int(len(inst))) and (jj < int(len(fe[i].inst)))):
          if   (fe[i].inst[jj] == inst[j]):
            ptr[(j + 1)] = ((ptr[(j + 1)] + fe[i].ptrb[(jj + 1)]) - fe[i].ptrb[jj])
            jj += 1
          j += 1
        i += 1
    # src/fusion/Expr.mbi(1417:9-74)
    i = 1

    while (i < int(len(ptr))):
      ptr[i] = (ptr[i] + ptr[(i - 1)])
      i += 1
    if   (inst != None):
      pass
    subj = ([ 0l for _autovar_237 in xrange(nnz) ])

    cof = ([ 0.0 for _autovar_238 in xrange(nnz) ])

    if   (inst == None):
      # src/fusion/Expr.mbi(1437:11-1507:11)
      i = 0

      while (i < int(len(fe))):
        e = fe[i]

        if   (e.inst == None):
          # src/fusion/Expr.mbi(1448:15-1462:15)
          j = 0

          while (j < (int(len(e.ptrb)) - 1)):
            b = ptr[j]

            n = (e.ptrb[(j + 1)] - e.ptrb[j])

            ( Utils.Tools._arraycopy__3FL_3FLL (e.cof,e.ptrb[j],cof,b,n) )
            # src/fusion/Expr.mbi(1456:17-1460:17)
            k = 0l

            while (k < n):
              subj[(b + k)] = (e.subj[(e.ptrb[j] + k)] + xoffset[i])
              k += 1
            ptr[j] = (ptr[j] + n)
            j += 1
          if   (hasbfix and (e.bfix != None)):
            # src/fusion/Expr.mbi(1466:17-1469:17)
            j = 0

            while (j < int(len(e.inst))):
              bfix[j] = (bfix[j] + e.bfix[j])
              j += 1
        else:
          # src/fusion/Expr.mbi(1483:15-1496:15)
          j = 0

          while (j < int(len(e.inst))):
            idx = e.inst[j]

            n = (e.ptrb[(j + 1)] - e.ptrb[j])

            b = ptr[idx]

            ( Utils.Tools._arraycopy__3FL_3FLL (e.cof,e.ptrb[j],cof,ptr[idx],n) )
            # src/fusion/Expr.mbi(1489:17-1492:17)
            k = 0l

            while (k < n):
              subj[(b + k)] = (e.subj[(e.ptrb[j] + k)] + xoffset[i])
              k += 1
            ptr[idx] = (ptr[idx] + n)
            j += 1
          if   (hasbfix and (e.bfix != None)):
            # src/fusion/Expr.mbi(1500:17-1504:17)
            j = 0

            while (j < int(len(e.inst))):
              idx = e.inst[j]

              bfix[idx] = (bfix[idx] + e.bfix[j])
              j += 1
        i += 1
    else:
      # src/fusion/Expr.mbi(1513:11-1533:11)
      i = 0

      while (i < int(len(fe))):
        jj = 0

        # src/fusion/Expr.mbi(1516:13-1532:13)
        j = 0

        while ((j < int(len(inst))) and (jj < int(len(fe[i].inst)))):
          if   (fe[i].inst[jj] == inst[j]):
            b = fe[i].ptrb[jj]

            N = (fe[i].ptrb[(jj + 1)] - b)

            ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].cof,b,cof,ptr[j],N) )
            # src/fusion/Expr.mbi(1525:17-1528:17)
            k = 0

            while (k < N):
              subj[(ptr[j] + k)] = (fe[i].subj[(b + k)] + xoffset[i])
              k += 1
            ptr[j] = (ptr[j] + N)
            jj += 1
          j += 1
        i += 1
    # src/fusion/Expr.mbi(1565:9-60)
    i = num

    while (i > 0):
      ptr[i] = ptr[(i - 1)]
      i -= 1
    ptr[0] = 0l
    v = ( Variable._vstack__3Omosek_fusion_Variable_2 (vs) )

    return mosek.fusion.Expr(ptr,v,subj,cof,None,shape,inst,1)
  @staticmethod
  def _matchargs_add_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1580:15-1587:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Expression,mosek.fusion.Expression)")
  def _add_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(lhs,rhs):
    if   (lhs == None):
      raise Exception("Argument lhs may not be null")
    if   (rhs == None):
      raise Exception("Argument rhs may not be null")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (lhs,rhs,True) )
  @staticmethod
  def _matchargs_add_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(1595:15-1602:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Expression,mosek.fusion.Variable)")
  def _add_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(lhs,rhs):
    if   (lhs == None):
      raise Exception("Argument lhs may not be null")
    if   (rhs == None):
      raise Exception("Argument rhs may not be null")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (lhs,( rhs._asExpr_() ),True) )
  @staticmethod
  def _matchargs_add_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1609:15-1616:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Variable,mosek.fusion.Expression)")
  def _add_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(lhs,rhs):
    if   (lhs == None):
      raise Exception("Argument lhs may not be null")
    if   (rhs == None):
      raise Exception("Argument rhs may not be null")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( lhs._asExpr_() ),rhs,True) )
  @staticmethod
  def _matchargs_add_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(1623:15-1635:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Variable,mosek.fusion.Variable)")
  def _add_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(lhs,rhs):
    if   (lhs == None):
      raise Exception("Argument lhs may not be null")
    if   (rhs == None):
      raise Exception("Argument rhs may not be null")
    if   (not ( lhs.shape._compare_Omosek_fusion_Set_2(rhs.shape) )):
      raise mosek.fusion.DimensionError("Operands have mismatching number of dimensions.")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( lhs._asExpr_() ),( rhs._asExpr_() ),True) )
  @staticmethod
  def _matchargs_add__3FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(1644:15-1665:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add([float],mosek.fusion.Variable)")
  def _add__3FOmosek_fusion_Variable_2(lhs,rhs):
    if   (lhs == None):
      raise Exception("Argument lhs may not be null")
    if   (rhs == None):
      raise Exception("Argument rhs may not be null")
    if   (( rhs.shape._realnd_() ) != 1):
      raise mosek.fusion.DimensionError("Operands have mismatching number of dimensions.")
    elif (rhs.shape._size != long(len(lhs))):
      raise mosek.fusion.LengthError("Operands have mismatching lengths.")
    ptrb = ( Utils.Tools._range_LL (0l,(long(len(lhs)) + 1)) )

    subj = ( Utils.Tools._range_LL (0l,long(len(lhs))) )

    cof = ( Utils.Tools._ones_I (int(len(lhs))) )

    bfix = ( Utils.Tools._arraycopy__3F (lhs) )

    return mosek.fusion.Expr(ptrb,rhs,subj,cof,bfix,rhs.shape,None,1)
  @staticmethod
  def _matchargs_add_Omosek_fusion_Variable_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(1673:15-1680:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Variable,[float])")
  def _add_Omosek_fusion_Variable_2_3F(lhs,rhs):
    if   (lhs == None):
      raise Exception("Argument lhs may not be null")
    if   (rhs == None):
      raise Exception("Argument rhs may not be null")
    return ( Expr._add__3FOmosek_fusion_Variable_2 (rhs,lhs) )
  @staticmethod
  def _matchargs_add__3FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(1688:15-1695:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add([float],mosek.fusion.Expression)")
  def _add__3FOmosek_fusion_Expression_2(lhs,rhs):
    if   (lhs == None):
      raise Exception("Argument lhs may not be null")
    if   (rhs == None):
      raise Exception("Argument rhs may not be null")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( Expr._constTerm__3F (lhs) ),rhs,True) )
  @staticmethod
  def _matchargs_add_Omosek_fusion_Expression_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(1703:15-1710:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Expression,[float])")
  def _add_Omosek_fusion_Expression_2_3F(lhs,rhs):
    if   (lhs == None):
      raise Exception("Argument lhs may not be null")
    if   (rhs == None):
      raise Exception("Argument rhs may not be null")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (lhs,( Expr._constTerm__3F (rhs) ),True) )
  @staticmethod
  def _matchargs_add_Omosek_fusion_Expression_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(1718:15-1736:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Expression,float)")
  def _add_Omosek_fusion_Expression_2F(lhs,rhs):
    if   (lhs == None):
      raise Exception("Argument lhs may not be null")
    fe = ( lhs._eval_() )

    bfix = None

    if   (fe.bfix == None):
      bfix = ( Utils.Tools._makevector_FI (rhs,(int(len(fe.ptrb)) - 1)) )
    else:
      bfix = ( Utils.Tools._arraycopy__3F (fe.bfix) )
      # src/fusion/Expr.mbi(1732:11-70)
      i = 0

      while (i < int(len(bfix))):
        bfix[i] = (bfix[i] + rhs)
        i += 1
    return mosek.fusion.Expr(fe.ptrb,fe.x,fe.subj,fe.cof,bfix,fe.shape,fe.inst,1)
  @staticmethod
  def _matchargs_add_Omosek_fusion_Variable_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(1744:15-1755:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Variable,float)")
  def _add_Omosek_fusion_Variable_2F(lhs,rhs):
    if   (lhs == None):
      raise Exception("Argument lhs may not be null")
    n = lhs.shape._size

    return mosek.fusion.Expr(( Utils.Tools._range_LL (0l,(n + 1)) ),lhs,( Utils.Tools._range_LL (0l,n) ),( Utils.Tools._ones_I (int(n)) ),( Utils.Tools._makevector_FI (rhs,int(n)) ),lhs.shape,None,1)
  @staticmethod
  def _matchargs_add__3F_3F(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(1764:15-1783:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add([float],[float])")
  def _add__3F_3F(lhs,rhs):
    if   (lhs == None):
      raise Exception("Argument lhs may not be null")
    if   (rhs == None):
      raise Exception("Argument rhs may not be null")
    if   (int(len(lhs)) != int(len(rhs))):
      raise mosek.fusion.LengthError("Operand lengths do not match")
    r = ([ 0.0 for _autovar_239 in xrange(int(len(lhs))) ])

    # src/fusion/Expr.mbi(1774:9-57)
    for i in xrange(0,int(len(lhs))):
      r[i] = (lhs[i] + rhs[i])
    return mosek.fusion.Expr(( Utils.Tools._range_LL (0l,long(len(r))) ),None,([ 0l for _autovar_240 in xrange(0) ]),([ 0.0 for _autovar_241 in xrange(0) ]),r,mosek.fusion.IntSet(int(len(r))),None,1)
  @staticmethod
  def _matchargs_stack__3Omosek_fusion_Expression_2I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Expression): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Expr.mbi(1787:18-2062:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("stack([mosek.fusion.Expression],int)")
  def _stack__3Omosek_fusion_Expression_2I(exprs,dim):
    if   (int(len(exprs)) == 1):
      return exprs[0]
    if   (int(len(exprs)) == 0):
      return mosek.fusion.Expr(([ 0l]),None,([ 0l for _autovar_242 in xrange(0) ]),([ 0.0 for _autovar_243 in xrange(0) ]),None,( Set._make_I (0) ),([ 0l for _autovar_244 in xrange(0) ]),1)
    nd = (dim + 1)

    # src/fusion/Expr.mbi(1797:9-1802:14)
    for i in xrange(0,int(len(exprs))):
      if   (exprs[i]._shape.nd > nd):
        nd = exprs[i]._shape.nd
    fe = ([ None for _autovar_245 in xrange(int(len(exprs))) ])

    e0 = exprs[0]

    r_dims = ([ 0 for _autovar_246 in xrange(nd) ])

    is_dense = True

    has_bfix = False

    r = None

    if   (e0._shape.nd < dim):
      raise mosek.fusion.LengthError("Invalid stack dimension")
    numxs = 0

    # src/fusion/Expr.mbi(1812:9-1826:9)
    for i in xrange(0,int(len(exprs))):
      # { @ src/fusion/Expr.mbi(1813:9-1826:9)
      ei = exprs[i]

      # src/fusion/Expr.mbi(1817:11-1822:19)
      for j in xrange(0,ei._shape.nd):
        if   ((dim != j) and (( e0._shape._dim_I(j) ) != ( ei._shape._dim_I(j) ))):
          raise mosek.fusion.DimensionError("Mismatching dimensions")
      r_dims[dim] = (r_dims[dim] + ( ei._shape._dim_I(dim) ))
      fe[i] = ( exprs[i]._eval_() )
      is_dense = (is_dense and (fe[i].inst == None))
      has_bfix = (has_bfix or (fe[i].bfix != None))
      if   (fe[i].x != None):
        numxs += 1
      # } @ src/fusion/Expr.mbi(1813:9-1826:9)
    # src/fusion/Expr.mbi(1828:9-1833:14)
    for j in xrange(0,nd):
      if   (j != dim):
        r_dims[j] = ( e0._shape._dim_I(j) )
    r_shape = mosek.fusion.NDSet(r_dims)

    xs = ([ None for _autovar_247 in xrange(numxs) ])

    xofs = ([ 0l for _autovar_248 in xrange(int(len(exprs))) ])

    # { @ src/fusion/Expr.mbi(1836:9-1848:9)
    b = 0

    xb = 0l

    # src/fusion/Expr.mbi(1839:11-1847:11)
    for i in xrange(0,int(len(exprs))):
      # { @ src/fusion/Expr.mbi(1840:11-1847:11)
      xofs[i] = xb
      if   (fe[i].x != None):
        xs[b] = ( Variable._reshape_Omosek_fusion_Variable_2I (fe[i].x,int(( fe[i].x._size_() ))) )
        b += 1
        xb = (xb + ( fe[i].x._size_() ))
      # } @ src/fusion/Expr.mbi(1840:11-1847:11)
    # } @ src/fusion/Expr.mbi(1836:9-1848:9)
    nnz = fe[0].nnz

    nrows = (int(len(fe[0].ptrb)) - 1)

    bfix = None

    # src/fusion/Expr.mbi(1854:9-1858:9)
    for i in xrange(1,int(len(exprs))):
      # { @ src/fusion/Expr.mbi(1855:9-1858:9)
      nnz = (nnz + fe[i].nnz)
      nrows = ((nrows + int(len(fe[i].ptrb))) - 1)
      # } @ src/fusion/Expr.mbi(1855:9-1858:9)
    if   has_bfix:
      bfix = ([ 0.0 for _autovar_249 in xrange(nrows) ])
    if   (dim == 0):
      r_x = mosek.fusion.CompoundVariable(xs,0)

      ptrb = ([ 0l for _autovar_250 in xrange((nrows + 1)) ])

      subj = ([ 0l for _autovar_251 in xrange(nnz) ])

      cof = ([ 0.0 for _autovar_252 in xrange(nnz) ])

      inst = None

      if   (not is_dense):
        inst = ([ 0l for _autovar_253 in xrange(nrows) ])
      ptr = 0l

      ofs = 0l

      cofs = 0l

      # src/fusion/Expr.mbi(1880:11-1910:11)
      for i in xrange(0,int(len(fe))):
        # { @ src/fusion/Expr.mbi(1881:11-1910:11)
        ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].cof,0l,cof,ofs,fe[i].nnz) )
        if   (fe[i].bfix != None):
          ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].bfix,0l,bfix,ptr,long(len(fe[i].bfix))) )
        # src/fusion/Expr.mbi(1885:13-1886:52)
        for j in xrange(0,(int(len(fe[i].ptrb)) - 1)):
          ptrb[((ptr + j) + 1)] = (fe[i].ptrb[(j + 1)] + ofs)
        # src/fusion/Expr.mbi(1887:13-1888:52)
        for j in xrange(0l,fe[i].nnz):
          subj[(ofs + j)] = (xofs[i] + fe[i].subj[j])
        if   (not is_dense):
          if   (fe[i].inst == None):
            # src/fusion/Expr.mbi(1894:17-1895:41)
            for j in xrange(0,(int(len(fe[i].ptrb)) - 1)):
              inst[(ptr + j)] = (cofs + j)
            ptr = ((ptr + int(len(fe[i].ptrb))) - 1)
          else:
            # src/fusion/Expr.mbi(1900:17-1901:53)
            for j in xrange(0,int(len(fe[i].inst))):
              inst[(ptr + j)] = (cofs + fe[i].inst[j])
            ptr = (ptr + int(len(fe[i].inst)))
        else:
          ptr = ((ptr + int(len(fe[i].ptrb))) - 1)
        cofs = (cofs + fe[i].shape._size)
        ofs = (ofs + fe[i].nnz)
        # } @ src/fusion/Expr.mbi(1881:11-1910:11)
      r = mosek.fusion.Expr(ptrb,r_x,subj,cof,bfix,r_shape,inst)
    else:
      r_x = mosek.fusion.CompoundVariable(xs,0)

      ptrb = ([ 0l for _autovar_254 in xrange((nrows + 1)) ])

      subj = ([ 0l for _autovar_255 in xrange(nnz) ])

      cof = ([ 0.0 for _autovar_256 in xrange(nnz) ])

      inst = None

      ptr = 0l

      ofs = 0l

      cofs = 0l

      npasses = 1

      # src/fusion/Expr.mbi(1939:11-1940:42)
      for i in xrange(0,dim):
        npasses = (npasses * r_dims[i])
      chunksize = 1

      # src/fusion/Expr.mbi(1942:11-1943:46)
      for i in xrange((dim + 1),int(len(r_dims))):
        chunksize = (chunksize * r_dims[i])
      basechunksize = chunksize

      chunksize = (chunksize * r_dims[dim])
      echunk = ([ 0 for _autovar_257 in xrange(int(len(fe))) ])

      # src/fusion/Expr.mbi(1949:11-1950:61)
      for i in xrange(0,int(len(fe))):
        echunk[i] = (basechunksize * ( fe[i].shape._dim_I(dim) ))
      eptr = ([ 0l for _autovar_258 in xrange(int(len(fe))) ])

      if   is_dense:
        # src/fusion/Expr.mbi(1960:13-1983:13)
        for k in xrange(0,npasses):
          # { @ src/fusion/Expr.mbi(1961:13-1983:13)
          # src/fusion/Expr.mbi(1962:15-1982:15)
          for i in xrange(0,int(len(fe))):
            # { @ src/fusion/Expr.mbi(1963:15-1982:15)
            block_nnz = (fe[i].ptrb[(eptr[i] + echunk[i])] - fe[i].ptrb[eptr[i]])

            ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].cof,fe[i].ptrb[eptr[i]],cof,ofs,block_nnz) )
            if   (fe[i].bfix != None):
              ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].bfix,eptr[i],bfix,ptr,long(echunk[i])) )
            eptrb = fe[i].ptrb[eptr[i]]

            # src/fusion/Expr.mbi(1973:17-1974:62)
            for j in xrange(0l,block_nnz):
              subj[(ofs + j)] = (fe[i].subj[(eptrb + j)] + xofs[i])
            # src/fusion/Expr.mbi(1975:17-1976:98)
            for j in xrange(0,echunk[i]):
              ptrb[((ptr + j) + 1)] = ((fe[i].ptrb[((eptr[i] + j) + 1)] - fe[i].ptrb[(eptr[i] + j)]) + ptrb[(ptr + j)])
            ofs = (ofs + block_nnz)
            ptr = (ptr + echunk[i])
            cofs = (cofs + fe[i].shape._size)
            eptr[i] = (eptr[i] + echunk[i])
            # } @ src/fusion/Expr.mbi(1963:15-1982:15)
          # } @ src/fusion/Expr.mbi(1961:13-1983:13)
        r = mosek.fusion.Expr(ptrb,r_x,subj,cof,bfix,r_shape,inst)
      else:
        ceofs = ([ 0l for _autovar_259 in xrange(int(len(fe))) ])

        # src/fusion/Expr.mbi(1995:13-2055:13)
        for k in xrange(0,npasses):
          # { @ src/fusion/Expr.mbi(1996:13-2055:13)
          # src/fusion/Expr.mbi(1997:15-2054:15)
          for i in xrange(0,int(len(fe))):
            # { @ src/fusion/Expr.mbi(1998:15-2054:15)
            if   (fe[i].inst == None):
              block_nnz = (fe[i].ptrb[(eptr[i] + echunk[i])] - fe[i].ptrb[eptr[i]])

              ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].cof,fe[i].ptrb[eptr[i]],cof,ofs,block_nnz) )
              if   (fe[i].bfix != None):
                ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].bfix,eptr[i],bfix,ptr,long(echunk[i])) )
              eptrb = fe[i].ptrb[eptr[i]]

              # src/fusion/Expr.mbi(2010:19-2011:64)
              for j in xrange(0l,block_nnz):
                subj[(ofs + j)] = (fe[i].subj[(eptrb + j)] + xofs[i])
              # src/fusion/Expr.mbi(2012:19-2013:68)
              for j in xrange(0,echunk[i]):
                ptrb[(ptr + j)] = (fe[i].ptrb[(eptr[i] + j)] + ptrb[ptr])
              # src/fusion/Expr.mbi(2015:19-2016:43)
              for j in xrange(0,echunk[i]):
                inst[(ptr + j)] = (cofs + j)
              ofs = (ofs + block_nnz)
              ptr = (ptr + echunk[i])
              cofs = (cofs + fe[i].shape._size)
              eptr[i] = (eptr[i] + echunk[i])
            else:
              block_rows = 0l

              # { @ src/fusion/Expr.mbi(2026:19-2030:19)
              j = 0l

              # src/fusion/Expr.mbi(2028:21-77)
              while (fe[i].inst[(eptr[i] + j)] < (ceofs[i] + echunk[i])):
                j += 1
              block_rows = j
              # } @ src/fusion/Expr.mbi(2026:19-2030:19)
              block_nnz = (fe[i].ptrb[(eptr[i] + block_rows)] - fe[i].ptrb[eptr[i]])

              ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].cof,fe[i].ptrb[eptr[i]],cof,ofs,block_nnz) )
              if   (fe[i].bfix != None):
                ( Utils.Tools._arraycopy__3FL_3FLL (fe[i].bfix,eptr[i],bfix,ptr,block_rows) )
              eptrb = fe[i].ptrb[eptr[i]]

              # src/fusion/Expr.mbi(2041:19-2042:64)
              for j in xrange(0l,block_nnz):
                subj[(ofs + j)] = (fe[i].subj[(eptrb + j)] + xofs[i])
              # src/fusion/Expr.mbi(2043:19-2044:98)
              for j in xrange(0l,block_rows):
                ptrb[((ptr + j) + 1)] = ((fe[i].ptrb[((eptr[i] + j) + 1)] - fe[i].ptrb[(eptr[i] + j)]) + ptrb[(ptr + j)])
              # src/fusion/Expr.mbi(2045:19-2046:53)
              for j in xrange(0l,block_rows):
                inst[(ptr + j)] = (fe[i].inst[j] + cofs)
              ofs = (ofs + block_nnz)
              ptr = (ptr + block_rows)
              cofs = (cofs + fe[i].shape._size)
              eptr[i] = (eptr[i] + block_rows)
              ceofs[i] = (ceofs[i] + echunk[i])
            # } @ src/fusion/Expr.mbi(1998:15-2054:15)
          # } @ src/fusion/Expr.mbi(1996:13-2055:13)
        r = mosek.fusion.Expr(ptrb,r_x,subj,cof,bfix,r_shape,inst)
    return r
  @staticmethod
  def _matchargs_hstack__3Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2087:15-2094:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("hstack([mosek.fusion.Expression])")
  def _hstack__3Omosek_fusion_Expression_2(exprs):
    if   (exprs == None):
      raise Exception("Argument exprs may not be null")
    # src/fusion/Expr.mbi(2090:9-2094:17)
    for i in xrange(0,int(len(exprs))):
      if   (exprs[i] == None):
        raise Exception("Arguments for hstack may not be null")
    return ( Expr._stack__3Omosek_fusion_Expression_2I (exprs,1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2120:15-2119:112)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,mosek.fusion.Expression)")
  def _hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,e2]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2121:15-2120:123)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,float)")
  def _hstack_Omosek_fusion_Expression_2F(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( Expr._constTerm_F (e2) )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2122:15-2121:121)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,mosek.fusion.Variable)")
  def _hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( e2._asExpr_() )]),1) )
  @staticmethod
  def _matchargs_hstack_FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2124:15-2123:130)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(float,mosek.fusion.Variable)")
  def _hstack_FOmosek_fusion_Variable_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),( e2._asExpr_() )]),1) )
  @staticmethod
  def _matchargs_hstack_FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2125:15-2124:121)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(float,mosek.fusion.Expression)")
  def _hstack_FOmosek_fusion_Expression_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),e2]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2126:15-2125:130)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,float)")
  def _hstack_Omosek_fusion_Variable_2F(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( Expr._constTerm_F (e2) )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2127:15-2126:128)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,mosek.fusion.Variable)")
  def _hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( e2._asExpr_() )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2128:15-2127:119)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,mosek.fusion.Expression)")
  def _hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),e2]),1) )
  @staticmethod
  def _matchargs_hstack_FFOmosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if not isinstance(args[1],float): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2132:15-2131:163)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(float,float,mosek.fusion.Variable)")
  def _hstack_FFOmosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),( Expr._constTerm_F (e2) ),( e3._asExpr_() )]),1) )
  @staticmethod
  def _matchargs_hstack_FFOmosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if not isinstance(args[1],float): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2133:15-2132:163)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(float,float,mosek.fusion.Expression)")
  def _hstack_FFOmosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),( Expr._constTerm_F (e2) ),e3]),1) )
  @staticmethod
  def _matchargs_hstack_FOmosek_fusion_Variable_2F(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2134:15-2133:163)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(float,mosek.fusion.Variable,float)")
  def _hstack_FOmosek_fusion_Variable_2F(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),( e2._asExpr_() ),( Expr._constTerm_F (e3) )]),1) )
  @staticmethod
  def _matchargs_hstack_FOmosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2135:15-2134:163)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(float,mosek.fusion.Variable,mosek.fusion.Variable)")
  def _hstack_FOmosek_fusion_Variable_2Omosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),( e2._asExpr_() ),( e3._asExpr_() )]),1) )
  @staticmethod
  def _matchargs_hstack_FOmosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2136:15-2135:163)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(float,mosek.fusion.Variable,mosek.fusion.Expression)")
  def _hstack_FOmosek_fusion_Variable_2Omosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),( e2._asExpr_() ),e3]),1) )
  @staticmethod
  def _matchargs_hstack_FOmosek_fusion_Expression_2F(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2137:15-2136:163)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(float,mosek.fusion.Expression,float)")
  def _hstack_FOmosek_fusion_Expression_2F(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),e2,( Expr._constTerm_F (e3) )]),1) )
  @staticmethod
  def _matchargs_hstack_FOmosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2138:15-2137:163)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(float,mosek.fusion.Expression,mosek.fusion.Variable)")
  def _hstack_FOmosek_fusion_Expression_2Omosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),e2,( e3._asExpr_() )]),1) )
  @staticmethod
  def _matchargs_hstack_FOmosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2139:15-2138:163)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(float,mosek.fusion.Expression,mosek.fusion.Expression)")
  def _hstack_FOmosek_fusion_Expression_2Omosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),e2,e3]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2FF(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2141:15-2140:161)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,float,float)")
  def _hstack_Omosek_fusion_Variable_2FF(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( Expr._constTerm_F (e2) ),( Expr._constTerm_F (e3) )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2FOmosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2142:15-2141:161)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,float,mosek.fusion.Variable)")
  def _hstack_Omosek_fusion_Variable_2FOmosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( Expr._constTerm_F (e2) ),( e3._asExpr_() )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2FOmosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2143:15-2142:161)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,float,mosek.fusion.Expression)")
  def _hstack_Omosek_fusion_Variable_2FOmosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( Expr._constTerm_F (e2) ),e3]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2F(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2144:15-2143:161)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,mosek.fusion.Variable,float)")
  def _hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2F(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( e2._asExpr_() ),( Expr._constTerm_F (e3) )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2145:15-2144:161)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)")
  def _hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( e2._asExpr_() ),( e3._asExpr_() )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2146:15-2145:161)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression)")
  def _hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( e2._asExpr_() ),e3]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2F(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2147:15-2146:161)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,mosek.fusion.Expression,float)")
  def _hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2F(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),e2,( Expr._constTerm_F (e3) )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2148:15-2147:161)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable)")
  def _hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),e2,( e3._asExpr_() )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2149:15-2148:161)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression)")
  def _hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),e2,e3]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2FF(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2151:15-2150:152)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,float,float)")
  def _hstack_Omosek_fusion_Expression_2FF(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( Expr._constTerm_F (e2) ),( Expr._constTerm_F (e3) )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2FOmosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2152:15-2151:152)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,float,mosek.fusion.Variable)")
  def _hstack_Omosek_fusion_Expression_2FOmosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( Expr._constTerm_F (e2) ),( e3._asExpr_() )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2FOmosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2153:15-2152:152)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,float,mosek.fusion.Expression)")
  def _hstack_Omosek_fusion_Expression_2FOmosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( Expr._constTerm_F (e2) ),e3]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2F(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2154:15-2153:152)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,mosek.fusion.Variable,float)")
  def _hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2F(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( e2._asExpr_() ),( Expr._constTerm_F (e3) )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2155:15-2154:152)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable)")
  def _hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( e2._asExpr_() ),( e3._asExpr_() )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2156:15-2155:152)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression)")
  def _hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( e2._asExpr_() ),e3]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2F(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2157:15-2156:152)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,mosek.fusion.Expression,float)")
  def _hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2F(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,e2,( Expr._constTerm_F (e3) )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2158:15-2157:152)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable)")
  def _hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,e2,( e3._asExpr_() )]),1) )
  @staticmethod
  def _matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2184:15-2183:249)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("hstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)")
  def _hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(e1,e2,e3):
    if   (((e1 == None) or (e2 == None)) or (e3 == None)):
      raise Exception("Arguments e1, e2 and e3 may not be null")
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,e2,e3]),1) )
  @staticmethod
  def _matchargs_vstack__3Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2192:15-2198:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("vstack([mosek.fusion.Expression])")
  def _vstack__3Omosek_fusion_Expression_2(exprs):
    if   (exprs == None):
      raise Exception("Argument exprs may not be null")
    # src/fusion/Expr.mbi(2195:9-2198:17)
    for i in xrange(0,int(len(exprs))):
      if   (exprs[i] == None):
        raise Exception("Arguments for vstack may not be null")
    return ( Expr._stack__3Omosek_fusion_Expression_2I (exprs,0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2205:15-2204:112)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,mosek.fusion.Expression)")
  def _vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,e2]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2206:15-2205:121)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,mosek.fusion.Variable)")
  def _vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( e2._asExpr_() )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2207:15-2206:123)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,float)")
  def _vstack_Omosek_fusion_Expression_2F(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( Expr._constTerm_F (e2) )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2208:15-2207:119)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,mosek.fusion.Expression)")
  def _vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),e2]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2209:15-2208:128)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,mosek.fusion.Variable)")
  def _vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( e2._asExpr_() )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2210:15-2209:130)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,float)")
  def _vstack_Omosek_fusion_Variable_2F(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( Expr._constTerm_F (e2) )]),0) )
  @staticmethod
  def _matchargs_vstack_FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2211:15-2210:119)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(float,mosek.fusion.Expression)")
  def _vstack_FOmosek_fusion_Expression_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),e2]),0) )
  @staticmethod
  def _matchargs_vstack_FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2212:15-2211:128)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(float,mosek.fusion.Variable)")
  def _vstack_FOmosek_fusion_Variable_2(e1,e2):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),( e2._asExpr_() )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2219:15-2218:130)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)")
  def _vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,e2,e3]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2220:15-2219:139)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable)")
  def _vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,e2,( e3._asExpr_() )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2F(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2221:15-2220:141)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,mosek.fusion.Expression,float)")
  def _vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2F(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,e2,( Expr._constTerm_F (e3) )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2222:15-2221:139)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression)")
  def _vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( e2._asExpr_() ),e3]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2223:15-2222:148)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable)")
  def _vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( e2._asExpr_() ),( e3._asExpr_() )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2F(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2224:15-2223:150)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,mosek.fusion.Variable,float)")
  def _vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2F(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( e2._asExpr_() ),( Expr._constTerm_F (e3) )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2FOmosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2225:15-2224:141)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,float,mosek.fusion.Expression)")
  def _vstack_Omosek_fusion_Expression_2FOmosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( Expr._constTerm_F (e2) ),e3]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2FOmosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2226:15-2225:150)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,float,mosek.fusion.Variable)")
  def _vstack_Omosek_fusion_Expression_2FOmosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( Expr._constTerm_F (e2) ),( e3._asExpr_() )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Expression_2FF(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2227:15-2226:152)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Expression,float,float)")
  def _vstack_Omosek_fusion_Expression_2FF(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ e1,( Expr._constTerm_F (e2) ),( Expr._constTerm_F (e3) )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2229:15-2228:137)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression)")
  def _vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),e2,e3]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2230:15-2229:146)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable)")
  def _vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),e2,( e3._asExpr_() )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2F(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2231:15-2230:148)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,mosek.fusion.Expression,float)")
  def _vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2F(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),e2,( Expr._constTerm_F (e3) )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2232:15-2231:146)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression)")
  def _vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( e2._asExpr_() ),e3]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2233:15-2232:155)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)")
  def _vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( e2._asExpr_() ),( e3._asExpr_() )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2F(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2234:15-2233:157)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,mosek.fusion.Variable,float)")
  def _vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2F(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( e2._asExpr_() ),( Expr._constTerm_F (e3) )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2FOmosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2235:15-2234:148)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,float,mosek.fusion.Expression)")
  def _vstack_Omosek_fusion_Variable_2FOmosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( Expr._constTerm_F (e2) ),e3]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2FOmosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2236:15-2235:157)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,float,mosek.fusion.Variable)")
  def _vstack_Omosek_fusion_Variable_2FOmosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( Expr._constTerm_F (e2) ),( e3._asExpr_() )]),0) )
  @staticmethod
  def _matchargs_vstack_Omosek_fusion_Variable_2FF(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2237:15-2236:159)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(mosek.fusion.Variable,float,float)")
  def _vstack_Omosek_fusion_Variable_2FF(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( e1._asExpr_() ),( Expr._constTerm_F (e2) ),( Expr._constTerm_F (e3) )]),0) )
  @staticmethod
  def _matchargs_vstack_FOmosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2239:15-2238:137)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(float,mosek.fusion.Expression,mosek.fusion.Expression)")
  def _vstack_FOmosek_fusion_Expression_2Omosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),e2,e3]),0) )
  @staticmethod
  def _matchargs_vstack_FOmosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2240:15-2239:146)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(float,mosek.fusion.Expression,mosek.fusion.Variable)")
  def _vstack_FOmosek_fusion_Expression_2Omosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),e2,( e3._asExpr_() )]),0) )
  @staticmethod
  def _matchargs_vstack_FOmosek_fusion_Expression_2F(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2241:15-2240:148)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(float,mosek.fusion.Expression,float)")
  def _vstack_FOmosek_fusion_Expression_2F(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),e2,( Expr._constTerm_F (e3) )]),0) )
  @staticmethod
  def _matchargs_vstack_FOmosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2242:15-2241:146)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(float,mosek.fusion.Variable,mosek.fusion.Expression)")
  def _vstack_FOmosek_fusion_Variable_2Omosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),( e2._asExpr_() ),e3]),0) )
  @staticmethod
  def _matchargs_vstack_FOmosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2243:15-2242:155)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(float,mosek.fusion.Variable,mosek.fusion.Variable)")
  def _vstack_FOmosek_fusion_Variable_2Omosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),( e2._asExpr_() ),( e3._asExpr_() )]),0) )
  @staticmethod
  def _matchargs_vstack_FOmosek_fusion_Variable_2F(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2244:15-2243:157)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(float,mosek.fusion.Variable,float)")
  def _vstack_FOmosek_fusion_Variable_2F(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),( e2._asExpr_() ),( Expr._constTerm_F (e3) )]),0) )
  @staticmethod
  def _matchargs_vstack_FFOmosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if not isinstance(args[1],float): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2245:15-2244:148)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(float,float,mosek.fusion.Expression)")
  def _vstack_FFOmosek_fusion_Expression_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),( Expr._constTerm_F (e2) ),e3]),0) )
  @staticmethod
  def _matchargs_vstack_FFOmosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if not isinstance(args[1],float): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2246:15-2245:157)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(float,float,mosek.fusion.Variable)")
  def _vstack_FFOmosek_fusion_Variable_2(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),( Expr._constTerm_F (e2) ),( e3._asExpr_() )]),0) )
  @staticmethod
  def _matchargs_vstack_FFF(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],float): return False
    if not isinstance(args[1],float): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2247:15-2246:159)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("vstack(float,float,float)")
  def _vstack_FFF(e1,e2,e3):
    return ( Expr._stack__3Omosek_fusion_Expression_2I (([ ( Expr._constTerm_F (e1) ),( Expr._constTerm_F (e2) ),( Expr._constTerm_F (e3) )]),0) )
  @staticmethod
  def _matchargs_stack__3_3Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not isinstance(a,mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2255:15-2270:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("stack([[mosek.fusion.Expression]])")
  def _stack__3_3Omosek_fusion_Expression_2(exprs):
    if   (exprs == None):
      raise Exception("Argument exprs may not be null")
    # src/fusion/Expr.mbi(2258:9-2264:9)
    for i in xrange(0,int(len(exprs))):
      # { @ src/fusion/Expr.mbi(2259:9-2264:9)
      es = exprs[i]

      if   (es == None):
        raise Exception("Arguments for stack may not be null")
      # src/fusion/Expr.mbi(2262:11-2265:12)
      for j in xrange(0,int(len(es))):
        if   (es[j] == None):
          raise Exception("Arguments for stack may not be null")
      # } @ src/fusion/Expr.mbi(2259:9-2264:9)
    tmp = ([ None for _autovar_260 in xrange(int(len(exprs))) ])

    # src/fusion/Expr.mbi(2266:9-2267:37)
    for i in xrange(0,int(len(exprs))):
      tmp[i] = ( Expr._stack__3Omosek_fusion_Expression_2I (exprs[i],1) )
    return ( Expr._stack__3Omosek_fusion_Expression_2I (tmp,0) )
  @staticmethod
  def _matchargs_dot__3FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(2273:15-2334:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dot([float],mosek.fusion.Expression)")
  def _dot__3FOmosek_fusion_Expression_2(a,expr):
    lhs = a

    if   ((lhs == None) or (expr == None)):
      raise Exception("Arguments for dot may not be null")
    rhs = ( expr._eval_() )

    if   (rhs.shape._size != long(len(lhs))):
      raise mosek.fusion.LengthError("Lengths of operands do not match")
    elif (( rhs.shape._realnd_() ) != 1):
      raise mosek.fusion.DimensionError("Dimensions of operands do not match")
    ptrb = ([ 0l,long(len(rhs.subj))])

    cof = ([ 0.0 for _autovar_261 in xrange(int(len(rhs.cof))) ])

    subj = ( Utils.Tools._arraycopy__3L (rhs.subj) )

    bfix = None

    if   (rhs.inst != None):
      # src/fusion/Expr.mbi(2293:11-2300:11)
      k = 0

      while (k < int(len(rhs.inst))):
        i = rhs.inst[k]

        # src/fusion/Expr.mbi(2296:13-2299:13)
        j = rhs.ptrb[k]

        while (j < rhs.ptrb[(k + 1)]):
          cof[j] = (lhs[i] * rhs.cof[j])
          j += 1
        k += 1
      if   (rhs.bfix != None):
        bfixval = 0.0

        # src/fusion/Expr.mbi(2305:13-2308:13)
        k = 0

        while (k < int(len(rhs.inst))):
          bfixval = (bfixval + (rhs.bfix[k] * lhs[rhs.inst[k]]))
          k += 1
        bfix = ([ bfixval])
    else:
      # src/fusion/Expr.mbi(2314:11-2320:11)
      i = 0

      while (i < (int(len(rhs.ptrb)) - 1)):
        # src/fusion/Expr.mbi(2316:13-2319:13)
        k = rhs.ptrb[i]

        while (k < rhs.ptrb[(i + 1)]):
          cof[k] = (rhs.cof[k] * lhs[i])
          k += 1
        i += 1
      if   (rhs.bfix != None):
        bfixval = 0.0

        # src/fusion/Expr.mbi(2324:13-2327:13)
        i = 0

        while (i < int(len(rhs.bfix))):
          bfixval = (bfixval + (rhs.bfix[i] * lhs[i]))
          i += 1
        bfix = ([ bfixval])
    x = None

    if   (rhs.x != None):
      x = ( Variable._reshape_Omosek_fusion_Variable_2I (rhs.x,int(rhs.x.shape._size)) )
    return mosek.fusion.Expr(ptrb,x,subj,cof,bfix,None,None,1)
  @staticmethod
  def _matchargs_dot_Omosek_fusion_Expression_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(2338:15-2344:9)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dot(mosek.fusion.Expression,[float])")
  def _dot_Omosek_fusion_Expression_2_3F(expr,a):
    if   ((a == None) or (expr == None)):
      raise Exception("Arguments for dot may not be null")
    return ( Expr._dot__3FOmosek_fusion_Expression_2 (a,expr) )
  @staticmethod
  def _matchargs_dot__3FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2346:15-2352:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dot([float],mosek.fusion.Variable)")
  def _dot__3FOmosek_fusion_Variable_2(a,v):
    if   ((a == None) or (v == None)):
      raise Exception("Arguments for dot may not be null")
    return ( Expr._dot_Omosek_fusion_Variable_2_3F (v,a) )
  @staticmethod
  def _matchargs_dot_Omosek_fusion_Variable_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(2355:15-2376:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dot(mosek.fusion.Variable,[float])")
  def _dot_Omosek_fusion_Variable_2_3F(v,a):
    lhs = v

    rhs = a

    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for dot may not be null")
    if   (( lhs.shape._realnd_() ) != 1):
      raise mosek.fusion.DimensionError("Dimensions of operands do not match")
    elif (lhs.shape._size != int(len(rhs))):
      raise mosek.fusion.LengthError("Operand lengths do not match")
    ptrb = ([ 0l,long(len(rhs))])

    subj = ( Utils.Tools._range_LL (0l,long(len(rhs))) )

    cof = ( Utils.Tools._arraycopy__3F (rhs) )

    bfix = None

    return mosek.fusion.Expr(ptrb,( Variable._reshape_Omosek_fusion_Variable_2I (lhs,int(lhs.shape._size)) ),subj,cof,bfix,None,None,1)
  @staticmethod
  def _matchargs_dot_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(2379:15-2384:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dot(mosek.fusion.Variable,mosek.fusion.Matrix)")
  def _dot_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(v,m):
    if   ((v == None) or (m == None)):
      raise Exception("Arguments for dot may not be null")
    return ( Expr._dot_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2 (m,v) )
  @staticmethod
  def _matchargs_dot_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2387:15-2477:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("dot(mosek.fusion.Matrix,mosek.fusion.Variable)")
  def _dot_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(m,v):
    lhs_ = m

    rhs = v

    if   ((v == None) or (m == None)):
      raise Exception("Arguments for dot may not be null")
    if   (((v.shape.nd != 2) or (( v.shape._dim_I(0) ) != m._dimi)) or (( v.shape._dim_I(1) ) != m._dimj)):
      raise mosek.fusion.DimensionError("Dimensions of operands do not match")
    res = None

    _autovar_262 = lhs_
    if   isinstance(_autovar_262,mosek.fusion.DenseMatrix):
      lhs = _autovar_262
      data = lhs._data

      numnz = 0

      # src/fusion/Expr.mbi(2406:13-2409:17)
      for i in xrange(0l,lhs._nnz):
        if   ((0.0 < lhs._data[i]) or (lhs._data[i] < 0.0)):
          numnz += 1
      if   (numnz < lhs._nnz):
        ptrb = ([ 0l,long(numnz)])

        subj = ([ 0l for _autovar_263 in xrange(numnz) ])

        cof = ([ 0.0 for _autovar_264 in xrange(numnz) ])

        k = 0

        # src/fusion/Expr.mbi(2415:15-2424:20)
        for i in xrange(0l,lhs._nnz):
          if   ((0.0 < lhs._data[i]) or (lhs._data[i] < 0.0)):
            subj[k] = i
            cof[k] = lhs._data[i]
            k += 1
        res = mosek.fusion.Expr(ptrb,rhs,subj,cof,None,None,None,1)
      else:
        res = mosek.fusion.Expr(([ 0l,lhs._nnz]),( Variable._reshape_Omosek_fusion_Variable_2I (rhs,int(rhs.shape._size)) ),( Utils.Tools._range_L (lhs._nnz) ),lhs._data,None,None,None,1)
    else:
      lhs = _autovar_262
      nnz = ( lhs._numNonzeros_() )

      if   (nnz > 0):
        subi = ([ 0 for _autovar_265 in xrange(nnz) ])

        subj = ([ 0 for _autovar_266 in xrange(nnz) ])

        val = ([ 0.0 for _autovar_267 in xrange(nnz) ])

        ( lhs._getDataAsTriplets__3I_3I_3F(subi,subj,val) )
        sub = ([ 0l for _autovar_268 in xrange(nnz) ])

        # src/fusion/Expr.mbi(2452:15-2453:61)
        for k in xrange(0l,nnz):
          sub[k] = long(((subi[k] * lhs._dimj) + subj[k]))
        res = mosek.fusion.Expr(([ 0l,nnz]),( Variable._reshape_Omosek_fusion_Variable_2I (rhs,int(rhs.shape._size)) ),sub,val,None,None,None,1)
      else:
        res = mosek.fusion.Expr(([ 0l,0l]),( Variable._reshape_Omosek_fusion_Variable_2I (rhs,int(rhs.shape._size)) ),([ 0l for _autovar_269 in xrange(0) ]),([ 0.0 for _autovar_270 in xrange(0) ]),None,None,None,1)
    return res
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2498:15-2668:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Matrix,mosek.fusion.Variable)")
  def _mul_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(mx,v):
    if   ((v == None) or (mx == None)):
      raise Exception("Arguments for mul may not be null")
    shape = v.shape

    mdimi = ( mx._numRows_() )

    mdimj = ( mx._numColumns_() )




    if   (shape.nd == 1):
      vdimi = ( shape._dim_I(0) )
      vdimj = 1
      x = v
    elif (shape.nd == 2):
      vdimi = ( shape._dim_I(0) )
      vdimj = ( shape._dim_I(1) )
      x = ( Variable._flatten_Omosek_fusion_Variable_2 (v) )
    else:
      raise mosek.fusion.LengthError("Operand shapes do not match.")
    rdimi = mdimi

    rdimj = vdimj


    rshape = None

    if   ((v.shape.nd == 1) and (( v.shape._dim_I(0) ) == 1)):
      rshape = mosek.fusion.NDSet(mdimi,mdimj)
    elif (v.shape.nd == 1):
      rshape = mosek.fusion.IntSet(rdimi)
    else:
      rshape = mosek.fusion.NDSet(rdimi,rdimj)
    if   ((shape.nd == 1) and (( shape._dim_I(0) ) == 1)):
      if   ( mx._isSparse_() ):
        msubi = ([ 0 for _autovar_271 in xrange(( mx._numNonzeros_() )) ])

        msubj = ([ 0 for _autovar_272 in xrange(( mx._numNonzeros_() )) ])

        mcof = ([ 0.0 for _autovar_273 in xrange(( mx._numNonzeros_() )) ])

        ( mx._getDataAsTriplets__3I_3I_3F(msubi,msubj,mcof) )
        inst = ([ 0l for _autovar_274 in xrange(( mx._numNonzeros_() )) ])

        # src/fusion/Expr.mbi(2542:13-85)
        for i in xrange(0,int(len(msubj))):
          inst[i] = long(((msubi[i] * mdimj) + msubj[i]))
        res = mosek.fusion.Expr(( Utils.Tools._range_LL (0l,long((( mx._numNonzeros_() ) + 1))) ),v,( Utils.Tools._makevector_LI (0l,int(( mx._numNonzeros_() ))) ),mcof,None,rshape,inst)
      else:
        res = mosek.fusion.Expr(( Utils.Tools._range_LL (0l,(( mx._numNonzeros_() ) + 1)) ),v,( Utils.Tools._makevector_LI (0l,int(( mx._numNonzeros_() ))) ),( mx._getDataAsArray_() ),None,rshape,None)
    elif (mdimj == vdimi):
      if   ( mx._isSparse_() ):
        if   (( mx._numNonzeros_() ) > 0):
          msubi = ([ 0 for _autovar_275 in xrange(( mx._numNonzeros_() )) ])

          msubj = ([ 0 for _autovar_276 in xrange(( mx._numNonzeros_() )) ])

          mcof = ([ 0.0 for _autovar_277 in xrange(( mx._numNonzeros_() )) ])

          mnnz = int(len(mcof))

          ( mx._getDataAsTriplets__3I_3I_3F(msubi,msubj,mcof) )
          resnent = (int(len(mcof)) * vdimj)

          mnnzrows = 0

          # src/fusion/Expr.mbi(2578:15-2584:15)
          i = 0

          while (i < mnnz):
            icur = msubi[i]

            e = (i + 1)

            # src/fusion/Expr.mbi(2581:30-71)
            while ((e < mnnz) and (icur == msubi[e])):
              e += 1
            mnnzrows += 1
            i = e
          resnnz = (mnnzrows * vdimj)

          ptrb = ([ 0l for _autovar_278 in xrange((resnnz + 1)) ])

          inst = ([ 0l for _autovar_279 in xrange(resnnz) ])

          subj = ([ 0l for _autovar_280 in xrange(resnent) ])

          cof = ([ 0.0 for _autovar_281 in xrange(resnent) ])

          if   (mnnzrows > 0):
            ptrb_i = 0

            subj_i = 0

            # src/fusion/Expr.mbi(2596:17-2617:17)
            i = 0

            while (i < mnnz):
              icur = msubi[i]

              e = (i + 1)

              # src/fusion/Expr.mbi(2599:32-73)
              while ((e < mnnz) and (icur == msubi[e])):
                e += 1
              # src/fusion/Expr.mbi(2601:19-2614:19)
              for j in xrange(0,vdimj):
                # { @ src/fusion/Expr.mbi(2602:19-2614:19)
                ptrb[(ptrb_i + 1)] = (ptrb[ptrb_i] + (e - i))
                inst[ptrb_i] = ((long(icur) * vdimj) + j)
                # src/fusion/Expr.mbi(2606:21-2611:21)
                for k in xrange(i,e):
                  # { @ src/fusion/Expr.mbi(2607:21-2611:21)
                  subj[subj_i] = ((long(msubj[k]) * vdimj) + j)
                  cof[subj_i] = mcof[k]
                  subj_i += 1
                  # } @ src/fusion/Expr.mbi(2607:21-2611:21)
                ptrb_i += 1
                # } @ src/fusion/Expr.mbi(2602:19-2614:19)
              i = e
          if   (int(len(inst)) == (rdimi * rdimj)):
            inst = None
          res = mosek.fusion.Expr(ptrb,x,subj,cof,None,rshape,inst)
        else:
          res = mosek.fusion.Expr(([ 0l for _autovar_282 in xrange(1) ]),x,([ 0l for _autovar_283 in xrange(0) ]),([ 0.0 for _autovar_284 in xrange(0) ]),None,rshape,([ 0l for _autovar_285 in xrange(0) ]))
      else:
        resnnz = ((mdimi * mdimj) * vdimj)

        mcof = ( mx._getDataAsArray_() )

        ptrb = ( Utils.Tools._range_LLL (0l,(long(resnnz) + 1),long(mdimj)) )

        subj = ([ 0l for _autovar_286 in xrange(resnnz) ])

        cof = ([ 0.0 for _autovar_287 in xrange(resnnz) ])

        # { @ src/fusion/Expr.mbi(2649:13-2659:13)
        p = 0

        # src/fusion/Expr.mbi(2651:15-2658:19)
        for i in xrange(0,rdimi):
          # src/fusion/Expr.mbi(2652:17-2658:19)
          for j in xrange(0,rdimj):
            # src/fusion/Expr.mbi(2653:19-2658:19)
            for k in xrange(0,mdimj):
              # { @ src/fusion/Expr.mbi(2654:19-2658:19)
              subj[p] = long(((k * vdimj) + j))
              cof[p] = mcof[((i * mdimj) + k)]
              p += 1
              # } @ src/fusion/Expr.mbi(2654:19-2658:19)
        # } @ src/fusion/Expr.mbi(2649:13-2659:13)
        res = mosek.fusion.Expr(ptrb,x,subj,cof,None,rshape,None)
    else:
      raise mosek.fusion.LengthError("Operand shapes do not match.")
    return res
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(2684:15-2813:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Variable,mosek.fusion.Matrix)")
  def _mul_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(v,mx):
    if   ((v == None) or (mx == None)):
      raise Exception("Arguments for mul may not be null")
    lhs = v

    rhs = mx

    mdimi = ( mx._numRows_() )

    mdimj = ( mx._numColumns_() )



    mnnz = ( mx._numNonzeros_() )

    if   ((v.shape.nd == 1) and (( v.shape._dim_I(0) ) == 1)):
      return ( Expr._mul_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2 (mx,v) )
    else:
      if   (lhs.shape.nd == 1):
        if   (rhs._dimi != lhs.shape._size):
          raise mosek.fusion.LengthError("Operand shapes do not match.")
        vdimi = 1
        vdimj = ( lhs.shape._dim_I(0) )
      elif (lhs.shape.nd == 2):
        if   (mx._dimi != ( v.shape._dim_I(1) )):
          raise mosek.fusion.LengthError("Operand shapes do not match.")
        vdimi = ( lhs.shape._dim_I(0) )
        vdimj = ( lhs.shape._dim_I(1) )
      else:
        raise mosek.fusion.LengthError("Variable must be one- or two-dimensional.")
      rdimi = vdimi

      rdimj = mdimj

      rshape = None

      if   (v.shape.nd == 1):
        rshape = mosek.fusion.IntSet(rdimj)
      else:
        rshape = mosek.fusion.NDSet(rdimi,rdimj)
      if   (not ( mx._isSparse_() )):
        rnnz = (long(rdimi) * long(rdimj))

        mcof = ( mx._getDataAsArray_() )

        ptrb = ([ 0l for _autovar_288 in xrange((rnnz + 1)) ])

        subj = ([ 0l for _autovar_289 in xrange((rnnz * long(vdimj))) ])

        cof = ([ 0.0 for _autovar_290 in xrange((rnnz * long(vdimj))) ])

        # { @ src/fusion/Expr.mbi(2734:13-2754:13)
        ptrb_i = 0

        subj_i = 0l

        # src/fusion/Expr.mbi(2738:15-2753:15)
        for i in xrange(0,rdimi):
          # { @ src/fusion/Expr.mbi(2739:15-2753:15)
          # src/fusion/Expr.mbi(2740:17-2752:17)
          for j in xrange(0,rdimj):
            # { @ src/fusion/Expr.mbi(2741:17-2752:17)
            midx = long(j)

            # src/fusion/Expr.mbi(2743:19-2748:19)
            for k in xrange(0,vdimj):
              # { @ src/fusion/Expr.mbi(2744:19-2748:19)
              subj[subj_i] = ((long(i) * vdimj) + k)
              cof[subj_i] = mcof[((k * mdimj) + j)]
              subj_i += 1
              # } @ src/fusion/Expr.mbi(2744:19-2748:19)
            ptrb[(ptrb_i + 1)] = subj_i
            ptrb_i += 1
            # } @ src/fusion/Expr.mbi(2741:17-2752:17)
          # } @ src/fusion/Expr.mbi(2739:15-2753:15)
        # } @ src/fusion/Expr.mbi(2734:13-2754:13)
        return mosek.fusion.Expr(ptrb,( Variable._flatten_Omosek_fusion_Variable_2 (v) ),subj,cof,None,rshape,None)
      else:
        if   (mnnz > 0):
          msubi = ([ 0 for _autovar_291 in xrange(mnnz) ])

          msubj = ([ 0 for _autovar_292 in xrange(mnnz) ])

          mcof = ([ 0.0 for _autovar_293 in xrange(mnnz) ])

          perm = ( Utils.Tools._range_L (mnnz) )

          ( mx._getDataAsTriplets__3I_3I_3F(msubi,msubj,mcof) )
          ( CommonTools._argQsort__3L_3I_3ILL (perm,msubj,msubi,0l,mnnz) )
          mncol = 0l

          if   (mnnz > 0):
            mncol = 1l
            # src/fusion/Expr.mbi(2773:17-2775:18)
            i = 1l

            while (i < mnnz):
              if   (msubj[perm[i]] > msubj[perm[(i - 1)]]):
                mncol += 1
              i += 1
          rnnz = (mncol * long(vdimi))

          ptrb = ([ 0l for _autovar_294 in xrange((rnnz + 1)) ])

          inst = ([ 0l for _autovar_295 in xrange(rnnz) ])

          subj = ([ 0l for _autovar_296 in xrange((mnnz * vdimi)) ])

          cof = ([ 0.0 for _autovar_297 in xrange((mnnz * vdimi)) ])

          # { @ src/fusion/Expr.mbi(2782:15-2804:15)
          ptrb_i = 0

          subj_i = 0l

          # src/fusion/Expr.mbi(2786:17-2803:19)
          for i in xrange(0,rdimi):
            # src/fusion/Expr.mbi(2787:19-2803:19)
            j = 0l

            while (j < mnnz):
              col_cur = msubj[perm[j]]

              mi = j

              me = j

              # src/fusion/Expr.mbi(2790:41-101)
              while ((me < mnnz) and (msubj[perm[me]] == msubj[perm[j]])):
                me += 1
              # src/fusion/Expr.mbi(2792:21-2797:21)
              for k in xrange(mi,me):
                # { @ src/fusion/Expr.mbi(2793:21-2797:21)
                subj[subj_i] = ((long(i) * vdimj) + msubi[perm[k]])
                cof[subj_i] = mcof[perm[k]]
                subj_i += 1
                # } @ src/fusion/Expr.mbi(2793:21-2797:21)
              ptrb[(ptrb_i + 1)] = subj_i
              inst[ptrb_i] = ((long(i) * rdimj) + col_cur)
              ptrb_i += 1
              j = me
          # } @ src/fusion/Expr.mbi(2782:15-2804:15)
          return mosek.fusion.Expr(ptrb,lhs,subj,cof,None,rshape,inst)
        else:
          return mosek.fusion.Expr(([ 0l for _autovar_298 in xrange(1) ]),lhs,([ 0l for _autovar_299 in xrange(0) ]),([ 0.0 for _autovar_300 in xrange(0) ]),None,rshape,([ 0l for _autovar_301 in xrange(0) ]))
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Variable_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(2827:15-2872:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Variable,[float])")
  def _mul_Omosek_fusion_Variable_2_3F(v,vals):
    if   ((v == None) or (vals == None)):
      raise Exception("Arguments for mul may not be null")
    lhs = v

    rhs = vals

    if   (lhs.shape._size == 0):
      ptrb = ([ 0l,0l])

      subj = ([ 0l for _autovar_302 in xrange(0) ])

      cof = ([ 0.0 for _autovar_303 in xrange(0) ])

      return mosek.fusion.Expr(ptrb,( v._flatten_() ),subj,cof,None,None,None,1)
    elif (lhs.shape._size == 1):
      ptrb = ( Utils.Tools._range_LL (0l,(long(len(rhs)) + 1)) )

      subj = ( Utils.Tools._makevector_LI (0l,int(len(rhs))) )

      cof = ( Utils.Tools._arraycopy__3F (rhs) )

      bfix = None

      return mosek.fusion.Expr(ptrb,lhs,subj,cof,bfix,None,None,1)
    elif ((v.shape.nd == 1) and (( v.shape._dim_I(0) ) == int(len(vals)))):
      return ( Expr._dot_Omosek_fusion_Variable_2_3F (v,vals) )
    elif (lhs.shape.nd == 2):
      if   (( lhs.shape._dim_I(1) ) != int(len(rhs))):
        raise mosek.fusion.DimensionError("Dimensions of operands do not match")
      ptrb = ( Utils.Tools._range_LLL (0l,(lhs.shape._size + ( lhs.shape._dim_I(1) )),long(( lhs.shape._dim_I(1) ))) )

      subj = ( Utils.Tools._range_LL (0l,lhs.shape._size) )

      cof = ([ 0.0 for _autovar_304 in xrange(lhs.shape._size) ])

      rowlen = long(( lhs.shape._dim_I(1) ))

      # src/fusion/Expr.mbi(2863:11-2864:68)
      for i in xrange(0l,long(( lhs.shape._dim_I(0) ))):
        ( Utils.Tools._arraycopy__3FL_3FLL (rhs,0l,cof,(i * rowlen),rowlen) )
      bfix = None

      return mosek.fusion.Expr(ptrb,( lhs._flatten_() ),subj,cof,bfix,None,None,1)
    else:
      raise mosek.fusion.DimensionError("Dimensions of operands do not match")
  @staticmethod
  def _matchargs_mul__3FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2879:15-2926:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul([float],mosek.fusion.Variable)")
  def _mul__3FOmosek_fusion_Variable_2(vals,v):
    if   ((v == None) or (vals == None)):
      raise Exception("Arguments for mul may not be null")
    lhs = vals

    rhs = v

    if   ((rhs.shape._size == 1) or (rhs.shape.nd == 1)):
      return ( Expr._mul_Omosek_fusion_Variable_2_3F (rhs,lhs) )
    elif ((v.shape.nd == 1) and (( v.shape._dim_I(0) ) == int(len(vals)))):
      return ( Expr._dot_Omosek_fusion_Variable_2_3F (v,vals) )
    elif (rhs.shape.nd == 2):
      if   (( rhs.shape._dim_I(0) ) != int(len(lhs))):
        raise mosek.fusion.DimensionError("Dimensions of operands do not match")
      nrow = long(( rhs.shape._dim_I(0) ))

      ncol = long(( rhs.shape._dim_I(1) ))

      ptrb = ( Utils.Tools._range_LLL (0l,((ncol + 1) * nrow),nrow) )

      subj = ([ 0l for _autovar_305 in xrange(rhs.shape._size) ])

      cof = ([ 0.0 for _autovar_306 in xrange(rhs.shape._size) ])

      # src/fusion/Expr.mbi(2904:11-2908:11)
      for i in xrange(0l,ncol):
        # { @ src/fusion/Expr.mbi(2905:11-2908:11)
        B = (i * nrow)

        ( Utils.Tools._arraycopy__3FL_3FLL (lhs,0l,cof,B,nrow) )
        # } @ src/fusion/Expr.mbi(2905:11-2908:11)
      k = 0l

      # src/fusion/Expr.mbi(2911:11-2917:11)
      for j in xrange(0l,ncol):
        # { @ src/fusion/Expr.mbi(2912:11-2917:11)
        # src/fusion/Expr.mbi(2913:13-2916:13)
        for i in xrange(0l,nrow):
          # { @ src/fusion/Expr.mbi(2914:13-2916:13)
          subj[k] = ((i * ncol) + j)
          k += 1
          # } @ src/fusion/Expr.mbi(2914:13-2916:13)
        # } @ src/fusion/Expr.mbi(2912:11-2917:11)
      bfix = None

      return mosek.fusion.Expr(ptrb,( Variable._reshape_Omosek_fusion_Variable_2I (rhs,int(rhs.shape._size)) ),subj,cof,bfix,None,None,1)
    else:
      raise mosek.fusion.DimensionError("Dimensions of operands do not match")
  @staticmethod
  def _matchargs_mul_FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2933:15-2945:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(float,mosek.fusion.Variable)")
  def _mul_FOmosek_fusion_Variable_2(val,v):
    if   (v == None):
      raise Exception("Arguments for mul may not be null")
    lhs = val

    rhs = v

    ptrb = ( Utils.Tools._range_LL (0l,(rhs.shape._size + 1l)) )

    cof = ( Utils.Tools._makevector_FI (lhs,int(rhs.shape._size)) )

    subj = ( Utils.Tools._range_LL (0l,rhs.shape._size) )

    bfix = None

    return mosek.fusion.Expr(ptrb,rhs,subj,cof,bfix,rhs.shape,None)
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Variable_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(2952:15-2958:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Variable,float)")
  def _mul_Omosek_fusion_Variable_2F(v,val):
    if   (v == None):
      raise Exception("Arguments for mul may not be null")
    return ( Expr._mul_FOmosek_fusion_Variable_2 (val,v) )
  @staticmethod
  def _matchargs_mul__3_3FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(2961:15-2966:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul([[float]],mosek.fusion.Variable)")
  def _mul__3_3FOmosek_fusion_Variable_2(mx,v):
    if   ((mx == None) or (v == None)):
      raise Exception("Arguments for mul may not be null")
    return ( Expr._mul_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2 (mosek.fusion.DenseMatrix(mx),v) )
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Variable_2_3_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(2969:15-2983:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Variable,[[float]])")
  def _mul_Omosek_fusion_Variable_2_3_3F(v,mx):
    if   ((mx == None) or (v == None)):
      raise Exception("Arguments for mul may not be null")
    if   (int(len(mx)) == 0):
      ptrb = ([ 0l,0l])

      subj = ([ 0l for _autovar_307 in xrange(0) ])

      cof = ([ 0.0 for _autovar_308 in xrange(0) ])

      return mosek.fusion.Expr(ptrb,( v._flatten_() ),subj,cof,None,None,None,1)
    else:
      return ( Expr._mul_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2 (v,mosek.fusion.DenseMatrix(mx)) )
  @staticmethod
  def _matchargs_mul_10DExpr_1Matrix__3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Variable): return False
    if args[4] is not None and not isinstance(args[4],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(2993:16-3053:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul_0DExpr_Matrix([long],[float],[float],mosek.fusion.Variable,mosek.fusion.Matrix)")
  def __mul_10DExpr_1Matrix__3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Matrix_2(esubj,ecof,ebfix,x,mx):
    res = None

    mdimi = ( mx._numRows_() )

    mdimj = ( mx._numColumns_() )

    mnnz = ( mx._numNonzeros_() )


    msubi = None

    msubj = None

    ptrb = ( Utils.Tools._range_LLL (0l,((mnnz * long(len(esubj))) + 1),long(len(esubj))) )

    subj = ([ 0l for _autovar_309 in xrange((mnnz * int(len(esubj)))) ])

    cof = ([ 0.0 for _autovar_310 in xrange((mnnz * int(len(esubj)))) ])

    bfix = None

    inst = None

    if   (not ( mx._isSparse_() )):
      mcof = ( mx._getDataAsArray_() )
    else:
      msubi = ([ 0 for _autovar_311 in xrange(mnnz) ])
      msubj = ([ 0 for _autovar_312 in xrange(mnnz) ])
      mcof = ([ 0.0 for _autovar_313 in xrange(mnnz) ])
      inst = ([ 0l for _autovar_314 in xrange(mnnz) ])
      ( mx._getDataAsTriplets__3I_3I_3F(msubi,msubj,mcof) )
      # src/fusion/Expr.mbi(3027:11-3028:56)
      for i in xrange(0,int(len(msubi))):
        inst[i] = ((long(msubi[i]) * mdimj) + msubj[i])
    # { @ src/fusion/Expr.mbi(3032:9-3041:9)
    k = 0

    # src/fusion/Expr.mbi(3034:11-3040:13)
    for i in xrange(0l,mnnz):
      # src/fusion/Expr.mbi(3035:13-3040:13)
      for j in xrange(0,int(len(esubj))):
        # { @ src/fusion/Expr.mbi(3036:13-3040:13)
        subj[k] = esubj[j]
        cof[k] = (mcof[i] * mcof[i])
        k += 1
        # } @ src/fusion/Expr.mbi(3036:13-3040:13)
    # } @ src/fusion/Expr.mbi(3032:9-3041:9)
    if   (ebfix != None):
      bfix = ([ 0.0 for _autovar_315 in xrange(mnnz) ])
      # src/fusion/Expr.mbi(3046:11-3047:41)
      for i in xrange(0l,mnnz):
        bfix[i] = (mcof[i] * ebfix[0])
    res = mosek.fusion.Expr(ptrb,x,subj,cof,bfix,mosek.fusion.NDSet(mdimi,mdimj),None)
    return res
  @staticmethod
  def _matchargs_mul_12DDExpr_1DMatrix__3L_3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3FII(args):
    if len(args) != 11:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[4] is not None and not isinstance(args[4],mosek.fusion.Variable): return False
    if args[5] is not None and not isinstance(args[5],mosek.fusion.Set): return False
    if not isinstance(args[6],int): return False
    if not isinstance(args[7],int): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[9],int): return False
    if not isinstance(args[10],int): return False
    return True
  # origin: src/fusion/Expr.mbi(3057:16-3125:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul_2DDExpr_DMatrix([long],[long],[float],[float],mosek.fusion.Variable,mosek.fusion.Set,int,int,[float],int,int)")
  def __mul_12DDExpr_1DMatrix__3L_3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3FII(eptrb,esubj,ecof,ebfix,x,rshape,edimi,edimj,mcof,mdimi,mdimj):
    res = None

    rdimi = edimi

    rdimj = mdimj

    ptrb = ([ 0l for _autovar_316 in xrange(((edimi * mdimj) + 1)) ])

    inst = None

    subj = ([ 0l for _autovar_317 in xrange((int(len(esubj)) * mdimj)) ])

    cof = ([ 0.0 for _autovar_318 in xrange((int(len(esubj)) * mdimj)) ])

    bfix = None

    # { @ src/fusion/Expr.mbi(3083:9-3106:9)
    rsubj_i = 0

    rptrb_i = 0

    # src/fusion/Expr.mbi(3086:11-3105:13)
    for i in xrange(0,rdimi):
      # src/fusion/Expr.mbi(3087:13-3105:13)
      for j in xrange(0,rdimj):
        # { @ src/fusion/Expr.mbi(3088:13-3105:13)
        eptr_base = (i * edimj)

        ptrb[(rptrb_i + 1)] = ptrb[rptrb_i]
        # src/fusion/Expr.mbi(3091:15-3102:15)
        for k in xrange(0,mdimi):
          # { @ src/fusion/Expr.mbi(3092:15-3102:15)
          ptrb[(rptrb_i + 1)] = (ptrb[(rptrb_i + 1)] + (eptrb[((eptr_base + k) + 1)] - eptrb[(eptr_base + k)]))
          c = mcof[((mdimj * k) + j)]

          # src/fusion/Expr.mbi(3096:17-3101:17)
          for l in xrange(eptrb[(eptr_base + k)],eptrb[((eptr_base + k) + 1)]):
            # { @ src/fusion/Expr.mbi(3097:17-3101:17)
            subj[rsubj_i] = esubj[l]
            cof[rsubj_i] = (ecof[l] * c)
            rsubj_i += 1
            # } @ src/fusion/Expr.mbi(3097:17-3101:17)
          # } @ src/fusion/Expr.mbi(3092:15-3102:15)
        rptrb_i += 1
        # } @ src/fusion/Expr.mbi(3088:13-3105:13)
    # } @ src/fusion/Expr.mbi(3083:9-3106:9)
    if   (ebfix != None):
      bfix = ([ 0.0 for _autovar_319 in xrange((rdimi * rdimj)) ])
      rbfix_i = 0

      # src/fusion/Expr.mbi(3112:11-3119:13)
      for i in xrange(0,rdimi):
        # src/fusion/Expr.mbi(3113:13-3119:13)
        for j in xrange(0,rdimj):
          # { @ src/fusion/Expr.mbi(3114:13-3119:13)
          bfix_base = (i * edimj)

          # src/fusion/Expr.mbi(3116:15-3117:91)
          for k in xrange(0,mdimi):
            bfix[rbfix_i] = (bfix[rbfix_i] + (ebfix[(bfix_base + k)] * mcof[((mdimj * k) + j)]))
          rbfix_i += 1
          # } @ src/fusion/Expr.mbi(3114:13-3119:13)
    res = mosek.fusion.Expr(ptrb,x,subj,cof,bfix,rshape,inst)
    return res
  @staticmethod
  def _matchargs_mul_1DMatrix_12DDExpr__3L_3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3FII(args):
    if len(args) != 11:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[4] is not None and not isinstance(args[4],mosek.fusion.Variable): return False
    if args[5] is not None and not isinstance(args[5],mosek.fusion.Set): return False
    if not isinstance(args[6],int): return False
    if not isinstance(args[7],int): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[9],int): return False
    if not isinstance(args[10],int): return False
    return True
  # origin: src/fusion/Expr.mbi(3128:16-3191:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul_DMatrix_2DDExpr([long],[long],[float],[float],mosek.fusion.Variable,mosek.fusion.Set,int,int,[float],int,int)")
  def __mul_1DMatrix_12DDExpr__3L_3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3FII(eptrb,esubj,ecof,ebfix,x,rshape,edimi,edimj,mcof,mdimi,mdimj):
    res = None

    rdimi = mdimi

    rdimj = edimj

    mnnz = (long(rdimi) * long(rdimj))

    ptrb = ([ 0l for _autovar_320 in xrange((mnnz + 1)) ])

    subj = ([ 0l for _autovar_321 in xrange((int(len(esubj)) * mdimj)) ])

    cof = ([ 0.0 for _autovar_322 in xrange((int(len(esubj)) * mdimj)) ])

    bfix = None

    # { @ src/fusion/Expr.mbi(3154:9-3173:9)
    subj_i = 0l

    ptrb_i = 0

    # src/fusion/Expr.mbi(3157:11-3172:13)
    for i in xrange(0,mdimi):
      # src/fusion/Expr.mbi(3158:13-3172:13)
      for j in xrange(0,edimj):
        # { @ src/fusion/Expr.mbi(3159:13-3172:13)
        # src/fusion/Expr.mbi(3160:15-3169:15)
        for k in xrange(0,edimi):
          # { @ src/fusion/Expr.mbi(3161:15-3169:15)
          c = mcof[((mdimj * i) + k)]

          # src/fusion/Expr.mbi(3163:17-3168:17)
          for l in xrange(eptrb[((k * edimj) + j)],eptrb[(((k * edimj) + j) + 1)]):
            # { @ src/fusion/Expr.mbi(3164:17-3168:17)
            cof[subj_i] = (c * ecof[l])
            subj[subj_i] = esubj[l]
            subj_i += 1
            # } @ src/fusion/Expr.mbi(3164:17-3168:17)
          # } @ src/fusion/Expr.mbi(3161:15-3169:15)
        ptrb[(ptrb_i + 1)] = subj_i
        ptrb_i += 1
        # } @ src/fusion/Expr.mbi(3159:13-3172:13)
    # } @ src/fusion/Expr.mbi(3154:9-3173:9)
    if   (ebfix != None):
      bfix_i = 0

      bfix = ([ 0.0 for _autovar_323 in xrange(mnnz) ])
      # src/fusion/Expr.mbi(3179:11-3185:13)
      for i in xrange(0,mdimi):
        # src/fusion/Expr.mbi(3180:13-3185:13)
        for j in xrange(0,edimj):
          # { @ src/fusion/Expr.mbi(3181:13-3185:13)
          # src/fusion/Expr.mbi(3182:15-3183:81)
          for k in xrange(0,edimi):
            bfix[bfix_i] = (bfix[bfix_i] + (ebfix[((k * edimj) + j)] * mcof[((mdimj * i) + k)]))
          bfix_i += 1
          # } @ src/fusion/Expr.mbi(3181:13-3185:13)
    res = mosek.fusion.Expr(ptrb,x,subj,cof,bfix,rshape,None)
    return res
  @staticmethod
  def _matchargs_mul_12DSExpr_1SMatrix__3L_3L_3F_3F_3LOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3I_3I_3FII(args):
    if len(args) != 14:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if args[5] is not None and not isinstance(args[5],mosek.fusion.Variable): return False
    if args[6] is not None and not isinstance(args[6],mosek.fusion.Set): return False
    if not isinstance(args[7],int): return False
    if not isinstance(args[8],int): return False
    a = args[9]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[10]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[11]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[12],int): return False
    if not isinstance(args[13],int): return False
    return True
  # origin: src/fusion/Expr.mbi(3195:16-3367:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul_2DSExpr_SMatrix([long],[long],[float],[float],[long],mosek.fusion.Variable,mosek.fusion.Set,int,int,[int],[int],[float],int,int)")
  def __mul_12DSExpr_1SMatrix__3L_3L_3F_3F_3LOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3I_3I_3FII(eptrb,esubj,ecof,ebfix,einst,x,rshape,edimi,edimj,msubi,msubj,mcof,mdimi,mdimj):
    res = None

    rdimi = edimi

    rdimj = mdimj

    mnnz = long(len(mcof))

    ennz = long(len(einst))

    perm = ( Utils.Tools._range_LL (0l,long(len(msubi))) )

    ( CommonTools._argQsort__3L_3I_3ILL (perm,msubj,msubi,0l,long(len(msubi))) )
    rnnz = 0

    rnelm = 0l

    # { @ src/fusion/Expr.mbi(3226:9-3259:9)
    # src/fusion/Expr.mbi(3227:11-3258:11)
    erow_b = 0

    while (erow_b < ennz):
      erow_e = erow_b

      erow_cur = (einst[erow_b] / edimj)

      # src/fusion/Expr.mbi(3231:13-87)
      while ((erow_e < int(len(einst))) and (erow_cur == (einst[erow_e] / edimj))):
        erow_e += 1
      # src/fusion/Expr.mbi(3233:13-3256:13)
      mcol_b = 0

      while (mcol_b < mnnz):
        mcol_e = mcol_b

        mcol_cur = msubj[perm[mcol_b]]

        # src/fusion/Expr.mbi(3237:15-81)
        while ((mcol_e < mnnz) and (msubj[perm[mcol_e]] == mcol_cur)):
          mcol_e += 1
        ei = erow_b

        mi = mcol_b

        rnelm_tmp = rnelm

        # src/fusion/Expr.mbi(3242:15-3249:17)
        while ((ei < erow_e) and (mi < mcol_e)):
          if   ((einst[ei] % edimj) < msubi[perm[mi]]):
            ei += 1
          elif ((einst[ei] % edimj) > msubi[perm[mi]]):
            mi += 1
          else:
            rnelm_tmp = (rnelm_tmp + (eptrb[(ei + 1)] - eptrb[ei]))
            ei += 1
            mi += 1
        if   (rnelm_tmp > rnelm):
          rnelm = rnelm_tmp
          rnnz += 1
        mcol_b = mcol_e
      erow_b = erow_e
    # } @ src/fusion/Expr.mbi(3226:9-3259:9)
    ptrb = ([ 0l for _autovar_324 in xrange((rnnz + 1)) ])

    inst = ([ 0l for _autovar_325 in xrange(rnnz) ])

    subj = ([ 0l for _autovar_326 in xrange(rnelm) ])

    cof = ([ 0.0 for _autovar_327 in xrange(rnelm) ])

    bfix = None

    # { @ src/fusion/Expr.mbi(3268:9-3314:9)
    ptrb_i = 0

    subj_i = 0l

    # src/fusion/Expr.mbi(3271:11-3313:11)
    erow_b = 0

    while (erow_b < ennz):
      erow_e = erow_b

      erow_cur = (einst[erow_b] / edimj)

      # src/fusion/Expr.mbi(3275:13-87)
      while ((erow_e < int(len(einst))) and (erow_cur == (einst[erow_e] / edimj))):
        erow_e += 1
      # src/fusion/Expr.mbi(3277:13-3311:13)
      mcol_b = 0

      while (mcol_b < mnnz):
        mcol_e = mcol_b

        rcol_cur = msubj[perm[mcol_b]]

        # src/fusion/Expr.mbi(3281:15-81)
        while ((mcol_e < mnnz) and (msubj[perm[mcol_e]] == rcol_cur)):
          mcol_e += 1
        ei = erow_b

        mi = mcol_b

        subjtmp_i = subj_i

        n = 0

        # src/fusion/Expr.mbi(3287:15-3301:17)
        while ((ei < erow_e) and (mi < mcol_e)):
          if   ((einst[ei] % edimj) < msubi[perm[mi]]):
            ei += 1
          elif ((einst[ei] % edimj) > msubi[perm[mi]]):
            mi += 1
          else:
            c = mcof[perm[mi]]

            # src/fusion/Expr.mbi(3293:19-3299:19)
            for i in xrange(eptrb[ei],eptrb[(ei + 1)]):
              # { @ src/fusion/Expr.mbi(3294:19-3299:19)
              subj[subjtmp_i] = esubj[i]
              cof[subjtmp_i] = (c * ecof[i])
              subjtmp_i += 1
              n += 1
              # } @ src/fusion/Expr.mbi(3294:19-3299:19)
            ei += 1
            mi += 1
        if   (n > 0):
          subj_i = subjtmp_i
          ptrb[(ptrb_i + 1)] = subjtmp_i
          inst[ptrb_i] = ((long(erow_cur) * rdimj) + rcol_cur)
          ptrb_i += 1
        mcol_b = mcol_e
      erow_b = erow_e
    # } @ src/fusion/Expr.mbi(3268:9-3314:9)
    if   (ebfix != None):
      bfix = ([ 0.0 for _autovar_328 in xrange(rnnz) ])
      bfix_i = 0

      # src/fusion/Expr.mbi(3321:11-3357:11)
      erow_b = 0

      while (erow_b < ennz):
        erow_e = erow_b

        erow_cur = (einst[erow_b] / edimj)

        # src/fusion/Expr.mbi(3325:13-87)
        while ((erow_e < int(len(einst))) and (erow_cur == (einst[erow_e] / edimj))):
          erow_e += 1
        # src/fusion/Expr.mbi(3327:13-3355:13)
        mcol_b = 0

        while (mcol_b < mnnz):
          mcol_e = mcol_b

          rcol_cur = msubj[perm[mcol_b]]

          # src/fusion/Expr.mbi(3331:15-81)
          while ((mcol_e < mnnz) and (msubj[perm[mcol_e]] == rcol_cur)):
            mcol_e += 1
          ei = erow_b

          mi = mcol_b

          nent = 0

          bfix_entry = 0.0

          # src/fusion/Expr.mbi(3338:15-3346:17)
          while ((ei < erow_e) and (mi < mcol_e)):
            if   ((einst[ei] % edimj) < msubi[perm[mi]]):
              ei += 1
            elif ((einst[ei] % edimj) > msubi[perm[mi]]):
              mi += 1
            else:
              bfix_entry = (bfix_entry + (ebfix[ei] * mcof[perm[mi]]))
              nent += 1
              ei += 1
              mi += 1
          if   (nent > 0):
            bfix[bfix_i] = bfix_entry
            bfix_i += 1
          mcol_b = mcol_e
        erow_b = erow_e
    if   (int(len(inst)) == (rdimi * rdimj)):
      inst = None
    res = mosek.fusion.Expr(ptrb,x,subj,cof,bfix,rshape,inst)
    return res
  @staticmethod
  def _matchargs_mul_1SMatrix_12DSExpr__3L_3L_3F_3F_3LOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3I_3I_3FII(args):
    if len(args) != 14:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if args[5] is not None and not isinstance(args[5],mosek.fusion.Variable): return False
    if args[6] is not None and not isinstance(args[6],mosek.fusion.Set): return False
    if not isinstance(args[7],int): return False
    if not isinstance(args[8],int): return False
    a = args[9]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[10]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[11]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[12],int): return False
    if not isinstance(args[13],int): return False
    return True
  # origin: src/fusion/Expr.mbi(3371:16-3549:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul_SMatrix_2DSExpr([long],[long],[float],[float],[long],mosek.fusion.Variable,mosek.fusion.Set,int,int,[int],[int],[float],int,int)")
  def __mul_1SMatrix_12DSExpr__3L_3L_3F_3F_3LOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3I_3I_3FII(eptrb,esubj,ecof,ebfix,einst,x,rshape,edimi,edimj,msubi,msubj,mcof,mdimi,mdimj):
    res = None

    exprsubi = ([ 0 for _autovar_329 in xrange(int(len(einst))) ])

    exprsubj = ([ 0 for _autovar_330 in xrange(int(len(einst))) ])

    perm = ( Utils.Tools._range_LL (0l,long(len(einst))) )

    mnnz = int(len(msubi))

    ennz = int(len(einst))

    rdimi = mdimi

    rdimj = edimj

    # src/fusion/Expr.mbi(3398:9-3402:9)
    for i in xrange(0,int(len(einst))):
      # { @ src/fusion/Expr.mbi(3399:9-3402:9)
      exprsubi[i] = int((einst[i] / edimj))
      exprsubj[i] = int((einst[i] % edimj))
      # } @ src/fusion/Expr.mbi(3399:9-3402:9)
    ( CommonTools._argQsort__3L_3I_3ILL (perm,exprsubj,exprsubi,0l,long(len(einst))) )
    rnnz = 0

    rnelm = 0l

    # { @ src/fusion/Expr.mbi(3409:9-3444:9)
    # src/fusion/Expr.mbi(3410:11-3443:11)
    row_i = 0

    while (row_i < mnnz):
      row_cur = msubi[row_i]

      row_e = (row_i + 1)

      # src/fusion/Expr.mbi(3414:13-70)
      while ((row_e < mnnz) and (row_cur == msubi[row_e])):
        row_e += 1
      # src/fusion/Expr.mbi(3416:13-3440:13)
      col_i = 0

      while (col_i < ennz):
        col_cur = exprsubj[perm[col_i]]

        col_e = (col_i + 1)

        # src/fusion/Expr.mbi(3420:15-81)
        while ((col_e < ennz) and (exprsubj[perm[col_e]] == col_cur)):
          col_e += 1
        rnelm_tmp = rnelm

        n = 0

        ri = row_i

        ci = col_i

        # src/fusion/Expr.mbi(3424:15-3431:17)
        while ((ri < row_e) and (ci < col_e)):
          if   (msubj[ri] < exprsubi[perm[ci]]):
            ri += 1
          elif (msubj[ri] > exprsubi[perm[ci]]):
            ci += 1
          else:
            rnelm_tmp = (rnelm_tmp + (eptrb[(perm[ci] + 1)] - eptrb[perm[ci]]))
            ri += 1
            ci += 1
            n += 1
        if   (n > 0):
          rnnz += 1
          rnelm = rnelm_tmp
        col_i = col_e
      row_i = row_e
    # } @ src/fusion/Expr.mbi(3409:9-3444:9)
    inst = ([ 0l for _autovar_331 in xrange(rnnz) ])

    ptrb = ([ 0l for _autovar_332 in xrange((rnnz + 1)) ])

    subj = ([ 0l for _autovar_333 in xrange(rnelm) ])

    cof = ([ 0.0 for _autovar_334 in xrange(rnelm) ])

    bfix = None

    # { @ src/fusion/Expr.mbi(3453:9-3499:9)
    ptrb_i = 0

    subj_i = 0l

    # src/fusion/Expr.mbi(3457:11-3498:11)
    row_i = 0

    while (row_i < mnnz):
      row_cur = msubi[row_i]

      row_e = (row_i + 1)

      # src/fusion/Expr.mbi(3461:13-70)
      while ((row_e < mnnz) and (row_cur == msubi[row_e])):
        row_e += 1
      # src/fusion/Expr.mbi(3463:13-3495:13)
      col_i = 0

      while (col_i < ennz):
        col_cur = exprsubj[perm[col_i]]

        col_e = (col_i + 1)

        # src/fusion/Expr.mbi(3467:15-81)
        while ((col_e < ennz) and (exprsubj[perm[col_e]] == col_cur)):
          col_e += 1
        subji_tmp = subj_i

        n = 0

        ri = row_i

        ci = col_i

        # src/fusion/Expr.mbi(3471:15-3484:17)
        while ((ri < row_e) and (ci < col_e)):
          if   (msubj[ri] < exprsubi[perm[ci]]):
            ri += 1
          elif (msubj[ri] > exprsubi[perm[ci]]):
            ci += 1
          else:
            n += 1
            # src/fusion/Expr.mbi(3477:19-3482:19)
            for l in xrange(eptrb[perm[ci]],eptrb[(perm[ci] + 1)]):
              # { @ src/fusion/Expr.mbi(3478:19-3482:19)
              subj[subji_tmp] = esubj[l]
              cof[subji_tmp] = (ecof[l] * mcof[ri])
              subji_tmp += 1
              # } @ src/fusion/Expr.mbi(3478:19-3482:19)
            ri += 1
            ci += 1
        if   (n > 0):
          inst[ptrb_i] = ((long(row_cur) * edimj) + long(col_cur))
          ptrb[(ptrb_i + 1)] = subji_tmp
          ptrb_i += 1
          subj_i = subji_tmp
        col_i = col_e
      row_i = row_e
    # } @ src/fusion/Expr.mbi(3453:9-3499:9)
    if   (ebfix != None):
      bfix = ([ 0.0 for _autovar_335 in xrange(rnnz) ])
      bfix_i = 0

      # src/fusion/Expr.mbi(3507:11-3540:11)
      row_i = 0

      while (row_i < mnnz):
        row_cur = msubi[row_i]

        row_e = (row_i + 1)

        # src/fusion/Expr.mbi(3511:13-70)
        while ((row_e < mnnz) and (row_cur == msubi[row_e])):
          row_e += 1
        # src/fusion/Expr.mbi(3513:13-3537:13)
        col_i = 0

        while (col_i < ennz):
          col_cur = exprsubj[perm[col_i]]

          col_e = (col_i + 1)

          # src/fusion/Expr.mbi(3517:15-81)
          while ((col_e < ennz) and (exprsubj[perm[col_e]] == col_cur)):
            col_e += 1
          n = 0

          bfix_entry = 0.0

          ri = row_i

          ci = col_i

          # src/fusion/Expr.mbi(3521:15-3528:17)
          while ((ri < row_e) and (ci < col_e)):
            if   (msubj[ri] < exprsubi[perm[ci]]):
              ri += 1
            elif (msubj[ri] > exprsubi[perm[ci]]):
              ci += 1
            else:
              bfix_entry = (bfix_entry + (ebfix[perm[ci]] * mcof[ri]))
              n += 1
              ri += 1
              ci += 1
          if   (n > 0):
            bfix[bfix_i] = bfix_entry
            bfix_i += 1
          col_i = col_e
        row_i = row_e
    if   (int(len(inst)) == (rdimi * rdimj)):
      inst = None
    res = mosek.fusion.Expr(ptrb,x,subj,cof,bfix,rshape,inst)
    return res
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Expression_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(3560:15-3566:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Expression,float)")
  def _mul_Omosek_fusion_Expression_2F(expr,val):
    if   (expr == None):
      raise Exception("Arguments for mul may not be null")
    return ( Expr._mul_FOmosek_fusion_Expression_2 (val,expr) )
  @staticmethod
  def _matchargs_mul_FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(3573:15-3591:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(float,mosek.fusion.Expression)")
  def _mul_FOmosek_fusion_Expression_2(val,expr):
    if   (expr == None):
      raise Exception("Arguments for mul may not be null")
    fe = ( expr._eval_() )

    # src/fusion/Expr.mbi(3579:9-65)
    for i in xrange(0,int(len(fe.cof))):
      fe.cof[i] = (fe.cof[i] * val)
    if   (fe.bfix != None):
      # src/fusion/Expr.mbi(3581:11-70)
      for i in xrange(0,int(len(fe.bfix))):
        fe.bfix[i] = (fe.bfix[i] * val)
    return mosek.fusion.Expr(fe.ptrb,fe.x,fe.subj,fe.cof,fe.bfix,fe.shape,fe.inst,1)
  @staticmethod
  def _matchargs_mul__3FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(3606:15-3678:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul([float],mosek.fusion.Expression)")
  def _mul__3FOmosek_fusion_Expression_2(vals,expr):
    if   ((vals == None) or (expr == None)):
      raise Exception("Arguments for mul may not be null")
    mdimi = 1

    mdimj = int(len(vals))

    res = None

    fe = ( expr._eval_() )



    if   ((fe.shape.nd == 1) and (( fe.shape._dim_I(0) ) == 1)):
      res = ( Expr.__mul_10DExpr_1Matrix__3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Matrix_2 (fe.subj,fe.cof,fe.bfix,fe.x,mosek.fusion.DenseMatrix(1,int(len(vals)),vals)) )
    else:
      rshape = None

      if   (fe.shape.nd == 1):
        edimj = 1
        edimi = ( fe.shape._dim_I(0) )
        rshape = mosek.fusion.IntSet(1)
      elif (fe.shape.nd == 2):
        rshape = mosek.fusion.IntSet(( fe.shape._dim_I(1) ))
        edimi = ( fe.shape._dim_I(0) )
        edimj = ( fe.shape._dim_I(1) )
      else:
        raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
      if   (edimi != mdimj):
        raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
      if   (fe.inst == None):
        res = ( Expr.__mul_1DMatrix_12DDExpr__3L_3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3FII (fe.ptrb,fe.subj,fe.cof,fe.bfix,fe.x,rshape,edimi,edimj,vals,mdimi,mdimj) )
      else:
        res = ( Expr.__mul_1SMatrix_12DSExpr__3L_3L_3F_3F_3LOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3I_3I_3FII (fe.ptrb,fe.subj,fe.cof,fe.bfix,fe.inst,fe.x,rshape,edimi,edimj,( Utils.Tools._makevector_II (0,mdimj) ),( Utils.Tools._range_II (0,mdimj) ),vals,mdimi,mdimj) )
    return res
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Expression_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(3681:15-3756:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Expression,[float])")
  def _mul_Omosek_fusion_Expression_2_3F(expr,vals):
    if   ((vals == None) or (expr == None)):
      raise Exception("Arguments for mul may not be null")
    res = None

    mdimi = int(len(vals))

    mdimj = 1

    fe = ( expr._eval_() )



    if   ((fe.shape.nd == 1) and (( fe.shape._dim_I(0) ) == 1)):
      res = ( Expr.__mul_10DExpr_1Matrix__3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Matrix_2 (fe.subj,fe.cof,fe.bfix,fe.x,mosek.fusion.DenseMatrix(int(len(vals)),1,vals)) )
    else:
      rshape = None

      if   (fe.shape.nd == 1):
        rshape = mosek.fusion.IntSet(1)
        edimj = ( fe.shape._dim_I(0) )
        edimi = 1
      elif (( fe.shape._realnd_() ) == 2):
        rshape = mosek.fusion.IntSet(( fe.shape._dim_I(0) ))
        edimi = ( fe.shape._dim_I(0) )
        edimj = ( fe.shape._dim_I(1) )
      else:
        raise mosek.fusion.DimensionError("Expression operand must be one- or two-dimensional")
      if   (edimj != mdimi):
        raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
      if   (fe.inst == None):
        res = ( Expr.__mul_12DDExpr_1DMatrix__3L_3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3FII (fe.ptrb,fe.subj,fe.cof,fe.bfix,fe.x,rshape,edimi,edimj,vals,mdimi,mdimj) )
      else:
        res = ( Expr.__mul_12DSExpr_1SMatrix__3L_3L_3F_3F_3LOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3I_3I_3FII (fe.ptrb,fe.subj,fe.cof,fe.bfix,fe.inst,fe.x,rshape,edimi,edimj,( Utils.Tools._range_II (0,mdimi) ),( Utils.Tools._makevector_II (0,mdimi) ),vals,mdimi,mdimj) )
    return res
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(3760:15-3815:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Expression,mosek.fusion.Matrix)")
  def _mul_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(e,mx):
    if   ((mx == None) or (e == None)):
      raise Exception("Arguments for mul may not be null")
    res = None

    fe = ( e._eval_() )

    mdimi = ( mx._numRows_() )

    mdimj = ( mx._numColumns_() )

    if   ((fe.shape.nd == 1) and (( fe.shape._dim_I(0) ) == 1)):
      res = ( Expr.__mul_10DExpr_1Matrix__3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Matrix_2 (fe.subj,fe.cof,fe.bfix,fe.x,mx) )
    else:
      rshape = None



      if   ((fe.shape.nd == 1) and (( fe.shape._dim_I(0) ) == mdimi)):
        edimi = 1
        edimj = ( fe.shape._dim_I(0) )
        rshape = mosek.fusion.IntSet(mdimj)
      elif ((fe.shape.nd == 2) and (( fe.shape._dim_I(1) ) == mdimi)):
        edimi = ( fe.shape._dim_I(0) )
        edimj = ( fe.shape._dim_I(1) )
        rshape = mosek.fusion.NDSet(edimi,mdimj)
      else:
        raise mosek.fusion.DimensionError("Expression operand must be one- or two-dimensional, and dimensions must match for multiplication")
      if   ((fe.inst == None) and (not ( mx._isSparse_() ))):
        res = ( Expr.__mul_12DDExpr_1DMatrix__3L_3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3FII (fe.ptrb,fe.subj,fe.cof,fe.bfix,fe.x,rshape,edimi,edimj,( mx._getDataAsArray_() ),mdimi,mdimj) )
      else:
        mnnz = ( mx._numNonzeros_() )

        msubi = ([ 0 for _autovar_336 in xrange(mnnz) ])

        msubj = ([ 0 for _autovar_337 in xrange(mnnz) ])

        mcof = ([ 0.0 for _autovar_338 in xrange(mnnz) ])

        ( mx._getDataAsTriplets__3I_3I_3F(msubi,msubj,mcof) )
        einst = fe.inst

        if   (einst == None):
          einst = ( Utils.Tools._range_LL (0l,(long(len(fe.ptrb)) - 1)) )
        res = ( Expr.__mul_12DSExpr_1SMatrix__3L_3L_3F_3F_3LOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3I_3I_3FII (fe.ptrb,fe.subj,fe.cof,fe.bfix,fe.inst,fe.x,rshape,edimi,edimj,msubi,msubj,mcof,mdimi,mdimj) )
    return res
  @staticmethod
  def _matchargs_mul_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(3818:15-3871:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul(mosek.fusion.Matrix,mosek.fusion.Expression)")
  def _mul_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(mx,e):
    if   ((mx == None) or (e == None)):
      raise Exception("Arguments for mul may not be null")
    res = None

    fe = ( e._eval_() )

    mdimi = ( mx._numRows_() )

    mdimj = ( mx._numColumns_() )

    rshape = None

    if   ((fe.shape.nd == 1) and (( fe.shape._dim_I(0) ) == 1)):
      res = ( Expr.__mul_10DExpr_1Matrix__3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Matrix_2 (fe.subj,fe.cof,fe.bfix,fe.x,mx) )
    else:


      if   ((fe.shape.nd == 1) and (( fe.shape._dim_I(0) ) == mdimj)):
        edimj = 1
        edimi = ( fe.shape._dim_I(0) )
        rshape = mosek.fusion.IntSet(mdimi)
      elif ((fe.shape.nd == 2) and (( fe.shape._dim_I(0) ) == mdimj)):
        edimi = ( fe.shape._dim_I(0) )
        edimj = ( fe.shape._dim_I(1) )
        rshape = mosek.fusion.NDSet(mdimi,edimj)
      else:
        raise mosek.fusion.DimensionError("Expression operand must be one- or two-dimensional, and dimensions must match for multiplication")
      if   ((fe.inst == None) and (not ( mx._isSparse_() ))):
        res = ( Expr.__mul_1DMatrix_12DDExpr__3L_3L_3F_3FOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3FII (fe.ptrb,fe.subj,fe.cof,fe.bfix,fe.x,rshape,edimi,edimj,( mx._getDataAsArray_() ),mdimi,mdimj) )
      else:
        mnnz = ( mx._numNonzeros_() )

        msubi = ([ 0 for _autovar_339 in xrange(mnnz) ])

        msubj = ([ 0 for _autovar_340 in xrange(mnnz) ])

        mcof = ([ 0.0 for _autovar_341 in xrange(mnnz) ])

        ( mx._getDataAsTriplets__3I_3I_3F(msubi,msubj,mcof) )
        einst = fe.inst

        if   (einst == None):
          einst = ( Utils.Tools._range_LL (0l,(long(len(fe.ptrb)) - 1)) )
        res = ( Expr.__mul_1SMatrix_12DSExpr__3L_3L_3F_3F_3LOmosek_fusion_Variable_2Omosek_fusion_Set_2II_3I_3I_3FII (fe.ptrb,fe.subj,fe.cof,fe.bfix,einst,fe.x,rshape,edimi,edimj,msubi,msubj,mcof,mdimi,mdimj) )
    return res
  @staticmethod
  def _matchargs_mulElm__3_3FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(3880:15-3885:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm([[float]],mosek.fusion.Variable)")
  def _mulElm__3_3FOmosek_fusion_Variable_2(mx,v):
    if   ((mx == None) or (v == None)):
      raise Exception("Arguments for mulElm may not be null")
    return ( Expr._mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2 (mosek.fusion.DenseMatrix(mx),v) )
  @staticmethod
  def _matchargs_mulElm_Omosek_fusion_Variable_2_3_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(3888:15-3893:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm(mosek.fusion.Variable,[[float]])")
  def _mulElm_Omosek_fusion_Variable_2_3_3F(v,mx):
    if   ((mx == None) or (v == None)):
      raise Exception("Arguments for mulElm may not be null")
    return ( Expr._mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2 (mosek.fusion.DenseMatrix(mx),v) )
  @staticmethod
  def _matchargs_mulElm_Omosek_fusion_Variable_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(3896:15-3901:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm(mosek.fusion.Variable,[float])")
  def _mulElm_Omosek_fusion_Variable_2_3F(v,a):
    if   ((a == None) or (v == None)):
      raise Exception("Arguments for mulElm may not be null")
    return ( Expr._mulElm__3FOmosek_fusion_Variable_2 (a,v) )
  @staticmethod
  def _matchargs_mulElm__3FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(3903:15-3920:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm([float],mosek.fusion.Variable)")
  def _mulElm__3FOmosek_fusion_Variable_2(a,v):
    if   ((a == None) or (v == None)):
      raise Exception("Arguments for mulElm may not be null")
    rshape = v.shape

    if   (v.shape.nd != 1):
      raise mosek.fusion.DimensionError("Variable and vector must have same dimension")
    else:
      if   (( v.shape._dim_I(0) ) != int(len(a))):
        raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    return mosek.fusion.Expr(( Utils.Tools._range_LL (0l,(long(len(a)) + 1)) ),v,( Utils.Tools._range_LL (0l,long(len(a))) ),a,None,rshape,None)
  @staticmethod
  def _matchargs_mulElm_Omosek_fusion_Expression_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(3923:15-3928:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm(mosek.fusion.Expression,[float])")
  def _mulElm_Omosek_fusion_Expression_2_3F(e,a):
    if   ((e == None) or (a == None)):
      raise Exception("Arguments for mulElm may not be null")
    return ( Expr._mulElm__3FOmosek_fusion_Expression_2 (a,e) )
  @staticmethod
  def _matchargs_mulElm__3FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(3931:15-3974:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm([float],mosek.fusion.Expression)")
  def _mulElm__3FOmosek_fusion_Expression_2(a,e):
    if   ((a == None) or (e == None)):
      raise Exception("Arguments for mulElm may not be null")
    rshape = e._shape

    if   (e._shape.nd != 1):
      raise mosek.fusion.DimensionError("Expression and vector must have same dimension")
    else:
      if   (( e._shape._dim_I(0) ) != int(len(a))):
        raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    fe = ( e._eval_() )

    cof = ([ 0.0 for _autovar_342 in xrange(int(len(fe.cof))) ])

    if   (fe.inst == None):
      # src/fusion/Expr.mbi(3944:11-3946:40)
      for i in xrange(0,(int(len(fe.ptrb)) - 1)):
        # src/fusion/Expr.mbi(3945:13-3946:40)
        for k in xrange(fe.ptrb[i],fe.ptrb[(i + 1)]):
          cof[k] = (fe.cof[k] * a[i])
    else:
      # src/fusion/Expr.mbi(3948:11-3950:49)
      for i in xrange(0,int(len(fe.inst))):
        # src/fusion/Expr.mbi(3949:13-3950:49)
        for k in xrange(fe.ptrb[i],fe.ptrb[(i + 1)]):
          cof[k] = (fe.cof[k] * a[fe.inst[i]])
    bfix = None

    if   (fe.bfix != None):
      bfix = ([ 0.0 for _autovar_343 in xrange(int(len(fe.cof))) ])
      if   (fe.inst == None):
        # src/fusion/Expr.mbi(3957:13-3959:44)
        for i in xrange(0,int(len(fe.bfix))):
          # src/fusion/Expr.mbi(3958:15-3959:44)
          for k in xrange(fe.ptrb[i],fe.ptrb[(i + 1)]):
            bfix[k] = (fe.bfix[k] * a[i])
      else:
        # src/fusion/Expr.mbi(3961:13-3963:52)
        for i in xrange(0,int(len(fe.inst))):
          # src/fusion/Expr.mbi(3962:15-3963:52)
          for k in xrange(fe.ptrb[i],fe.ptrb[(i + 1)]):
            cof[k] = (fe.bfix[k] * a[fe.inst[i]])
    return mosek.fusion.Expr(fe.ptrb,fe.x,fe.subj,cof,bfix,fe.shape,fe.inst)
  @staticmethod
  def _matchargs_mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(3978:15-4014:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm(mosek.fusion.Matrix,mosek.fusion.Variable)")
  def _mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(mx,v):
    if   ((mx == None) or (v == None)):
      raise Exception("Arguments for mulElm may not be null")
    lhs = mx

    rhs = v

    shape = rhs.shape

    if   (shape.nd != 2):
      raise mosek.fusion.DimensionError("Variable and matrix must have same dimension")
    else:
      if   ((( shape._dim_I(0) ) != lhs._dimi) or (( shape._dim_I(1) ) != lhs._dimj)):
        raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    _autovar_344 = lhs
    if   isinstance(_autovar_344,mosek.fusion.DenseMatrix):
      m = _autovar_344
      ptrb = ( Utils.Tools._range_LL (0l,long(((m._dimi * m._dimj) + 1))) )

      subj = ( Utils.Tools._range_LL (0l,long((m._dimi * m._dimj))) )

      return mosek.fusion.Expr(ptrb,rhs,subj,m._data,None,shape,None)
    else:
      m = _autovar_344
      nnz = ( m._numNonzeros_() )

      subi_ = ([ 0 for _autovar_345 in xrange(nnz) ])

      subj_ = ([ 0 for _autovar_346 in xrange(nnz) ])

      val_ = ([ 0.0 for _autovar_347 in xrange(nnz) ])

      ptrb = ( Utils.Tools._range_LL (0l,(nnz + 1)) )

      inst = ([ 0l for _autovar_348 in xrange(nnz) ])

      ( m._getDataAsTriplets__3I_3I_3F(subi_,subj_,val_) )
      # src/fusion/Expr.mbi(4009:11-4010:59)
      for i in xrange(0l,nnz):
        inst[i] = long(((subi_[i] * m._dimj) + subj_[i]))
      return mosek.fusion.Expr(ptrb,rhs,inst,val_,None,shape,inst)
  @staticmethod
  def _matchargs_mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(4017:15-4210:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm(mosek.fusion.Matrix,mosek.fusion.Expression)")
  def _mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(mx,expr):
    if   ((mx == None) or (expr == None)):
      raise Exception("Arguments for mulElm may not be null")
    lhs = mx

    rhs = expr

    shape = rhs._shape

    if   (shape.nd != 2):
      raise mosek.fusion.DimensionError("Variable and matrix must have same dimension")
    else:
      if   ((( shape._dim_I(0) ) != lhs._dimi) or (( shape._dim_I(1) ) != lhs._dimj)):
        raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    fe = ( rhs._eval_() )

    if   (fe.inst == None):
      _autovar_349 = lhs
      if   isinstance(_autovar_349,mosek.fusion.DenseMatrix):
        m = _autovar_349
        nnz = ( m._numNonzeros_() )

        ptrb = fe.ptrb

        # src/fusion/Expr.mbi(4037:13-4041:13)
        i = 0l

        while (i < nnz):
          # src/fusion/Expr.mbi(4039:15-4040:50)
          k = ptrb[i]

          while (k < ptrb[(i + 1)]):
            fe.cof[k] = (fe.cof[k] * m._data[i])
            k += 1
          i += 1
        if   (fe.bfix != None):
          # src/fusion/Expr.mbi(4044:15-4045:52)
          i = 0l

          while (i < nnz):
            fe.bfix[i] = (fe.bfix[i] * m._data[i])
            i += 1
        return mosek.fusion.Expr(ptrb,fe.x,fe.subj,fe.cof,fe.bfix,shape,None,1)
      else:
        m = _autovar_349
        nnz = ( m._numNonzeros_() )

        msubi = ([ 0 for _autovar_350 in xrange(nnz) ])

        msubj = ([ 0 for _autovar_351 in xrange(nnz) ])

        mcof = ([ 0.0 for _autovar_352 in xrange(nnz) ])

        # { @ src/fusion/Expr.mbi(4055:13-4071:13)
        subi = ([ 0 for _autovar_353 in xrange(nnz) ])

        subj_ = ([ 0 for _autovar_354 in xrange(nnz) ])

        val = ([ 0.0 for _autovar_355 in xrange(nnz) ])

        ( m._getDataAsTriplets__3I_3I_3F(subi,subj_,val) )
        perm = ([ 0l for _autovar_356 in xrange(nnz) ])

        # src/fusion/Expr.mbi(4062:36-78)
        k = 0l

        while (k < nnz):
          perm[k] = k
          k += 1
        ( Sort._argsort__3L_3I_3I (perm,subi,subj_) )
        # src/fusion/Expr.mbi(4065:15-4070:15)
        k = 0l

        while (k < nnz):
          msubi[k] = subi[perm[k]]
          msubj[k] = subj_[perm[k]]
          mcof[k] = val[perm[k]]
          k += 1
        # } @ src/fusion/Expr.mbi(4055:13-4071:13)
        numexpnz = long(nnz)

        numnz = 0l

        # src/fusion/Expr.mbi(4076:13-4080:13)
        i = 0

        while (i < nnz):
          lidx = long(((msubi[i] * m._dimj) + msubj[i]))

          numnz = (numnz + (fe.ptrb[(lidx + 1l)] - fe.ptrb[lidx]))
          i += 1
        # { @ src/fusion/Expr.mbi(4082:13-4106:13)
        ptrb = ([ 0l for _autovar_357 in xrange((numexpnz + 1)) ])

        ptrb[0] = 0l

        if   (fe.bfix == None):
          bfix = None
        else:
          bfix = ([ 0.0 for _autovar_358 in xrange(numexpnz) ])
        subj_ = ([ 0l for _autovar_359 in xrange(numnz) ])

        cof = ([ 0.0 for _autovar_360 in xrange(numnz) ])

        inst = ([ 0l for _autovar_361 in xrange(numexpnz) ])

        # src/fusion/Expr.mbi(4089:15-4103:15)
        for i in xrange(0,int(nnz)):
          # { @ src/fusion/Expr.mbi(4090:15-4103:15)
          lidx = long(((msubi[i] * m._dimj) + msubj[i]))

          l = (fe.ptrb[(lidx + 1)] - fe.ptrb[lidx])

          ptrb[(i + 1)] = (ptrb[i] + l)
          # src/fusion/Expr.mbi(4095:17-4099:17)
          for j in xrange(0l,l):
            # { @ src/fusion/Expr.mbi(4096:17-4099:17)
            subj_[(ptrb[i] + j)] = fe.subj[(fe.ptrb[lidx] + j)]
            cof[(ptrb[i] + j)] = (fe.cof[(fe.ptrb[lidx] + j)] * mcof[i])
            # } @ src/fusion/Expr.mbi(4096:17-4099:17)
          if   (fe.bfix != None):
            bfix[i] = (fe.bfix[lidx] * mcof[i])
          inst[i] = lidx
          # } @ src/fusion/Expr.mbi(4090:15-4103:15)
        return mosek.fusion.Expr(ptrb,fe.x,subj_,cof,bfix,shape,inst)
        # } @ src/fusion/Expr.mbi(4082:13-4106:13)
    else:
      _autovar_362 = lhs
      if   isinstance(_autovar_362,mosek.fusion.DenseMatrix):
        m = _autovar_362
        ptrb = fe.ptrb

        subj_ = fe.subj

        cof = fe.cof

        bfix = fe.bfix

        # src/fusion/Expr.mbi(4118:13-4123:13)
        i = 0l

        while (i < fe.nnz):
          idx = fe.inst[i]

          # src/fusion/Expr.mbi(4121:15-4122:59)
          k = fe.ptrb[i]

          while (k < fe.ptrb[(i + 1)]):
            fe.cof[k] = (fe.cof[k] * m._data[fe.inst[i]])
            k += 1
          i += 1
        if   (fe.bfix != None):
          # src/fusion/Expr.mbi(4126:15-4127:61)
          i = 0l

          while (i < fe.nnz):
            fe.bfix[i] = (fe.bfix[i] * m._data[fe.inst[i]])
            i += 1
        return mosek.fusion.Expr(fe.ptrb,fe.x,fe.subj,fe.cof,fe.bfix,shape,fe.inst,1)
      else:
        m = _autovar_362
        mnnz = ( m._numNonzeros_() )

        msubi = ([ 0 for _autovar_363 in xrange(mnnz) ])

        msubj = ([ 0 for _autovar_364 in xrange(mnnz) ])

        mcof = ([ 0.0 for _autovar_365 in xrange(mnnz) ])

        # { @ src/fusion/Expr.mbi(4137:13-4153:13)
        subi = ([ 0 for _autovar_366 in xrange(mnnz) ])

        subj_ = ([ 0 for _autovar_367 in xrange(mnnz) ])

        val = ([ 0.0 for _autovar_368 in xrange(mnnz) ])

        ( m._getDataAsTriplets__3I_3I_3F(subi,subj_,val) )
        perm = ([ 0l for _autovar_369 in xrange(mnnz) ])

        # src/fusion/Expr.mbi(4144:37-80)
        k = 0l

        while (k < mnnz):
          perm[k] = k
          k += 1
        ( Sort._argsort__3L_3I_3I (perm,subj_,subi) )
        # src/fusion/Expr.mbi(4147:15-4152:15)
        k = 0l

        while (k < mnnz):
          msubi[k] = subi[perm[k]]
          msubj[k] = subj_[perm[k]]
          mcof[k] = val[perm[k]]
          k += 1
        # } @ src/fusion/Expr.mbi(4137:13-4153:13)
        numexpnz = 0l

        numnz = 0l

        # src/fusion/Expr.mbi(4160:13-4173:13)
        i = 0

        j = 0

        while (i < mnnz):
          lidx = ((msubi[i] * m._dimj) + msubj[i])

          if   (lidx < fe.inst[j]):
            i += 1
          elif (lidx > fe.inst[j]):
            j += 1
          else:
            numexpnz = ((numexpnz + fe.ptrb[(j + 1)]) - fe.ptrb[j])
            numnz += 1
            i += 1
            j += 1
        # { @ src/fusion/Expr.mbi(4174:13-4207:13)
        ptrb = ([ 0l for _autovar_370 in xrange((numexpnz + 1)) ])

        ptrb[0] = 0l

        if   (fe.bfix == None):
          bfix = None
        else:
          bfix = ([ 0.0 for _autovar_371 in xrange(numexpnz) ])
        subj_ = ([ 0l for _autovar_372 in xrange(numnz) ])

        cof = ([ 0.0 for _autovar_373 in xrange(numnz) ])

        inst = ([ 0l for _autovar_374 in xrange(numnz) ])

        # src/fusion/Expr.mbi(4181:15-4204:15)
        i = 0

        j = 0

        k = 0

        while (i < mnnz):
          lidx = long(((msubi[i] * m._dimj) + msubj[i]))

          if   (lidx < fe.inst[j]):
            i += 1
          elif (lidx > fe.inst[j]):
            j += 1
          else:
            l = (fe.ptrb[(j + 1)] - fe.ptrb[j])

            b = ptrb[k]

            ptrb[(k + 1)] = (b + l)
            # src/fusion/Expr.mbi(4193:19-4197:19)
            p = 0

            while (p < l):
              subj_[(b + l)] = fe.subj[(fe.ptrb[j] + l)]
              cof[(b + l)] = (fe.cof[(fe.ptrb[j] + l)] * mcof[i])
              p += 1
            inst[k] = lidx
            if   (bfix != None):
              bfix[k] = (fe.bfix[k] * mcof[i])
            i += 1
            j += 1
            k += 1
        return mosek.fusion.Expr(ptrb,fe.x,subj_,cof,bfix,shape,inst,1)
        # } @ src/fusion/Expr.mbi(4174:13-4207:13)
  @staticmethod
  def _matchargs_mulElm_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(4213:15-4218:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm(mosek.fusion.Expression,mosek.fusion.Matrix)")
  def _mulElm_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(expr,mx):
    if   ((mx == None) or (expr == None)):
      raise Exception("Arguments for mulElm may not be null")
    return ( Expr._mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2 (mx,expr) )
  @staticmethod
  def _matchargs_mulElm_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(4221:15-4226:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulElm(mosek.fusion.Variable,mosek.fusion.Matrix)")
  def _mulElm_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(v,mx):
    if   ((mx == None) or (v == None)):
      raise Exception("Arguments for mulElm may not be null")
    return ( Expr._mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2 (mx,v) )
  @staticmethod
  def _matchargs_mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(4240:15-4499:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulDiag(mosek.fusion.Matrix,mosek.fusion.Expression)")
  def _mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(mx,expr):
    if   ((mx == None) or (expr == None)):
      raise Exception("Arguments for mulDiag may not be null")
    rhs = mx

    lhs = expr


    e = ( lhs._eval_() )

    if   (e.shape.nd != 2):
      raise mosek.fusion.DimensionError("Expression operand must have 2 dimensions")
    if   ((( e.shape._dim_I(0) ) != rhs._dimj) or (( e.shape._dim_I(1) ) != rhs._dimi)):
      raise mosek.fusion.DimensionError("Mismatching operand dimensions")
    edi = ( e.shape._dim_I(0) )

    edj = ( e.shape._dim_I(1) )

    _autovar_375 = rhs
    if   isinstance(_autovar_375,mosek.fusion.DenseMatrix):
      m = _autovar_375
      if   (e.inst == None):
        numEntries = m._dimi

        ptrb = ([ 0l for _autovar_376 in xrange((numEntries + 1)) ])

        subj_ = ([ 0l for _autovar_377 in xrange(e.nnz) ])

        cof = ([ 0.0 for _autovar_378 in xrange(e.nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_379 in xrange(numEntries) ])
        p = 1

        # { @ src/fusion/Expr.mbi(4269:13-4294:13)
        # src/fusion/Expr.mbi(4270:15-4293:15)
        i = 0

        while (i < m._dimi):
          rhsptridx = i

          ptrb[p] = ptrb[(p - 1)]
          # src/fusion/Expr.mbi(4276:17-4291:17)
          k = 0

          while (k < m._dimj):
            b = e.ptrb[rhsptridx]

            num = (e.ptrb[(rhsptridx + 1)] - b)

            ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,b,subj_,ptrb[p],num) )
            c = m._data[((i * m._dimj) + k)]

            # src/fusion/Expr.mbi(4283:19-4284:54)
            l = 0

            while (l < num):
              cof[(ptrb[p] + l)] = (e.cof[(b + l)] * c)
              l += 1
            if   (bfix != None):
              bfix[(p - 1)] = (bfix[(p - 1)] + (e.bfix[rhsptridx] * c))
            rhsptridx = (rhsptridx + m._dimi)
            ptrb[p] = (ptrb[p] + num)
            k += 1
          p += 1
          i += 1
        # } @ src/fusion/Expr.mbi(4269:13-4294:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj_,cof,bfix,None,None)
      else:
        numEntries = m._dimi

        ptrb = ([ 0l for _autovar_380 in xrange((numEntries + 1)) ])

        subj_ = ([ 0l for _autovar_381 in xrange(e.nnz) ])

        cof = ([ 0.0 for _autovar_382 in xrange(e.nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_383 in xrange(numEntries) ])
        # { @ src/fusion/Expr.mbi(4306:13-4317:13)
        n = int(len(e.inst))

        # src/fusion/Expr.mbi(4308:15-4314:15)
        i = 0

        while (i < n):
          esubi = (e.inst[i] / m._dimi)

          esubj = (e.inst[i] - (esubi * m._dimi))

          ptrb[(esubj + 1)] = (ptrb[(esubj + 1)] + (e.ptrb[(i + 1)] - e.ptrb[i]))
          i += 1
        # src/fusion/Expr.mbi(4315:15-4316:50)
        i = 0

        while (i < m._dimi):
          ptrb[(i + 1)] = (ptrb[(i + 1)] + ptrb[i])
          i += 1
        # } @ src/fusion/Expr.mbi(4306:13-4317:13)
        # { @ src/fusion/Expr.mbi(4319:13-4343:13)
        n = int(len(e.inst))

        # src/fusion/Expr.mbi(4321:15-4338:15)
        i = 0

        while (i < n):
          esubi = (e.inst[i] / edj)

          esubj = (e.inst[i] - (esubi * edj))

          num = (e.ptrb[(i + 1)] - e.ptrb[i])

          ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[i],subj_,ptrb[esubj],num) )
          c = m._data[((esubj * m._dimj) + esubi)]

          # src/fusion/Expr.mbi(4331:17-4332:64)
          l = 0

          while (l < num):
            cof[(ptrb[esubj] + l)] = (e.cof[(e.ptrb[i] + l)] * c)
            l += 1
          if   (bfix != None):
            bfix[esubj] = (bfix[esubj] + (c * e.bfix[i]))
          ptrb[esubj] = (ptrb[esubj] + num)
          i += 1
        # src/fusion/Expr.mbi(4340:15-4341:38)
        i = m._dimi

        while (i > 1):
          ptrb[i] = ptrb[(i - 1)]
          i -= 1
        ptrb[0] = 0l
        # } @ src/fusion/Expr.mbi(4319:13-4343:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj_,cof,bfix,None,None)
    else:
      m = _autovar_375
      if   (e.inst == None):
        mnnz = ( m._numNonzeros_() )

        msubi = ([ 0 for _autovar_384 in xrange(mnnz) ])

        msubj = ([ 0 for _autovar_385 in xrange(mnnz) ])

        mval = ([ 0.0 for _autovar_386 in xrange(mnnz) ])

        ( m._getDataAsTriplets__3I_3I_3F(msubi,msubj,mval) )
        numEntries = 1

        # src/fusion/Expr.mbi(4359:13-91)
        i = 1

        while (i < mnnz):
          if   (msubi[i] > msubi[(i - 1)]):
            numEntries += 1
          i += 1
        ptrb = ([ 0l for _autovar_387 in xrange((numEntries + 1)) ])

        subj_ = ([ 0l for _autovar_388 in xrange(e.nnz) ])

        cof = ([ 0.0 for _autovar_389 in xrange(e.nnz) ])

        shape = None

        inst = None

        if   (numEntries < m._dimi):
          shape = mosek.fusion.IntSet(numEntries)
          inst = ([ 0l for _autovar_390 in xrange(numEntries) ])
        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_391 in xrange(numEntries) ])
        # { @ src/fusion/Expr.mbi(4374:13-4400:13)
        p = 0

        curi = (- 1)

        # src/fusion/Expr.mbi(4377:15-4399:15)
        k = 0

        while (k < mnnz):
          if   (curi < msubi[k]):
            curi = msubi[k]
            if   (inst != None):
              inst[p] = long(msubi[k])
            p += 1
            ptrb[p] = ptrb[(p - 1)]
          rhsptridx = ((msubj[k] * m._dimi) + msubi[k])

          num = (e.ptrb[(rhsptridx + 1)] - e.ptrb[rhsptridx])

          ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[rhsptridx],subj_,ptrb[p],num) )
          # src/fusion/Expr.mbi(4392:17-4393:74)
          l = 0

          while (l < num):
            cof[(ptrb[p] + l)] = (mval[k] * e.cof[(e.ptrb[rhsptridx] + l)])
            l += 1
          if   (bfix != None):
            bfix[(p - 1)] = (bfix[(p - 1)] + (mval[k] * e.bfix[rhsptridx]))
          ptrb[p] = (ptrb[p] + num)
          k += 1
        # } @ src/fusion/Expr.mbi(4374:13-4400:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj_,cof,bfix,shape,inst)
      else:
        mnnz = ( m._numNonzeros_() )

        msubi = ([ 0 for _autovar_392 in xrange(mnnz) ])

        msubj = ([ 0 for _autovar_393 in xrange(mnnz) ])

        mval = ([ 0.0 for _autovar_394 in xrange(mnnz) ])

        ( m._getDataAsTriplets__3I_3I_3F(msubi,msubj,mval) )
        eNEntries = int(len(e.inst))

        esubi = ([ 0 for _autovar_395 in xrange(eNEntries) ])

        esubj = ([ 0 for _autovar_396 in xrange(eNEntries) ])

        # src/fusion/Expr.mbi(4418:13-4422:13)
        k = 0

        while (k < eNEntries):
          esubi[k] = int((e.inst[k] / m._dimi))
          esubj[k] = int((e.inst[k] - long((esubi[k] * m._dimi))))
          k += 1
        perm = ([ 0l for _autovar_397 in xrange(eNEntries) ])

        # src/fusion/Expr.mbi(4423:40-88)
        k = 0l

        while (k < eNEntries):
          perm[k] = k
          k += 1
        ( Sort._argsort__3L_3I_3I (perm,esubj,esubi) )
        numEntries = 0

        numNz = 0l

        # { @ src/fusion/Expr.mbi(4430:13-4449:13)
        i = 0

        j = 0

        previ = (- 1)

        # src/fusion/Expr.mbi(4432:15-4448:15)
        while ((i < mnnz) and (j < e.nnz)):
          if   (msubi[i] < esubj[perm[j]]):
            i += 1
          elif (msubi[i] > esubj[perm[j]]):
            j += 1
          elif (msubj[i] < esubi[perm[j]]):
            i += 1
          elif (msubj[i] > esubi[perm[j]]):
            j += 1
          else:
            if   (previ < msubi[i]):
              previ = msubi[i]
              numEntries += 1
            numNz = (numNz + (e.ptrb[(perm[j] + 1)] - e.ptrb[perm[j]]))
            i += 1
            j += 1
        # } @ src/fusion/Expr.mbi(4430:13-4449:13)
        ptrb = ([ 0l for _autovar_398 in xrange((numEntries + 1)) ])

        subj_ = ([ 0l for _autovar_399 in xrange(numNz) ])

        cof = ([ 0.0 for _autovar_400 in xrange(numNz) ])

        inst = ([ 0l for _autovar_401 in xrange(numEntries) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_402 in xrange(numEntries) ])
        shape = mosek.fusion.IntSet(m._dimi)

        # { @ src/fusion/Expr.mbi(4461:13-4493:13)
        p = 0

        i = 0

        j = 0

        previ = (- 1)

        # src/fusion/Expr.mbi(4464:15-4492:15)
        while ((i < mnnz) and (j < e.nnz)):
          if   (msubi[i] < esubj[perm[j]]):
            i += 1
          elif (msubi[i] > esubj[perm[j]]):
            j += 1
          elif (msubj[i] < esubi[perm[j]]):
            i += 1
          elif (msubj[i] > esubi[perm[j]]):
            j += 1
          else:
            if   (previ < msubi[i]):
              previ = msubi[i]
              inst[p] = long(msubi[i])
              p += 1
              ptrb[p] = ptrb[(p - 1)]
            num = (e.ptrb[(perm[j] + 1)] - e.ptrb[perm[j]])

            ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[perm[j]],subj_,ptrb[p],num) )
            # src/fusion/Expr.mbi(4481:19-4482:74)
            l = 0

            while (l < num):
              cof[(ptrb[p] + l)] = (mval[i] * e.cof[(e.ptrb[perm[j]] + l)])
              l += 1
            if   (bfix != None):
              bfix[(p - 1)] = (bfix[(p - 1)] + (mval[i] * e.bfix[perm[j]]))
            ptrb[p] = (ptrb[p] + num)
            i += 1
            j += 1
        # } @ src/fusion/Expr.mbi(4461:13-4493:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj_,cof,bfix,shape,inst)
    return r
  @staticmethod
  def _matchargs_mulDiag_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(4512:15-4764:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulDiag(mosek.fusion.Expression,mosek.fusion.Matrix)")
  def _mulDiag_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(expr,mx):
    if   ((mx == None) or (expr == None)):
      raise Exception("Arguments for mulDiag may not be null")
    lhs = expr

    rhs = mx


    e = ( lhs._eval_() )

    if   (e.shape.nd != 2):
      raise mosek.fusion.DimensionError("Expression operand must have 2 dimensions")
    if   ((( e.shape._dim_I(0) ) != rhs._dimj) or (( e.shape._dim_I(1) ) != rhs._dimi)):
      raise mosek.fusion.DimensionError("Mismatching operand dimensions")
    edi = ( e.shape._dim_I(0) )

    edj = ( e.shape._dim_I(1) )

    _autovar_403 = rhs
    if   isinstance(_autovar_403,mosek.fusion.DenseMatrix):
      m = _autovar_403
      if   (e.inst == None):
        ptrb = ([ 0l for _autovar_404 in xrange((edi + 1)) ])

        subj = ([ 0l for _autovar_405 in xrange(e.nnz) ])

        cof = ([ 0.0 for _autovar_406 in xrange(e.nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_407 in xrange(edi) ])
        inst = None

        shape = None

        eptridx = 0

        # src/fusion/Expr.mbi(4543:13-4562:13)
        i = 0

        while (i < edi):
          ptrb[(i + 1)] = ptrb[i]
          # src/fusion/Expr.mbi(4546:15-4561:15)
          j = 0

          while (j < edj):
            num = (e.ptrb[(eptridx + 1)] - e.ptrb[eptridx])

            c = m._data[((j * edi) + i)]

            ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[eptridx],subj,ptrb[(i + 1)],num) )
            # src/fusion/Expr.mbi(4552:17-4553:68)
            l = 0

            while (l < num):
              cof[(ptrb[(i + 1)] + l)] = (c * e.cof[(e.ptrb[eptridx] + l)])
              l += 1
            if   (bfix != None):
              bfix[i] = (bfix[i] + (c * e.bfix[eptridx]))
            ptrb[(i + 1)] = (ptrb[(i + 1)] + num)
            eptridx += 1
            j += 1
          i += 1
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
      else:
        numElements = 0

        # { @ src/fusion/Expr.mbi(4569:13-4580:13)
        previ = (- 1l)

        # src/fusion/Expr.mbi(4571:15-4579:15)
        i = 0

        while (i < int(len(e.inst))):
          ei = (e.inst[i] / long(edj))

          if   (previ < ei):
            previ = ei
            numElements += 1
          i += 1
        # } @ src/fusion/Expr.mbi(4569:13-4580:13)
        ptrb = ([ 0l for _autovar_408 in xrange((numElements + 1)) ])

        subj = ([ 0l for _autovar_409 in xrange(e.nnz) ])

        cof = ([ 0.0 for _autovar_410 in xrange(e.nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_411 in xrange(numElements) ])
        inst = None

        if   (numElements < edi):
          inst = ([ 0l for _autovar_412 in xrange(numElements) ])
        shape = mosek.fusion.IntSet(edi)

        # { @ src/fusion/Expr.mbi(4589:13-4620:13)
        previ = (- 1l)

        p = 0

        # src/fusion/Expr.mbi(4592:15-4619:15)
        i = 0

        while (i < int(len(e.inst))):
          ei = (e.inst[i] / long(edj))

          ej = (e.inst[i] - (ei * long(edj)))

          if   (previ < ei):
            previ = ei
            if   (inst != None):
              inst[p] = ei
            p += 1
            ptrb[p] = ptrb[(p - 1)]
          num = (e.ptrb[(i + 1)] - e.ptrb[i])

          ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[i],subj,ptrb[p],num) )
          c = m._data[((ej * edi) + ei)]

          # src/fusion/Expr.mbi(4608:17-4611:17)
          l = 0

          while (l < num):
            cof[(ptrb[p] + l)] = (c * e.cof[(e.ptrb[i] + l)])
            l += 1
          if   (bfix != None):
            bfix[(p - 1)] = (bfix[(p - 1)] + (c * e.bfix[i]))
          ptrb[p] = (ptrb[p] + num)
          i += 1
        # } @ src/fusion/Expr.mbi(4589:13-4620:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
    else:
      m = _autovar_403
      mnnz = ( m._numNonzeros_() )

      msubi = ([ 0 for _autovar_413 in xrange(mnnz) ])

      msubj = ([ 0 for _autovar_414 in xrange(mnnz) ])

      mval = ([ 0.0 for _autovar_415 in xrange(mnnz) ])

      perm = ( Utils.Tools._range_L (long(mnnz)) )

      ( m._getDataAsTriplets__3I_3I_3F(msubi,msubj,mval) )
      ( Sort._argsort__3L_3I_3I (perm,msubj,msubi) )
      if   (e.inst == None):
        numEntries = 0

        nnz = 0l

        # { @ src/fusion/Expr.mbi(4639:13-4647:13)
        prevj = (- 1)

        # src/fusion/Expr.mbi(4641:15-4646:15)
        k = 0

        while (k < mnnz):
          if   (prevj < msubj[perm[k]]):
            numEntries += 1
            prevj = msubj[perm[k]]
          eptrbidx = ((msubj[perm[k]] * m._dimi) + msubi[perm[k]])

          nnz = (nnz + (e.ptrb[(eptrbidx + 1)] - e.ptrb[eptrbidx]))
          k += 1
        # } @ src/fusion/Expr.mbi(4639:13-4647:13)
        ptrb = ([ 0l for _autovar_416 in xrange((numEntries + 1)) ])

        subj = ([ 0l for _autovar_417 in xrange(nnz) ])

        cof = ([ 0.0 for _autovar_418 in xrange(nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_419 in xrange(numEntries) ])
        inst = None

        if   (numEntries < m._dimj):
          inst = ([ 0l for _autovar_420 in xrange(numEntries) ])
        shape = mosek.fusion.IntSet(m._dimj)

        # { @ src/fusion/Expr.mbi(4656:13-4681:13)
        prevj = (- 1l)

        p = 0

        # src/fusion/Expr.mbi(4659:15-4680:15)
        k = 0

        while (k < mnnz):
          if   (prevj < msubj[perm[k]]):
            prevj = long(msubj[perm[k]])
            if   (inst != None):
              inst[p] = prevj
            p += 1
            ptrb[p] = ptrb[(p - 1)]
          eptrbidx = ((msubj[perm[k]] * m._dimi) + msubi[perm[k]])

          num = (e.ptrb[(eptrbidx + 1)] - e.ptrb[eptrbidx])

          ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[eptrbidx],subj,ptrb[p],num) )
          # src/fusion/Expr.mbi(4672:17-109)
          l = 0

          while (l < num):
            cof[(ptrb[p] + l)] = (e.cof[(e.ptrb[eptrbidx] + l)] * mval[perm[k]])
            l += 1
          if   (bfix != None):
            bfix[prevj] = (bfix[prevj] + (e.bfix[eptrbidx] * mval[perm[k]]))
          ptrb[p] = (ptrb[p] + num)
          k += 1
        # } @ src/fusion/Expr.mbi(4656:13-4681:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
      else:
        numEntries = 0

        nnz = 0l

        # { @ src/fusion/Expr.mbi(4690:13-4713:13)
        i = 0

        j = 0

        previ = (- 1l)

        # src/fusion/Expr.mbi(4692:15-4712:15)
        while ((i < int(len(e.inst))) and (j < mnnz)):
          curlhsi = (e.inst[i] / edj)

          curlhsj = (e.inst[i] - (curlhsi * edj))

          if   (curlhsi < msubj[perm[j]]):
            i += 1
          elif (curlhsi > msubj[perm[j]]):
            j += 1
          elif (curlhsj < msubi[perm[j]]):
            i += 1
          elif (curlhsj > msubi[perm[j]]):
            j += 1
          else:
            if   (previ < curlhsi):
              numEntries += 1
              previ = curlhsi
            nnz = (nnz + (e.ptrb[(i + 1)] - e.ptrb[i]))
            i += 1
            j += 1
        # } @ src/fusion/Expr.mbi(4690:13-4713:13)
        ptrb = ([ 0l for _autovar_421 in xrange((numEntries + 1)) ])

        subj = ([ 0l for _autovar_422 in xrange(nnz) ])

        cof = ([ 0.0 for _autovar_423 in xrange(nnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_424 in xrange(numEntries) ])
        inst = None

        if   (numEntries < edi):
          inst = ([ 0l for _autovar_425 in xrange(numEntries) ])
        shape = mosek.fusion.IntSet(edi)

        # { @ src/fusion/Expr.mbi(4722:13-4757:13)
        i = 0

        j = 0

        previ = (- 1l)

        p = 0

        # src/fusion/Expr.mbi(4724:15-4756:15)
        while ((i < int(len(e.inst))) and (j < mnnz)):
          curlhsi = (e.inst[i] / long(edj))

          curlhsj = (e.inst[i] - (curlhsi * long(edj)))

          if   (curlhsi < msubj[perm[j]]):
            i += 1
          elif (curlhsi > msubj[perm[j]]):
            j += 1
          elif (curlhsj < msubi[perm[j]]):
            i += 1
          elif (curlhsj > msubi[perm[j]]):
            j += 1
          else:
            if   (previ < curlhsi):
              if   (inst != None):
                inst[p] = curlhsi
              p += 1
              ptrb[p] = ptrb[(p - 1)]
              previ = curlhsi
            num = (e.ptrb[(i + 1)] - e.ptrb[i])

            c = mval[perm[j]]

            ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[i],subj,ptrb[p],num) )
            # src/fusion/Expr.mbi(4747:19-4748:62)
            l = 0

            while (l < num):
              cof[(ptrb[p] + l)] = (c * e.cof[(e.ptrb[i] + l)])
              l += 1
            if   (bfix != None):
              bfix[(p - 1)] = (bfix[(p - 1)] + (c * e.bfix[i]))
            ptrb[p] = (ptrb[p] + num)
            i += 1
            j += 1
        # } @ src/fusion/Expr.mbi(4722:13-4757:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
    return r
  @staticmethod
  def _matchargs_mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(4777:15-4830:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulDiag(mosek.fusion.Matrix,mosek.fusion.Variable)")
  def _mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(expr,v):
    if   ((v == None) or (expr == None)):
      raise Exception("Arguments for mulDiag may not be null")
    lhs = expr

    rhs = v

    if   (((rhs.shape.nd != 2) or (lhs._dimj != ( rhs.shape._dim_I(0) ))) or (lhs._dimi != ( rhs.shape._dim_I(1) ))):
      raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    _autovar_426 = lhs
    if   isinstance(_autovar_426,mosek.fusion.DenseMatrix):
      m = _autovar_426
      ptrb = ( Utils.Tools._range_LLL (0l,long((m._dimj * (1 + m._dimi))),long(m._dimj)) )

      subj = ([ 0l for _autovar_427 in xrange((m._dimi * m._dimj)) ])

      cof = m._data

      k = 0

      # src/fusion/Expr.mbi(4798:11-4808:11)
      i = 0

      while (i < m._dimi):
        vk = long(i)

        # src/fusion/Expr.mbi(4801:13-4807:13)
        j = 0

        while (j < m._dimj):
          subj[k] = vk
          k += 1
          vk = (vk + m._dimi)
          j += 1
        i += 1
      return mosek.fusion.Expr(ptrb,rhs,subj,cof,None,None,None,1)
    elif isinstance(_autovar_426,mosek.fusion.SparseMatrix):
      m = _autovar_426
      ptrb = ([ 0l for _autovar_428 in xrange((m._dimi + 1)) ])

      subj = ([ 0l for _autovar_429 in xrange(m._nnz) ])

      cof = m._val

      nnz = m._nnz

      # src/fusion/Expr.mbi(4820:11-68)
      k = 0

      while (k < nnz):
        ptrb[(m._subi[k] + 1)] += 1
        k += 1
      # src/fusion/Expr.mbi(4821:11-79)
      k = 0

      while (k < m._dimi):
        ptrb[(k + 1)] = (ptrb[k] + ptrb[(k + 1)])
        k += 1
      # src/fusion/Expr.mbi(4822:11-95)
      k = 0

      while (k < nnz):
        subj[k] = long(((m._subj[k] * m._dimi) + m._subi[k]))
        k += 1
      return mosek.fusion.Expr(ptrb,rhs,subj,cof,None,None,None,1)
    else:
      m = _autovar_426
      raise mosek.fusion.MatrixError("Unknown matrix type used.")
  @staticmethod
  def _matchargs_mulDiag_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(4843:15-4907:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mulDiag(mosek.fusion.Variable,mosek.fusion.Matrix)")
  def _mulDiag_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(v,mx):
    if   ((v == None) or (mx == None)):
      raise Exception("Arguments for mulDiag may not be null")
    lhs = v

    rhs_ = mx

    if   (((lhs.shape.nd != 2) or (rhs_._dimj != ( lhs.shape._dim_I(0) ))) or (rhs_._dimi != ( lhs.shape._dim_I(1) ))):
      raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    d = long(rhs_._dimj)

    _autovar_430 = rhs_
    if   isinstance(_autovar_430,mosek.fusion.DenseMatrix):
      m = _autovar_430
      nnz = (d * m._dimi)

      ptrb = ( Utils.Tools._range_LLL (0l,(d * (1l + d)),d) )

      subj = ( Utils.Tools._range_LL (0l,nnz) )

      cof = ([ 0.0 for _autovar_431 in xrange(nnz) ])

      k = 0

      # src/fusion/Expr.mbi(4868:11-4875:11)
      i = 0l

      while (i < m._dimj):
        # src/fusion/Expr.mbi(4870:13-4874:13)
        j = 0l

        while (j < m._dimi):
          cof[k] = m._data[((j * d) + i)]
          k += 1
          j += 1
        i += 1
      return mosek.fusion.Expr(ptrb,lhs,subj,cof,None,None,None,1)
    else:
      m = _autovar_430
      nnz = ( m._numNonzeros_() )

      ptrb = ([ 0l for _autovar_432 in xrange((d + 1)) ])

      subj = ([ 0l for _autovar_433 in xrange(nnz) ])

      cof = ([ 0.0 for _autovar_434 in xrange(nnz) ])

      msubi = ([ 0 for _autovar_435 in xrange(nnz) ])

      msubj = ([ 0 for _autovar_436 in xrange(nnz) ])

      mval = ([ 0.0 for _autovar_437 in xrange(nnz) ])

      ( m._getDataAsTriplets__3I_3I_3F(msubi,msubj,mval) )
      # src/fusion/Expr.mbi(4892:11-63)
      k = 0

      while (k < nnz):
        ptrb[(msubj[k] + 1)] += 1
        k += 1
      # src/fusion/Expr.mbi(4893:11-76)
      k = 0

      while (k < d):
        ptrb[(k + 1)] = (ptrb[k] + ptrb[(k + 1)])
        k += 1
      # src/fusion/Expr.mbi(4894:11-4900:11)
      k = 0

      while (k < nnz):
        idx = ptrb[msubj[k]]

        cof[idx] = mval[k]
        subj[idx] = long(((msubj[k] * m._dimi) + msubi[k]))
        ptrb[msubj[k]] += 1
        k += 1
      # src/fusion/Expr.mbi(4902:11-62)
      k = d

      while (k > 0):
        ptrb[k] = ptrb[(k - 1)]
        k -= 1
      ptrb[0] = 0l
      return mosek.fusion.Expr(ptrb,lhs,subj,cof,None,None,None,1)
  @staticmethod
  def _matchargs_computeNz__3L_3I_3L_3III_3I_3L(args):
    if len(args) != 8:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[4],int): return False
    if not isinstance(args[5],int): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  # origin: src/fusion/Expr.mbi(4917:17-4959:8)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("computeNz([long],[int],[long],[int],int,int,[int],[long])")
  def __computeNz__3L_3I_3L_3III_3I_3L(a_ptrb,a_subj,b_ptrb,b_subj,rows,cols,flag,c_ptrb):
    nz = 0l

    mark = 0

    # src/fusion/Expr.mbi(4929:10-4932:10)
    i = 0

    while (i < cols):
      flag[i] = 0
      i += 1
    # src/fusion/Expr.mbi(4934:10-4954:10)
    a_row = 0

    while (a_row < rows):
      mark += 1
      c_ptrb[a_row] = nz
      # src/fusion/Expr.mbi(4939:12-4953:12)
      idx = a_ptrb[a_row]

      while (idx < a_ptrb[(a_row + 1)]):
        b_row = a_subj[idx]

        # src/fusion/Expr.mbi(4943:14-4952:14)
        b_offset = b_ptrb[b_row]

        while (b_offset < b_ptrb[(b_row + 1)]):
          i = b_subj[b_offset]

          if   (flag[i] != mark):
            nz += 1
            flag[i] = mark
          b_offset += 1
        idx += 1
      a_row += 1
    c_ptrb[rows] = nz
    return nz
  @staticmethod
  def _matchargs_sparseMatmul__3L_3I_3F_3L_3I_3F_3L_3I_3FII_3I(args):
    if len(args) != 12:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[9],int): return False
    if not isinstance(args[10],int): return False
    a = args[11]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Expr.mbi(4963:16-5021:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseMatmul([long],[int],[float],[long],[int],[float],[long],[int],[float],int,int,[int])")
  def __sparseMatmul__3L_3I_3F_3L_3I_3F_3L_3I_3FII_3I(c_ptrb,c_subj,c_cof,a_ptrb,a_subj,a_cof,b_ptrb,b_subj,b_cof,rows,cols,flag):
    nz = 0

    nz_start = 0

    val = ([ 0.0 for _autovar_438 in xrange(cols) ])

    # src/fusion/Expr.mbi(4980:9-4984:9)
    i = 0

    while (i < cols):
      flag[i] = (- 1)
      val[i] = 0.0
      i += 1
    # src/fusion/Expr.mbi(4987:9-5020:9)
    a_row = 0

    while (a_row < rows):
      nz_start = nz
      # src/fusion/Expr.mbi(4991:11-5012:11)
      idx = a_ptrb[a_row]

      while (idx < a_ptrb[(a_row + 1)]):
        b_row = a_subj[idx]

        a_val = a_cof[idx]

        # src/fusion/Expr.mbi(4996:13-5011:13)
        b_offset = b_ptrb[b_row]

        while (b_offset < b_ptrb[(b_row + 1)]):
          i = b_subj[b_offset]

          if   (flag[i] < nz_start):
            flag[i] = nz
            val[i] = (a_val * b_cof[b_offset])
            c_subj[nz] = i
            nz += 1
          else:
            val[i] = (val[i] + (a_val * b_cof[b_offset]))
          b_offset += 1
        idx += 1
      ( Utils.Tools._sort__3III (c_subj,nz_start,nz) )
      # src/fusion/Expr.mbi(5015:11-5019:11)
      i = nz_start

      while (i < nz):
        c_cof[i] = val[c_subj[i]]
        val[c_subj[i]] = 0.0
        i += 1
      a_row += 1
  @staticmethod
  def _matchargs_sparseMatrixVector__3L_3I_3F_3F_3FI(args):
    if len(args) != 6:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[5],int): return False
    return True
  # origin: src/fusion/Expr.mbi(5025:16-5045:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseMatrixVector([long],[int],[float],[float],[float],int)")
  def __sparseMatrixVector__3L_3I_3F_3F_3FI(aPtrb,aSubj,aCof,b,w,numARows):
    # src/fusion/Expr.mbi(5032:9-5035:9)
    i = 0

    while (i < numARows):
      w[i] = 0.0
      i += 1
    # src/fusion/Expr.mbi(5037:9-5044:9)
    row = 0

    while (row < numARows):
      # src/fusion/Expr.mbi(5039:11-5043:11)
      p = aPtrb[row]

      while (p < aPtrb[(row + 1)]):
        index = aSubj[p]

        w[row] = (w[row] + (b[index] * aCof[index]))
        p += 1
      row += 1
  @staticmethod
  def _matchargs_mul_1_1_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(5064:16-5473:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mul__(mosek.fusion.Matrix,mosek.fusion.Expression)")
  def __mul_1_1_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(mx,expr):
    lhs = mx

    rhs = expr

    if   (expr._shape.nd > 2):
      raise mosek.fusion.DimensionError("Expression operand must have 1 or 2 dimensions")
    if   (( expr._shape._dim_I(0) ) != lhs._dimj):
      raise mosek.fusion.DimensionError("Dimensions of operands do not match")
    e = ( expr._eval_() )


    edi = ( e.shape._dim_I(0) )

    edj = 1

    nd = 1

    if   (e.shape.nd == 2):
      edj = ( e.shape._dim_I(1) )
      nd = 2
      shape = mosek.fusion.NDSet(lhs._dimi,edj)
    else:
      shape = mosek.fusion.IntSet(lhs._dimi)

    _autovar_439 = lhs
    if   isinstance(_autovar_439,mosek.fusion.DenseMatrix):
      m = _autovar_439
      if   (e.inst == None):
        numEntries = (m._dimi * edj)

        ptrb = ([ 0l for _autovar_440 in xrange((numEntries + 1)) ])

        subj = ([ 0l for _autovar_441 in xrange((e.nnz * m._dimi)) ])

        cof = ([ 0.0 for _autovar_442 in xrange((e.nnz * m._dimi)) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_443 in xrange(numEntries) ])
        p = 1

        # src/fusion/Expr.mbi(5112:13-5136:13)
        i = 0

        while (i < m._dimi):
          # src/fusion/Expr.mbi(5114:15-5135:15)
          j = 0

          while (j < edj):
            ptrbase = ptrb[(p - 1)]

            # src/fusion/Expr.mbi(5117:17-5132:17)
            k = 0

            while (k < edi):
              idx = ((k * edj) + j)

              num = (e.ptrb[(idx + 1)] - e.ptrb[idx])

              curcof = m._data[((i * m._dimj) + k)]

              # src/fusion/Expr.mbi(5122:19-5126:19)
              l = 0

              while (l < num):
                cof[(ptrbase + l)] = (e.cof[(e.ptrb[idx] + l)] * curcof)
                subj[(ptrbase + l)] = e.subj[(e.ptrb[idx] + l)]
                l += 1
              ptrbase = (ptrbase + num)
              if   (e.bfix != None):
                bfix[(p - 1)] = (bfix[(p - 1)] + (e.bfix[idx] * curcof))
              k += 1
            ptrb[p] = ptrbase
            p += 1
            j += 1
          i += 1
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,None)
      else:
        nelm = int(len(e.inst))

        esubi = ([ 0 for _autovar_444 in xrange(nelm) ])

        esubj = ([ 0 for _autovar_445 in xrange(nelm) ])

        perm = ( Utils.Tools._range_L (long(len(e.inst))) )

        # src/fusion/Expr.mbi(5146:13-5150:13)
        k = 0

        while (k < nelm):
          esubi[k] = int((e.inst[k] / edj))
          esubj[k] = int((e.inst[k] - esubi[k]))
          k += 1
        ( Sort._argsort__3L_3I_3I (perm,esubj,esubi) )
        numRhsCol = 0

        if   (int(len(esubj)) > 0):
          numRhsCol = 1
          # src/fusion/Expr.mbi(5156:15-104)
          k = 1

          while (k < nelm):
            if   (esubj[perm[k]] > esubj[perm[(k - 1)]]):
              numRhsCol += 1
            k += 1
        numEntries = (numRhsCol * m._dimi)

        ptrb = ([ 0l for _autovar_446 in xrange((numEntries + 1)) ])

        subj = ([ 0l for _autovar_447 in xrange((e.nnz * m._dimi)) ])

        cof = ([ 0.0 for _autovar_448 in xrange((e.nnz * m._dimi)) ])

        bfix = None

        inst = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_449 in xrange(numEntries) ])
        if   (numRhsCol < edj):
          inst = ([ 0l for _autovar_450 in xrange(numEntries) ])
        ptridx = 0

        # src/fusion/Expr.mbi(5174:13-5230:13)
        i = 0

        while (i < m._dimi):
          mrowbase = long((m._dimj * i))

          # src/fusion/Expr.mbi(5183:15-5229:15)
          k = 0

          while (k < nelm):
            if   ((k == 0) or (esubj[perm[k]] > esubj[perm[(k - 1)]])):
              ptridx += 1
              ptrb[ptridx] = ptrb[(ptridx - 1)]
              if   (inst != None):
                inst[(ptridx - 1)] = ((long(i) * edj) + esubj[perm[k]])
            eptrbpk = e.ptrb[perm[k]]

            num = (e.ptrb[(perm[k] + 1)] - eptrbpk)

            lhscof = m._data[(mrowbase + esubi[perm[k]])]

            # src/fusion/Expr.mbi(5206:17-5210:17)
            l = 0

            while (l < num):
              subj[(ptrb[ptridx] + l)] = e.subj[(eptrbpk + l)]
              cof[(ptrb[ptridx] + l)] = (e.cof[(eptrbpk + l)] * lhscof)
              l += 1
            if   (bfix != None):
              bfix[(ptridx - 1)] = (bfix[(ptridx - 1)] + (e.bfix[perm[k]] * lhscof))
            if   (inst != None):
              inst[(ptridx - 1)] = long(esubj[perm[k]])
            ptrb[ptridx] = (ptrb[ptridx] + num)
            k += 1
          i += 1
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
    else:
      m = _autovar_439
      numMatNz = ( m._numNonzeros_() )

      msubi = ([ 0 for _autovar_451 in xrange(numMatNz) ])

      msubj = ([ 0 for _autovar_452 in xrange(numMatNz) ])

      mval = ([ 0.0 for _autovar_453 in xrange(numMatNz) ])

      ( m._getDataAsTriplets__3I_3I_3F(msubi,msubj,mval) )
      if   (e.inst == None):
        numLhsRow = 1l

        # src/fusion/Expr.mbi(5245:13-84)
        for i in xrange(1l,numMatNz):
          # { @ src/fusion/Expr.mbi(5245:42-84)
          if   (msubi[i] > msubi[(i - 1)]):
            numLhsRow += 1
          # } @ src/fusion/Expr.mbi(5245:42-84)
        numResElm = (numLhsRow * edj)

        ptrb = ([ 0l for _autovar_454 in xrange((numResElm + 1)) ])

        resNnz = 0l

        # { @ src/fusion/Expr.mbi(5250:13-5270:13)
        prevMsubi = msubi[0]

        resBase = 0l

        # src/fusion/Expr.mbi(5253:15-5269:15)
        for i in xrange(0l,numMatNz):
          # { @ src/fusion/Expr.mbi(5254:15-5269:15)
          if   (prevMsubi < msubi[i]):
            resBase = (resBase + edj)
            prevMsubi = msubi[i]
          # src/fusion/Expr.mbi(5261:17-5268:17)
          for j in xrange(0,edj):
            # { @ src/fusion/Expr.mbi(5262:17-5268:17)
            idx = ((msubj[i] * edj) + j)

            num = (e.ptrb[(idx + 1)] - e.ptrb[idx])

            resNnz = (resNnz + num)
            ptrb[((resBase + j) + 1)] = (ptrb[((resBase + j) + 1)] + num)
            # } @ src/fusion/Expr.mbi(5262:17-5268:17)
          # } @ src/fusion/Expr.mbi(5254:15-5269:15)
        # } @ src/fusion/Expr.mbi(5250:13-5270:13)
        subj = ([ 0l for _autovar_455 in xrange(resNnz) ])

        cof = ([ 0.0 for _autovar_456 in xrange(resNnz) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_457 in xrange(numResElm) ])
        # src/fusion/Expr.mbi(5277:13-84)
        i = 0

        while (i < numResElm):
          ptrb[(i + 1)] = (ptrb[i] + ptrb[(i + 1)])
          i += 1
        inst = None

        if   (numLhsRow < m._dimi):
          inst = ([ 0l for _autovar_458 in xrange(numResElm) ])
        # { @ src/fusion/Expr.mbi(5291:13-5324:13)
        resBase = 0l

        prevMsubi = msubi[0]

        # src/fusion/Expr.mbi(5294:15-5323:15)
        i = 0

        while (i < numMatNz):
          mcof = mval[i]

          if   (prevMsubi < msubi[i]):
            resBase = (resBase + edj)
            prevMsubi = msubi[i]
          # src/fusion/Expr.mbi(5303:17-5320:17)
          j = 0

          while (j < edj):
            idx = ((msubj[i] * edj) + j)

            num = (e.ptrb[(idx + 1)] - e.ptrb[idx])

            # src/fusion/Expr.mbi(5308:19-5312:19)
            k = 0

            while (k < num):
              cof[(ptrb[(resBase + j)] + k)] = (e.cof[(e.ptrb[idx] + k)] * mcof)
              subj[(ptrb[(resBase + j)] + k)] = e.subj[(e.ptrb[idx] + k)]
              k += 1
            if   (bfix != None):
              bfix[(resBase + j)] = (bfix[(resBase + j)] + (e.bfix[idx] * mcof))
            ptrb[(resBase + j)] = (ptrb[(resBase + j)] + num)
            if   (inst != None):
              inst[(resBase + j)] = long(((msubi[i] * edj) + j))
            j += 1
          i += 1
        # } @ src/fusion/Expr.mbi(5291:13-5324:13)
        # src/fusion/Expr.mbi(5325:13-5326:34)
        i = (int(len(ptrb)) - 1)

        while (i > 0):
          ptrb[i] = ptrb[(i - 1)]
          i -= 1
        ptrb[0] = 0l
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
      else:
        lhsNumNz = ( lhs._numNonzeros_() )

        nelm = int(len(e.inst))

        esubi = ([ 0 for _autovar_459 in xrange(nelm) ])

        esubj = ([ 0 for _autovar_460 in xrange(nelm) ])

        perm = ( Utils.Tools._range_L (long(len(e.inst))) )

        # src/fusion/Expr.mbi(5340:13-5344:13)
        k = 0

        while (k < nelm):
          esubi[k] = int((e.inst[k] / edj))
          esubj[k] = int((e.inst[k] - esubi[k]))
          k += 1
        ( Sort._argsort__3L_3I_3I (perm,esubj,esubi) )
        numResElm = 0l

        numResNz = 0l

        # { @ src/fusion/Expr.mbi(5350:13-5401:13)
        # src/fusion/Expr.mbi(5351:15-5400:15)
        lhs_row_start = 0

        while (lhs_row_start < lhsNumNz):
          lhs_row_end = lhs_row_start

          # src/fusion/Expr.mbi(5353:50-144)
          while ((lhs_row_end < lhsNumNz) and (msubi[lhs_row_end] == msubi[lhs_row_start])):
            pass
            lhs_row_end += 1
          matRowIdx = msubi[lhs_row_start]

          rhs_col_idx = esubj[perm[0]]

          # { @ src/fusion/Expr.mbi(5360:17-5397:17)
          # src/fusion/Expr.mbi(5361:19-5396:19)
          rhs_col_start = 0

          while (rhs_col_start < nelm):

            # src/fusion/Expr.mbi(5364:21-5367:22)
            rhs_col_end = (rhs_col_start + 1)
            while ((rhs_col_end < nelm) and (esubj[perm[rhs_col_end]] == esubj[perm[(rhs_col_end - 1)]])):
              pass
              rhs_col_end += 1
            i = lhs_row_start

            k = rhs_col_start

            old_nnz = numResNz

            # src/fusion/Expr.mbi(5375:21-5388:21)
            while ((i < lhs_row_end) and (k < rhs_col_end)):
              if   (msubj[i] < esubi[perm[k]]):
                i += 1
              elif (msubj[i] > esubi[perm[k]]):
                k += 1
              else:
                numResNz = (numResNz + (e.ptrb[(perm[k] + 1)] - e.ptrb[perm[k]]))
                k += 1
                i += 1
            if   (old_nnz < numResNz):
              numResElm += 1
            rhs_col_start = rhs_col_end
          # } @ src/fusion/Expr.mbi(5360:17-5397:17)
          lhs_row_start = lhs_row_end
        # } @ src/fusion/Expr.mbi(5350:13-5401:13)
        ptrb = ([ 0l for _autovar_461 in xrange((numResElm + 1)) ])

        subj = ([ 0l for _autovar_462 in xrange(numResNz) ])

        cof = ([ 0.0 for _autovar_463 in xrange(numResNz) ])

        inst = ([ 0l for _autovar_464 in xrange(numResElm) ])

        bfix = None

        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_465 in xrange(numResElm) ])
        # { @ src/fusion/Expr.mbi(5410:13-5467:13)
        ptridx = 0

        resptr = 0l

        resptridx = 0

        # src/fusion/Expr.mbi(5414:15-5466:15)
        lhs_row_start = 0

        while (lhs_row_start < lhsNumNz):
          lhs_row_end = lhs_row_start

          # src/fusion/Expr.mbi(5416:50-144)
          while ((lhs_row_end < lhsNumNz) and (msubi[lhs_row_end] == msubi[lhs_row_start])):
            pass
            lhs_row_end += 1
          matRowIdx = msubi[lhs_row_start]

          rhs_col_idx = esubj[perm[0]]

          # { @ src/fusion/Expr.mbi(5420:17-5463:17)
          # src/fusion/Expr.mbi(5421:19-5462:19)
          rhs_col_start = 0

          while (rhs_col_start < nelm):

            # src/fusion/Expr.mbi(5424:21-5427:22)
            rhs_col_end = (rhs_col_start + 1)
            while ((rhs_col_end < nelm) and (esubj[perm[rhs_col_end]] == esubj[perm[(rhs_col_end - 1)]])):
              pass
              rhs_col_end += 1
            i = lhs_row_start

            k = rhs_col_start

            old_nnz = resptr

            # src/fusion/Expr.mbi(5432:21-5452:21)
            while ((i < lhs_row_end) and (k < rhs_col_end)):
              if   (msubj[i] < esubi[perm[k]]):
                i += 1
              elif (msubj[i] > esubi[perm[k]]):
                k += 1
              else:
                b = e.ptrb[perm[k]]

                num = (e.ptrb[(perm[k] + 1)] - b)

                ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[perm[k]],subj,resptr,num) )
                # src/fusion/Expr.mbi(5442:25-95)
                l = 0

                while (l < num):
                  cof[(resptr + l)] = (e.cof[(b + l)] * mval[i])
                  l += 1
                if   (bfix != None):
                  bfix[resptridx] = (bfix[resptridx] + (e.bfix[perm[k]] * mval[i]))
                resptr = (resptr + num)
                k += 1
                i += 1
            if   (old_nnz < resptr):
              inst[resptridx] = (long((msubi[lhs_row_start] * edj)) + esubj[perm[rhs_col_start]])
              resptridx += 1
              ptrb[resptridx] = resptr
            rhs_col_start = rhs_col_end
          # } @ src/fusion/Expr.mbi(5420:17-5463:17)
          lhs_row_start = lhs_row_end
        # } @ src/fusion/Expr.mbi(5410:13-5467:13)
        r = mosek.fusion.Expr(ptrb,e.x,subj,cof,bfix,shape,inst)
    return r
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(5484:15-5621:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Expression,mosek.fusion.Matrix)")
  def _sub_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for sub may not be null")
    if   (((lhs._shape.nd != 2) or (( lhs._shape._dim_I(0) ) != rhs._dimi)) or (( lhs._shape._dim_I(1) ) != rhs._dimj)):
      raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    lfe = ( lhs._eval_() )

    if   (lfe.inst == None):

      if   (lfe.bfix == None):
        bfix = ([ 0.0 for _autovar_466 in xrange((rhs._dimi * rhs._dimj)) ])
      else:
        bfix = lfe.bfix
      _autovar_467 = rhs
      if   isinstance(_autovar_467,mosek.fusion.DenseMatrix):
        m = _autovar_467
        # src/fusion/Expr.mbi(5508:13-5509:44)
        for i in xrange(0,int(len(bfix))):
          bfix[i] = (bfix[i] - m._data[i])
      else:
        m = _autovar_467
        subi_ = ([ 0 for _autovar_468 in xrange(( m._numNonzeros_() )) ])

        subj_ = ([ 0 for _autovar_469 in xrange(( m._numNonzeros_() )) ])

        val_ = ([ 0.0 for _autovar_470 in xrange(( m._numNonzeros_() )) ])

        ( m._getDataAsTriplets__3I_3I_3F(subi_,subj_,val_) )
        # src/fusion/Expr.mbi(5520:13-5524:13)
        for i in xrange(0l,( m._numNonzeros_() )):
          # { @ src/fusion/Expr.mbi(5521:13-5524:13)
          idx = ((subi_[i] * m._dimj) + subj_[i])

          bfix[idx] = (bfix[idx] - val_[i])
          # } @ src/fusion/Expr.mbi(5521:13-5524:13)
      return mosek.fusion.Expr(lfe.ptrb,lfe.x,lfe.subj,lfe.cof,bfix,lfe.shape,None,1)
    else:
      _autovar_471 = rhs
      if   isinstance(_autovar_471,mosek.fusion.DenseMatrix):
        m = _autovar_471
        rnnz = ( m._numNonzeros_() )

        ptrb = ([ 0l for _autovar_472 in xrange((rnnz + 1)) ])

        bfix = ([ 0.0 for _autovar_473 in xrange(rnnz) ])

        # src/fusion/Expr.mbi(5538:13-62)
        for i in xrange(0,int(len(bfix))):
          bfix[i] = (- m._data[i])
        if   (lfe.bfix == None):
          # src/fusion/Expr.mbi(5540:15-5541:68)
          for i in xrange(0,int(len(lfe.bfix))):
            bfix[lfe.inst[i]] = (bfix[lfe.inst[i]] + lfe.bfix[i])
        # src/fusion/Expr.mbi(5543:13-81)
        for i in xrange(0,int(len(lfe.inst))):
          ptrb[(lfe.inst[i] + 1)] = lfe.ptrb[(i + 1)]
        # src/fusion/Expr.mbi(5544:13-5547:21)
        for i in xrange(1,int(len(ptrb))):
          if   (ptrb[i] == 0):
            ptrb[i] = ptrb[(i - 1)]
        return mosek.fusion.Expr(ptrb,lfe.x,lfe.subj,lfe.cof,bfix,lfe.shape,None,1)
      else:
        m = _autovar_471
        subi_ = ([ 0 for _autovar_474 in xrange(( m._numNonzeros_() )) ])

        subj_ = ([ 0 for _autovar_475 in xrange(( m._numNonzeros_() )) ])

        val_ = ([ 0.0 for _autovar_476 in xrange(( m._numNonzeros_() )) ])

        lidx = ([ 0l for _autovar_477 in xrange(( m._numNonzeros_() )) ])

        ( m._getDataAsTriplets__3I_3I_3F(subi_,subj_,val_) )
        # src/fusion/Expr.mbi(5556:13-92)
        for i in xrange(0l,( m._numNonzeros_() )):
          lidx[i] = long(((subi_[i] * m._dimj) + subj_[i]))
        rnnz = 0

        # { @ src/fusion/Expr.mbi(5560:13-5569:13)
        i = 0

        j = 0

        # src/fusion/Expr.mbi(5562:15-5566:44)
        while ((i < int(len(lfe.inst))) and (j < int(len(val_)))):
          if   (lfe.inst[i] < lidx[j]):
            i += 1
            rnnz += 1
          elif (lfe.inst[i] > lidx[j]):
            j += 1
            rnnz += 1
          else:
            i += 1
            j += 1
            rnnz += 1
        if   (i < int(len(lfe.inst))):
          rnnz = ((rnnz + int(len(lfe.inst))) - i)
        if   (j < int(len(lidx))):
          rnnz = ((rnnz + int(len(lidx))) - j)
        # } @ src/fusion/Expr.mbi(5560:13-5569:13)
        ptrb = ([ 0l for _autovar_478 in xrange((rnnz + 1)) ])

        bfix = ([ 0.0 for _autovar_479 in xrange(rnnz) ])

        inst = ([ 0l for _autovar_480 in xrange(rnnz) ])

        # { @ src/fusion/Expr.mbi(5575:13-5616:13)
        i = 0

        j = 0

        k = 0

        # src/fusion/Expr.mbi(5577:15-5601:15)
        while ((i < int(len(lfe.inst))) and (j < int(len(val_)))):
          if   (lfe.inst[i] < lidx[j]):
            if   (lfe.bfix != None):
              bfix[k] = lfe.bfix[i]
            inst[k] = lfe.inst[i]
            i += 1
          elif (lfe.inst[i] > lidx[j]):
            bfix[k] = (- val_[j])
            inst[k] = lidx[j]
            j += 1
          else:
            if   (lfe.bfix != None):
              bfix[k] = (lfe.bfix[i] - val_[j])
            else:
              bfix[k] = (- val_[j])
            inst[k] = lidx[j]
            i += 1
            j += 1
          k += 1
          ptrb[k] = lfe.ptrb[i]
        # src/fusion/Expr.mbi(5602:15-5608:15)
        while (i < int(len(lfe.inst))):
          if   (lfe.bfix != None):
            bfix[k] = lfe.bfix[i]
          inst[k] = lfe.inst[i]
          i += 1
          k += 1
          ptrb[k] = lfe.ptrb[i]
        # src/fusion/Expr.mbi(5609:15-5615:15)
        while (j < int(len(lidx))):
          bfix[k] = (- val_[j])
          inst[k] = lidx[j]
          j += 1
          k += 1
          ptrb[k] = lfe.ptrb[i]
        # } @ src/fusion/Expr.mbi(5575:13-5616:13)
        return mosek.fusion.Expr(ptrb,lfe.x,lfe.subj,lfe.cof,bfix,lfe.shape,inst,1)
  @staticmethod
  def _matchargs_add_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(5635:15-5771:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Expression,mosek.fusion.Matrix)")
  def _add_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for add may not be null")
    if   (((lhs._shape.nd != 2) or (( lhs._shape._dim_I(0) ) != rhs._dimi)) or (( lhs._shape._dim_I(1) ) != rhs._dimj)):
      raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    lfe = ( lhs._eval_() )

    if   (lfe.inst == None):

      if   (lfe.bfix == None):
        bfix = ([ 0.0 for _autovar_481 in xrange((rhs._dimi * rhs._dimj)) ])
      else:
        bfix = lfe.bfix
      _autovar_482 = rhs
      if   isinstance(_autovar_482,mosek.fusion.DenseMatrix):
        m = _autovar_482
        # src/fusion/Expr.mbi(5659:13-5660:44)
        for i in xrange(0,int(len(bfix))):
          bfix[i] = (bfix[i] + m._data[i])
      else:
        m = _autovar_482
        subi_ = ([ 0 for _autovar_483 in xrange(( m._numNonzeros_() )) ])

        subj_ = ([ 0 for _autovar_484 in xrange(( m._numNonzeros_() )) ])

        val_ = ([ 0.0 for _autovar_485 in xrange(( m._numNonzeros_() )) ])

        ( m._getDataAsTriplets__3I_3I_3F(subi_,subj_,val_) )
        # src/fusion/Expr.mbi(5671:13-5675:13)
        for i in xrange(0l,( m._numNonzeros_() )):
          # { @ src/fusion/Expr.mbi(5672:13-5675:13)
          idx = ((subi_[i] * m._dimj) + subj_[i])

          bfix[idx] = (bfix[idx] + val_[i])
          # } @ src/fusion/Expr.mbi(5672:13-5675:13)
      return mosek.fusion.Expr(lfe.ptrb,lfe.x,lfe.subj,lfe.cof,bfix,lfe.shape,None,1)
    else:
      _autovar_486 = rhs
      if   isinstance(_autovar_486,mosek.fusion.DenseMatrix):
        m = _autovar_486
        rnnz = ( m._numNonzeros_() )

        ptrb = ([ 0l for _autovar_487 in xrange((rnnz + 1)) ])

        bfix = ( Utils.Tools._arraycopy__3F (m._data) )

        if   (lfe.bfix == None):
          # src/fusion/Expr.mbi(5690:15-5691:68)
          for i in xrange(0,int(len(lfe.bfix))):
            bfix[lfe.inst[i]] = (bfix[lfe.inst[i]] + lfe.bfix[i])
        # src/fusion/Expr.mbi(5693:13-81)
        for i in xrange(0,int(len(lfe.inst))):
          ptrb[(lfe.inst[i] + 1)] = lfe.ptrb[(i + 1)]
        # src/fusion/Expr.mbi(5694:13-5697:21)
        for i in xrange(1,int(len(ptrb))):
          if   (ptrb[i] == 0):
            ptrb[i] = ptrb[(i - 1)]
        return mosek.fusion.Expr(ptrb,lfe.x,lfe.subj,lfe.cof,bfix,lfe.shape,None,1)
      else:
        m = _autovar_486
        subi_ = ([ 0 for _autovar_488 in xrange(( m._numNonzeros_() )) ])

        subj_ = ([ 0 for _autovar_489 in xrange(( m._numNonzeros_() )) ])

        val_ = ([ 0.0 for _autovar_490 in xrange(( m._numNonzeros_() )) ])

        lidx = ([ 0l for _autovar_491 in xrange(( m._numNonzeros_() )) ])

        ( m._getDataAsTriplets__3I_3I_3F(subi_,subj_,val_) )
        # src/fusion/Expr.mbi(5706:13-92)
        for i in xrange(0l,( m._numNonzeros_() )):
          lidx[i] = long(((subi_[i] * m._dimj) + subj_[i]))
        rnnz = 0

        # { @ src/fusion/Expr.mbi(5710:13-5719:13)
        i = 0

        j = 0

        # src/fusion/Expr.mbi(5712:15-5716:44)
        while ((i < int(len(lfe.inst))) and (j < int(len(val_)))):
          if   (lfe.inst[i] < lidx[j]):
            i += 1
            rnnz += 1
          elif (lfe.inst[i] > lidx[j]):
            j += 1
            rnnz += 1
          else:
            i += 1
            j += 1
            rnnz += 1
        if   (i < int(len(lfe.inst))):
          rnnz = ((rnnz + int(len(lfe.inst))) - i)
        if   (j < int(len(lidx))):
          rnnz = ((rnnz + int(len(lidx))) - j)
        # } @ src/fusion/Expr.mbi(5710:13-5719:13)
        ptrb = ([ 0l for _autovar_492 in xrange((rnnz + 1)) ])

        bfix = ([ 0.0 for _autovar_493 in xrange(rnnz) ])

        inst = ([ 0l for _autovar_494 in xrange(rnnz) ])

        # { @ src/fusion/Expr.mbi(5725:13-5766:13)
        i = 0

        j = 0

        k = 0

        # src/fusion/Expr.mbi(5727:15-5751:15)
        while ((i < int(len(lfe.inst))) and (j < int(len(val_)))):
          if   (lfe.inst[i] < lidx[j]):
            if   (lfe.bfix != None):
              bfix[k] = lfe.bfix[i]
            inst[k] = lfe.inst[i]
            i += 1
          elif (lfe.inst[i] > lidx[j]):
            bfix[k] = val_[j]
            inst[k] = lidx[j]
            j += 1
          else:
            if   (lfe.bfix != None):
              bfix[k] = (lfe.bfix[i] + val_[j])
            else:
              bfix[k] = val_[j]
            inst[k] = lidx[j]
            i += 1
            j += 1
          k += 1
          ptrb[k] = lfe.ptrb[i]
        # src/fusion/Expr.mbi(5752:15-5758:15)
        while (i < int(len(lfe.inst))):
          if   (lfe.bfix != None):
            bfix[k] = lfe.bfix[i]
          inst[k] = lfe.inst[i]
          i += 1
          k += 1
          ptrb[k] = lfe.ptrb[i]
        # src/fusion/Expr.mbi(5759:15-5765:15)
        while (j < int(len(lidx))):
          bfix[k] = val_[j]
          inst[k] = lidx[j]
          j += 1
          k += 1
          ptrb[k] = lfe.ptrb[i]
        # } @ src/fusion/Expr.mbi(5725:13-5766:13)
        return mosek.fusion.Expr(ptrb,lfe.x,lfe.subj,lfe.cof,bfix,lfe.shape,inst,1)
  @staticmethod
  def _matchargs_add_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(5779:15-5785:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add(mosek.fusion.Matrix,mosek.fusion.Expression)")
  def _add_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for add may not be null")
    return ( Expr._add_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2 (rhs,lhs) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(5794:15-5801:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Matrix,mosek.fusion.Expression)")
  def _sub_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for sub may not be null")
    return ( Expr._neg_Omosek_fusion_Expression_2 (( Expr._sub_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2 (rhs,lhs) )) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Expr.mbi(5809:15-5849:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Variable,mosek.fusion.Matrix)")
  def _sub_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for sub may not be null")
    if   (((lhs.shape.nd != 2) or (( lhs.shape._dim_I(0) ) != rhs._dimi)) or (( lhs.shape._dim_I(1) ) != rhs._dimj)):
      raise mosek.fusion.DimensionError("Mismatching dimensions of operands")
    size = (rhs._dimi * rhs._dimj)

    bfix = ([ 0.0 for _autovar_495 in xrange(size) ])

    _autovar_496 = rhs
    if   isinstance(_autovar_496,mosek.fusion.DenseMatrix):
      m = _autovar_496
      # src/fusion/Expr.mbi(5825:11-5826:34)
      for i in xrange(0,int(len(bfix))):
        bfix[i] = (- m._data[i])
    else:
      m = _autovar_496
      subi_ = ([ 0 for _autovar_497 in xrange(( m._numNonzeros_() )) ])

      subj_ = ([ 0 for _autovar_498 in xrange(( m._numNonzeros_() )) ])

      val_ = ([ 0.0 for _autovar_499 in xrange(( m._numNonzeros_() )) ])

      ( m._getDataAsTriplets__3I_3I_3F(subi_,subj_,val_) )
      # src/fusion/Expr.mbi(5835:11-5839:11)
      for i in xrange(0l,( m._numNonzeros_() )):
        # { @ src/fusion/Expr.mbi(5836:11-5839:11)
        idx = ((subi_[i] * m._dimj) + subj_[i])

        bfix[idx] = (- val_[i])
        # } @ src/fusion/Expr.mbi(5836:11-5839:11)
    cof = ( Utils.Tools._ones_I (size) )

    subj = ( Utils.Tools._range_LL (0l,long(size)) )

    ptrb = ( Utils.Tools._range_LL (0l,long((size + 1))) )

    return mosek.fusion.Expr(ptrb,lhs,subj,cof,bfix,lhs.shape,None,1)
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(5857:15-5863:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Matrix,mosek.fusion.Variable)")
  def _sub_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for sub may not be null")
    return ( Expr._neg_Omosek_fusion_Expression_2 (( Expr._sub_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2 (rhs,lhs) )) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(5872:15-5878:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Expression,mosek.fusion.Expression)")
  def _sub_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for sub may not be null")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (lhs,rhs,False) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(5885:15-5891:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Expression,mosek.fusion.Variable)")
  def _sub_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for sub may not be null")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (lhs,( rhs._asExpr_() ),False) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(5898:15-5904:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Variable,mosek.fusion.Expression)")
  def _sub_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for sub may not be null")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( lhs._asExpr_() ),rhs,False) )
  @staticmethod
  def _matchargs_sub__3FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(5913:15-5919:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub([float],mosek.fusion.Variable)")
  def _sub__3FOmosek_fusion_Variable_2(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for sub may not be null")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( Expr._constTerm__3F (lhs) ),( rhs._asExpr_() ),False) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Variable_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(5927:15-5933:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Variable,[float])")
  def _sub_Omosek_fusion_Variable_2_3F(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for sub may not be null")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( lhs._asExpr_() ),( Expr._constTerm__3F (rhs) ),False) )
  @staticmethod
  def _matchargs_sub__3FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(5941:15-5947:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub([float],mosek.fusion.Expression)")
  def _sub__3FOmosek_fusion_Expression_2(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for sub may not be null")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( Expr._constTerm__3F (lhs) ),rhs,False) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Expression_2_3F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(5955:15-5961:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Expression,[float])")
  def _sub_Omosek_fusion_Expression_2_3F(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for sub may not be null")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (lhs,( Expr._constTerm__3F (rhs) ),False) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Expression_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(5970:15-5988:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Expression,float)")
  def _sub_Omosek_fusion_Expression_2F(lhs,rhs):
    if   (lhs == None):
      raise Exception("Arguments for sub may not be null")
    fe = ( lhs._eval_() )

    bfix = None

    if   (fe.bfix == None):
      bfix = ( Utils.Tools._makevector_FI ((- rhs),(int(len(fe.ptrb)) - 1)) )
    else:
      bfix = ( Utils.Tools._arraycopy__3F (fe.bfix) )
      # src/fusion/Expr.mbi(5984:11-70)
      i = 0

      while (i < int(len(bfix))):
        bfix[i] = (bfix[i] - rhs)
        i += 1
    return mosek.fusion.Expr(fe.ptrb,fe.x,fe.subj,fe.cof,bfix,fe.shape,fe.inst,1)
  @staticmethod
  def _matchargs_sub_FOmosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(5996:15-6018:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(float,mosek.fusion.Expression)")
  def _sub_FOmosek_fusion_Expression_2(lhs,rhs):
    if   (rhs == None):
      raise Exception("Arguments for sub may not be null")
    fe = ( rhs._eval_() )

    bfix = None

    n = (int(len(fe.ptrb)) - 1)

    if   (fe.bfix == None):
      bfix = ( Utils.Tools._makevector_FI (lhs,n) )
    else:
      bfix = ([ 0.0 for _autovar_500 in xrange(n) ])
      # src/fusion/Expr.mbi(6011:11-65)
      i = 0

      while (i < n):
        bfix[i] = (lhs - fe.bfix[i])
        i += 1
    cof = ([ 0.0 for _autovar_501 in xrange(int(len(fe.cof))) ])

    # src/fusion/Expr.mbi(6015:9-63)
    i = 0

    while (i < int(len(cof))):
      cof[i] = (- fe.cof[i])
      i += 1
    return mosek.fusion.Expr(fe.ptrb,fe.x,fe.subj,cof,bfix,fe.shape,fe.inst,1)
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Variable_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(6026:15-6031:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Variable,float)")
  def _sub_Omosek_fusion_Variable_2F(lhs,rhs):
    if   (lhs == None):
      raise Exception("Arguments for sub may not be null")
    return ( Expr._sub_Omosek_fusion_Expression_2F (( lhs._asExpr_() ),rhs) )
  @staticmethod
  def _matchargs_sub_FOmosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(6040:15-6051:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(float,mosek.fusion.Variable)")
  def _sub_FOmosek_fusion_Variable_2(lhs,rhs):
    if   (rhs == None):
      raise Exception("Arguments for sub may not be null")
    n = rhs.shape._size

    return mosek.fusion.Expr(( Utils.Tools._range_LL (0l,(n + 1)) ),rhs,( Utils.Tools._range_LL (0l,n) ),( Utils.Tools._makevector_FI ((- 1.0),int(n)) ),( Utils.Tools._makevector_FI (lhs,int(n)) ),rhs.shape,None,1)
  @staticmethod
  def _matchargs_sub__3F_3F(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(6059:15-6065:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub([float],[float])")
  def _sub__3F_3F(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for sub may not be null")
    return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( Expr._constTerm__3F (lhs) ),( Expr._constTerm__3F (rhs) ),False) )
  @staticmethod
  def _matchargs_sub_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(6075:15-6084:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sub(mosek.fusion.Variable,mosek.fusion.Variable)")
  def _sub_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(lhs,rhs):
    if   ((lhs == None) or (rhs == None)):
      raise Exception("Arguments for sub may not be null")
    if   ( lhs.shape._compare_Omosek_fusion_Set_2(rhs.shape) ):
      return ( Expr.__addsub_1op_Omosek_fusion_Expression_2Omosek_fusion_Expression_2B (( lhs._asExpr_() ),( rhs._asExpr_() ),False) )
    else:
      raise mosek.fusion.DimensionError("Operands have mismatching number of dimensions.")
  @staticmethod
  def _matchargs_neg_Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(6088:15-6099:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("neg(mosek.fusion.Expression)")
  def _neg_Omosek_fusion_Expression_2(e):
    if   (e == None):
      raise Exception("Arguments for neg may not be null")
    fe = ( e._eval_() )

    newcof = ([ 0.0 for _autovar_502 in xrange(int(len(fe.cof))) ])

    newbfix = None

    if   (fe.bfix != None):
      newbfix = ([ 0.0 for _autovar_503 in xrange(int(len(fe.bfix))) ])
    # src/fusion/Expr.mbi(6094:9-62)
    for i in xrange(0,int(len(newcof))):
      newcof[i] = (- fe.cof[i])
    if   (fe.bfix != None):
      # src/fusion/Expr.mbi(6096:11-67)
      for i in xrange(0,int(len(fe.bfix))):
        newbfix[i] = (- fe.bfix[i])
    return mosek.fusion.Expr(fe.ptrb,fe.x,fe.subj,newcof,newbfix,fe.shape,fe.inst,1)
  @staticmethod
  def _matchargs_neg_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(6103:15-6110:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("neg(mosek.fusion.Variable)")
  def _neg_Omosek_fusion_Variable_2(v):
    if   (v == None):
      raise Exception("Arguments for neg may not be null")
    x = ( Variable._flatten_Omosek_fusion_Variable_2 (v) )

    ptrb = ( Utils.Tools._range_L ((x.shape._size + 1)) )

    subj = ( Utils.Tools._range_L (x.shape._size) )

    cof = ( Utils.Tools._makevector_FI ((- 1.0),( x.shape._dim_I(0) )) )

    return mosek.fusion.Expr(ptrb,x,subj,cof,None,v.shape,None,1)
  @staticmethod
  def _matchargs_sum_Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(6125:15-6152:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("sum(mosek.fusion.Expression)")
  def _sum_Omosek_fusion_Expression_2(expr):
    if   (expr == None):
      raise Exception("Arguments for neg may not be null")
    rhs = ( expr._eval_() )

    ptrb = ([ 0l,long(len(rhs.cof))])

    subj = ( Utils.Tools._arraycopy__3L (rhs.subj) )

    cof = ( Utils.Tools._arraycopy__3F (rhs.cof) )


    if   (rhs.bfix != None):
      bfix = 0.0

      # src/fusion/Expr.mbi(6139:11-6142:11)
      i = 0

      while (i < int(len(rhs.bfix))):
        bfix = (bfix + rhs.bfix[i])
        i += 1
      bfixarr = ([ 0.0 for _autovar_504 in xrange(1) ])
      bfixarr[0] = bfix
    else:
      bfixarr = None
    return mosek.fusion.Expr(ptrb,rhs.x,subj,cof,bfixarr,None,None,1)
  @staticmethod
  def _matchargs_numNonzeros_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expr.mbi(6156:15-6159:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numNonzeros()")
  def _numNonzeros_(self):
    return long(len(self.__cof_v))
  @staticmethod
  def _matchargs_sum_Omosek_fusion_Variable_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Expr.mbi(6170:15-6175:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("sum(mosek.fusion.Variable)")
  def _sum_Omosek_fusion_Variable_2(v):
    if   (v == None):
      raise Exception("Arguments for neg may not be null")
    return ( Expr._sum_Omosek_fusion_Expression_2 (( v._asExpr_() )) )
  @staticmethod
  def _matchargs_ones_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Expr.mbi(6182:15-6192:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("ones(int)")
  def _ones_I(num):
    ptrb = ( Utils.Tools._makevector_LI (0l,(1 + num)) )

    v = None

    subj = ([ 0l for _autovar_505 in xrange(0) ])

    cof = ([ 0.0 for _autovar_506 in xrange(0) ])

    bfix = ( Utils.Tools._ones_I (num) )

    return mosek.fusion.Expr(ptrb,v,subj,cof,bfix,None,None,1)
  @staticmethod
  def _matchargs_constTerm__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Expr.mbi(6199:15-6210:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("constTerm([float])")
  def _constTerm__3F(vals):
    if   (vals == None):
      raise Exception("Arguments for constTerm may not be null")
    ptrb = ( Utils.Tools._makevector_LI (0l,(int(len(vals)) + 1)) )

    v = None

    subj = ([ 0l for _autovar_507 in xrange(0) ])

    cof = ([ 0.0 for _autovar_508 in xrange(0) ])

    bfix = ( Utils.Tools._arraycopy__3F (vals) )

    return mosek.fusion.Expr(ptrb,v,subj,cof,bfix,None,None,1)
  @staticmethod
  def _matchargs_constTerm_IF(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Expr.mbi(6218:15-6228:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constTerm(int,float)")
  def _constTerm_IF(size,val):
    ptrb = ( Utils.Tools._makevector_LI (0l,(size + 1)) )

    v = None

    subj = ([ 0l for _autovar_509 in xrange(0) ])

    cof = ([ 0.0 for _autovar_510 in xrange(0) ])

    bfix = ( Utils.Tools._makevector_FI (val,size) )

    return mosek.fusion.Expr(ptrb,v,subj,cof,bfix,None,None,1)
  @staticmethod
  def _matchargs_constTerm_F(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],float): return False
    return True
  # origin: src/fusion/Expr.mbi(6231:15-6241:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("constTerm(float)")
  def _constTerm_F(val):
    ptrb = ([ 0l,0l])

    v = None

    subj = ([ 0l for _autovar_511 in xrange(0) ])

    cof = ([ 0.0 for _autovar_512 in xrange(0) ])

    bfix = ([ val])

    return mosek.fusion.Expr(ptrb,v,subj,cof,bfix,None,None,1)
  @staticmethod
  def _matchargs_zeros_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Expr.mbi(6249:15-6259:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("zeros(int)")
  def _zeros_I(num):
    ptrb = ( Utils.Tools._makevector_LI (0l,(1 + num)) )

    v = None

    subj = ([ 0l for _autovar_513 in xrange(0) ])

    cof = ([ 0.0 for _autovar_514 in xrange(0) ])

    bfix = ( Utils.Tools._zeros_I (num) )

    return mosek.fusion.Expr(ptrb,v,subj,cof,bfix,None,None,1)
  @staticmethod
  def _matchargs_eval_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expr.mbi(6263:15-6267:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("eval()")
  def _eval_(self):
    bfix_ = None

    if   (self.__bfix != None):
      bfix_ = ( Utils.Tools._arraycopy__3F (self.__bfix) )
    inst_ = None

    if   (self.__inst != None):
      inst_ = ( Utils.Tools._arraycopy__3L (self.__inst) )
    return mosek.fusion.FlatExpr(bfix_,( Utils.Tools._arraycopy__3L (self.__ptrb) ),( Utils.Tools._arraycopy__3L (self.__subj) ),self.__x,( Utils.Tools._arraycopy__3F (self.__cof_v) ),self._shape,self.__inst)
  @staticmethod
  def _matchargs_size_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Expr.mbi(6270:15-6272:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("size()")
  def _size_(self):
    return ( self._shape._getSize_() )
  @staticmethod
  def _matchargs_reshape_Omosek_fusion_Expression_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/Expr.mbi(6275:15-6299:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape(mosek.fusion.Expression,mosek.fusion.Set)")
  def _reshape_Omosek_fusion_Expression_2Omosek_fusion_Set_2(e,shp):
    if   ((e == None) or (shp == None)):
      raise Exception("Arguments for reshape may not be null")
    if   (shp._size != e._shape._size):
      raise mosek.fusion.DimensionError("New shape has wrong number of elements")
    strides = ([ 0l for _autovar_515 in xrange(shp.nd) ])

    strides[(shp.nd - 1)] = 1l
    _autovar_516 = e
    if   isinstance(_autovar_516,mosek.fusion.Expr):
      e_ = _autovar_516
      return mosek.fusion.Expr(e_.__ptrb,e_.__x,e_.__subj,e_.__cof_v,e_.__bfix,shp,e_.__inst,1)
    else:
      e_ = _autovar_516
      ef = ( e._eval_() )

      return mosek.fusion.Expr(ef.ptrb,ef.x,ef.subj,ef.cof,ef.bfix,shp,ef.inst,1)
  @staticmethod
  def _matchargs_reshape_Omosek_fusion_Expression_2I(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Expr.mbi(6302:15-6305:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape(mosek.fusion.Expression,int)")
  def _reshape_Omosek_fusion_Expression_2I(e,size):
    if   (e == None):
      raise Exception("Arguments for reshape may not be null")
    return ( Expr._reshape_Omosek_fusion_Expression_2Omosek_fusion_Set_2 (e,mosek.fusion.IntSet(size)) )
  @staticmethod
  def _matchargs_reshape_Omosek_fusion_Expression_2II(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    return True
  # origin: src/fusion/Expr.mbi(6307:15-6310:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("reshape(mosek.fusion.Expression,int,int)")
  def _reshape_Omosek_fusion_Expression_2II(e,dimi,dimj):
    if   (e == None):
      raise Exception("Arguments for reshape may not be null")
    return ( Expr._reshape_Omosek_fusion_Expression_2Omosek_fusion_Set_2 (e,mosek.fusion.NDSet(dimi,dimj)) )
  @staticmethod
  def _matchargs_flatten_Omosek_fusion_Expression_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Expr.mbi(6312:15-6315:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("flatten(mosek.fusion.Expression)")
  def _flatten_Omosek_fusion_Expression_2(e):
    if   (e == None):
      raise Exception("Arguments for flatten may not be null")
    return ( Expr._reshape_Omosek_fusion_Expression_2I (e,int(e._shape._size)) )
  @_cliptrace
  def toString(self,*args):
    if   Expression._matchargs_toString_(args):
      return Expression._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def hstack(*args):
    if   Expr._matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
      return Expr._hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack__3Omosek_fusion_Expression_2(args):
      return Expr._hstack__3Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack_FOmosek_fusion_Expression_2(args):
      return Expr._hstack_FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack_FOmosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Expr._hstack_FOmosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_hstack_FFOmosek_fusion_Expression_2(args):
      return Expr._hstack_FFOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Expression_2FOmosek_fusion_Expression_2(args):
      return Expr._hstack_Omosek_fusion_Expression_2FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack_FOmosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
      return Expr._hstack_FOmosek_fusion_Variable_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Expr._hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
      return Expr._hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_hstack_FOmosek_fusion_Variable_2(args):
      return Expr._hstack_FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2F(args):
      return Expr._hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Expr._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2F(args):
      return Expr._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
      return Expr._hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Variable_2F(args):
      return Expr._hstack_Omosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Variable_2FOmosek_fusion_Variable_2(args):
      return Expr._hstack_Omosek_fusion_Variable_2FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2F(args):
      return Expr._hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Expression_2F(args):
      return Expr._hstack_Omosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Expr._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_hstack_FOmosek_fusion_Variable_2F(args):
      return Expr._hstack_FOmosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_hstack_FFOmosek_fusion_Variable_2(args):
      return Expr._hstack_FFOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_hstack_FOmosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._hstack_FOmosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Variable_2FF(args):
      return Expr._hstack_Omosek_fusion_Variable_2FF(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
      return Expr._hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
      return Expr._hstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Expression_2FOmosek_fusion_Variable_2(args):
      return Expr._hstack_Omosek_fusion_Expression_2FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_hstack_FOmosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
      return Expr._hstack_FOmosek_fusion_Expression_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Expression_2FF(args):
      return Expr._hstack_Omosek_fusion_Expression_2FF(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._hstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2F(args):
      return Expr._hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_hstack_FOmosek_fusion_Expression_2F(args):
      return Expr._hstack_FOmosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
      return Expr._hstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Variable_2FOmosek_fusion_Expression_2(args):
      return Expr._hstack_Omosek_fusion_Variable_2FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._hstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    else:
      argtypestr = "hstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\thstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression)"),(1,"\thstack([mosek.fusion.Expression])"),(2,"\thstack(float,mosek.fusion.Expression)"),(3,"\thstack(float,mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\thstack(float,float,mosek.fusion.Expression)"),(3,"\thstack(mosek.fusion.Expression,float,mosek.fusion.Expression)"),(3,"\thstack(float,mosek.fusion.Variable,mosek.fusion.Expression)"),(3,"\thstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\thstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable)"),(2,"\thstack(float,mosek.fusion.Variable)"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Expression,float)"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,float)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Expression)"),(2,"\thstack(mosek.fusion.Variable,float)"),(3,"\thstack(mosek.fusion.Variable,float,mosek.fusion.Variable)"),(3,"\thstack(mosek.fusion.Expression,mosek.fusion.Variable,float)"),(2,"\thstack(mosek.fusion.Expression,float)"),(3,"\thstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)"),(2,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\thstack(float,mosek.fusion.Variable,float)"),(3,"\thstack(float,float,mosek.fusion.Variable)"),(3,"\thstack(float,mosek.fusion.Expression,mosek.fusion.Expression)"),(3,"\thstack(mosek.fusion.Variable,float,float)"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable)"),(2,"\thstack(mosek.fusion.Expression,mosek.fusion.Variable)"),(3,"\thstack(mosek.fusion.Expression,float,mosek.fusion.Variable)"),(3,"\thstack(float,mosek.fusion.Expression,mosek.fusion.Variable)"),(3,"\thstack(mosek.fusion.Expression,float,float)"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression)"),(3,"\thstack(mosek.fusion.Expression,mosek.fusion.Expression,float)"),(3,"\thstack(float,mosek.fusion.Expression,float)"),(3,"\thstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression)"),(3,"\thstack(mosek.fusion.Variable,float,mosek.fusion.Expression)"),(2,"\thstack(mosek.fusion.Expression,mosek.fusion.Expression)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def mulDiag(*args):
    if   Expr._matchargs_mulDiag_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
      return Expr._mulDiag_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
      return Expr._mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
      return Expr._mulDiag_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_mulDiag_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
      return Expr._mulDiag_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(*args)
    else:
      argtypestr = "mulDiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tmulDiag(mosek.fusion.Variable,mosek.fusion.Matrix)"),(2,"\tmulDiag(mosek.fusion.Matrix,mosek.fusion.Expression)"),(2,"\tmulDiag(mosek.fusion.Matrix,mosek.fusion.Variable)"),(2,"\tmulDiag(mosek.fusion.Expression,mosek.fusion.Matrix)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def vstack(*args):
    if   Expr._matchargs_vstack_FOmosek_fusion_Expression_2(args):
      return Expr._vstack_FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
      return Expr._vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2F(args):
      return Expr._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Variable_2FOmosek_fusion_Expression_2(args):
      return Expr._vstack_Omosek_fusion_Variable_2FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2FF(args):
      return Expr._vstack_Omosek_fusion_Expression_2FF(*args)
    elif Expr._matchargs_vstack_FOmosek_fusion_Variable_2(args):
      return Expr._vstack_FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
      return Expr._vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack__3Omosek_fusion_Expression_2(args):
      return Expr._vstack__3Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Variable_2FF(args):
      return Expr._vstack_Omosek_fusion_Variable_2FF(*args)
    elif Expr._matchargs_vstack_FOmosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
      return Expr._vstack_FOmosek_fusion_Expression_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_vstack_FOmosek_fusion_Expression_2F(args):
      return Expr._vstack_FOmosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_vstack_FOmosek_fusion_Variable_2F(args):
      return Expr._vstack_FOmosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2F(args):
      return Expr._vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Variable_2F(args):
      return Expr._vstack_Omosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Expr._vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Expr._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_vstack_FOmosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._vstack_FOmosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2F(args):
      return Expr._vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_vstack_FFOmosek_fusion_Variable_2(args):
      return Expr._vstack_FFOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2F(args):
      return Expr._vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_vstack_FFF(args):
      return Expr._vstack_FFF(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Expr._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_vstack_FOmosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Expr._vstack_FOmosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2FOmosek_fusion_Expression_2(args):
      return Expr._vstack_Omosek_fusion_Expression_2FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
      return Expr._vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_vstack_FOmosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
      return Expr._vstack_FOmosek_fusion_Variable_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2FOmosek_fusion_Variable_2(args):
      return Expr._vstack_Omosek_fusion_Expression_2FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
      return Expr._vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
      return Expr._vstack_Omosek_fusion_Variable_2Omosek_fusion_Variable_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._vstack_Omosek_fusion_Variable_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2F(args):
      return Expr._vstack_Omosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._vstack_Omosek_fusion_Expression_2Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Variable_2FOmosek_fusion_Variable_2(args):
      return Expr._vstack_Omosek_fusion_Variable_2FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
      return Expr._vstack_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_vstack_FFOmosek_fusion_Expression_2(args):
      return Expr._vstack_FFOmosek_fusion_Expression_2(*args)
    else:
      argtypestr = "vstack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tvstack(float,mosek.fusion.Expression)"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Expression)"),(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,float)"),(3,"\tvstack(mosek.fusion.Variable,float,mosek.fusion.Expression)"),(3,"\tvstack(mosek.fusion.Expression,float,float)"),(2,"\tvstack(float,mosek.fusion.Variable)"),(3,"\tvstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression)"),(1,"\tvstack([mosek.fusion.Expression])"),(3,"\tvstack(mosek.fusion.Variable,float,float)"),(3,"\tvstack(float,mosek.fusion.Expression,mosek.fusion.Variable)"),(3,"\tvstack(float,mosek.fusion.Expression,float)"),(3,"\tvstack(float,mosek.fusion.Variable,float)"),(3,"\tvstack(mosek.fusion.Expression,mosek.fusion.Expression,float)"),(2,"\tvstack(mosek.fusion.Variable,float)"),(3,"\tvstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\tvstack(float,mosek.fusion.Expression,mosek.fusion.Expression)"),(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Expression,float)"),(3,"\tvstack(float,float,mosek.fusion.Variable)"),(2,"\tvstack(mosek.fusion.Expression,mosek.fusion.Expression)"),(3,"\tvstack(mosek.fusion.Expression,mosek.fusion.Variable,float)"),(3,"\tvstack(float,float,float)"),(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\tvstack(float,mosek.fusion.Variable,mosek.fusion.Variable)"),(3,"\tvstack(mosek.fusion.Expression,float,mosek.fusion.Expression)"),(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable)"),(3,"\tvstack(float,mosek.fusion.Variable,mosek.fusion.Expression)"),(3,"\tvstack(mosek.fusion.Expression,float,mosek.fusion.Variable)"),(3,"\tvstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable)"),(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression)"),(3,"\tvstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression)"),(2,"\tvstack(mosek.fusion.Expression,float)"),(3,"\tvstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)"),(3,"\tvstack(mosek.fusion.Variable,float,mosek.fusion.Variable)"),(2,"\tvstack(mosek.fusion.Expression,mosek.fusion.Variable)"),(3,"\tvstack(float,float,mosek.fusion.Expression)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def ones(*args):
    if   Expr._matchargs_ones_I(args):
      return Expr._ones_I(*args)
    else:
      argtypestr = "ones(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tones(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def flatten(*args):
    if   Expr._matchargs_flatten_Omosek_fusion_Expression_2(args):
      return Expr._flatten_Omosek_fusion_Expression_2(*args)
    else:
      argtypestr = "flatten(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tflatten(mosek.fusion.Expression)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def eval(self,*args):
    if   Expr._matchargs_eval_(args):
      return Expr._eval_(self,*args)
    else:
      argtypestr = "eval(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\teval()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def numNonzeros(self,*args):
    if   Expr._matchargs_numNonzeros_(args):
      return Expr._numNonzeros_(self,*args)
    else:
      argtypestr = "numNonzeros(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumNonzeros()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   Expr._matchargs_size_(args):
      return Expr._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def sub(*args):
    if   Expr._matchargs_sub_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
      return Expr._sub_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
      return Expr._sub_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_sub_FOmosek_fusion_Expression_2(args):
      return Expr._sub_FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_sub_FOmosek_fusion_Variable_2(args):
      return Expr._sub_FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Expression_2_3F(args):
      return Expr._sub_Omosek_fusion_Expression_2_3F(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Variable_2F(args):
      return Expr._sub_Omosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_sub__3FOmosek_fusion_Variable_2(args):
      return Expr._sub__3FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Expression_2F(args):
      return Expr._sub_Omosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
      return Expr._sub_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Variable_2_3F(args):
      return Expr._sub_Omosek_fusion_Variable_2_3F(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
      return Expr._sub_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_sub__3FOmosek_fusion_Expression_2(args):
      return Expr._sub__3FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Expr._sub_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
      return Expr._sub_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
      return Expr._sub_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_sub__3F_3F(args):
      return Expr._sub__3F_3F(*args)
    elif Expr._matchargs_sub_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._sub_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    else:
      argtypestr = "sub(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tsub(mosek.fusion.Expression,mosek.fusion.Matrix)"),(2,"\tsub(mosek.fusion.Variable,mosek.fusion.Expression)"),(2,"\tsub(float,mosek.fusion.Expression)"),(2,"\tsub(float,mosek.fusion.Variable)"),(2,"\tsub(mosek.fusion.Expression,[float])"),(2,"\tsub(mosek.fusion.Variable,float)"),(2,"\tsub([float],mosek.fusion.Variable)"),(2,"\tsub(mosek.fusion.Expression,float)"),(2,"\tsub(mosek.fusion.Variable,mosek.fusion.Matrix)"),(2,"\tsub(mosek.fusion.Variable,[float])"),(2,"\tsub(mosek.fusion.Matrix,mosek.fusion.Variable)"),(2,"\tsub([float],mosek.fusion.Expression)"),(2,"\tsub(mosek.fusion.Variable,mosek.fusion.Variable)"),(2,"\tsub(mosek.fusion.Expression,mosek.fusion.Variable)"),(2,"\tsub(mosek.fusion.Matrix,mosek.fusion.Expression)"),(2,"\tsub([float],[float])"),(2,"\tsub(mosek.fusion.Expression,mosek.fusion.Expression)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def reshape(*args):
    if   Expr._matchargs_reshape_Omosek_fusion_Expression_2Omosek_fusion_Set_2(args):
      return Expr._reshape_Omosek_fusion_Expression_2Omosek_fusion_Set_2(*args)
    elif Expr._matchargs_reshape_Omosek_fusion_Expression_2II(args):
      return Expr._reshape_Omosek_fusion_Expression_2II(*args)
    elif Expr._matchargs_reshape_Omosek_fusion_Expression_2I(args):
      return Expr._reshape_Omosek_fusion_Expression_2I(*args)
    else:
      argtypestr = "reshape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\treshape(mosek.fusion.Expression,mosek.fusion.Set)"),(3,"\treshape(mosek.fusion.Expression,int,int)"),(2,"\treshape(mosek.fusion.Expression,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def sum(*args):
    if   Expr._matchargs_sum_Omosek_fusion_Expression_2(args):
      return Expr._sum_Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_sum_Omosek_fusion_Variable_2(args):
      return Expr._sum_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "sum(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsum(mosek.fusion.Expression)"),(1,"\tsum(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getModel(self,*args):
    if   Expression._matchargs_getModel_(args):
      return Expression._getModel_(self,*args)
    else:
      argtypestr = "getModel(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetModel()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def mulElm(*args):
    if   Expr._matchargs_mulElm_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
      return Expr._mulElm_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
      return Expr._mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_mulElm__3FOmosek_fusion_Expression_2(args):
      return Expr._mulElm__3FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_mulElm__3_3FOmosek_fusion_Variable_2(args):
      return Expr._mulElm__3_3FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_mulElm_Omosek_fusion_Variable_2_3_3F(args):
      return Expr._mulElm_Omosek_fusion_Variable_2_3_3F(*args)
    elif Expr._matchargs_mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
      return Expr._mulElm_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_mulElm_Omosek_fusion_Variable_2_3F(args):
      return Expr._mulElm_Omosek_fusion_Variable_2_3F(*args)
    elif Expr._matchargs_mulElm_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
      return Expr._mulElm_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_mulElm__3FOmosek_fusion_Variable_2(args):
      return Expr._mulElm__3FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_mulElm_Omosek_fusion_Expression_2_3F(args):
      return Expr._mulElm_Omosek_fusion_Expression_2_3F(*args)
    else:
      argtypestr = "mulElm(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tmulElm(mosek.fusion.Expression,mosek.fusion.Matrix)"),(2,"\tmulElm(mosek.fusion.Matrix,mosek.fusion.Variable)"),(2,"\tmulElm([float],mosek.fusion.Expression)"),(2,"\tmulElm([[float]],mosek.fusion.Variable)"),(2,"\tmulElm(mosek.fusion.Variable,[[float]])"),(2,"\tmulElm(mosek.fusion.Matrix,mosek.fusion.Expression)"),(2,"\tmulElm(mosek.fusion.Variable,[float])"),(2,"\tmulElm(mosek.fusion.Variable,mosek.fusion.Matrix)"),(2,"\tmulElm([float],mosek.fusion.Variable)"),(2,"\tmulElm(mosek.fusion.Expression,[float])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def add(*args):
    if   Expr._matchargs_add_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(args):
      return Expr._add_Omosek_fusion_Expression_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_add__3F_3F(args):
      return Expr._add__3F_3F(*args)
    elif Expr._matchargs_add__3FOmosek_fusion_Expression_2(args):
      return Expr._add__3FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Expression_2_3F(args):
      return Expr._add_Omosek_fusion_Expression_2_3F(*args)
    elif Expr._matchargs_add__3FOmosek_fusion_Variable_2(args):
      return Expr._add__3FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
      return Expr._add_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(args):
      return Expr._add_Omosek_fusion_Expression_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(args):
      return Expr._add_Omosek_fusion_Variable_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
      return Expr._add_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Variable_2F(args):
      return Expr._add_Omosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_add_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(args):
      return Expr._add_Omosek_fusion_Variable_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_add__3Omosek_fusion_Variable_2(args):
      return Expr._add__3Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Expression_2F(args):
      return Expr._add_Omosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_add__3Omosek_fusion_Expression_2(args):
      return Expr._add__3Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_add_Omosek_fusion_Variable_2_3F(args):
      return Expr._add_Omosek_fusion_Variable_2_3F(*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tadd(mosek.fusion.Expression,mosek.fusion.Variable)"),(2,"\tadd([float],[float])"),(2,"\tadd([float],mosek.fusion.Expression)"),(2,"\tadd(mosek.fusion.Expression,[float])"),(2,"\tadd([float],mosek.fusion.Variable)"),(2,"\tadd(mosek.fusion.Expression,mosek.fusion.Matrix)"),(2,"\tadd(mosek.fusion.Expression,mosek.fusion.Expression)"),(2,"\tadd(mosek.fusion.Variable,mosek.fusion.Expression)"),(2,"\tadd(mosek.fusion.Matrix,mosek.fusion.Expression)"),(2,"\tadd(mosek.fusion.Variable,float)"),(2,"\tadd(mosek.fusion.Variable,mosek.fusion.Variable)"),(1,"\tadd([mosek.fusion.Variable])"),(2,"\tadd(mosek.fusion.Expression,float)"),(1,"\tadd([mosek.fusion.Expression])"),(2,"\tadd(mosek.fusion.Variable,[float])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def stack(*args):
    if   Expr._matchargs_stack__3_3Omosek_fusion_Expression_2(args):
      return Expr._stack__3_3Omosek_fusion_Expression_2(*args)
    else:
      argtypestr = "stack(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tstack([[mosek.fusion.Expression]])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def constTerm(*args):
    if   Expr._matchargs_constTerm_F(args):
      return Expr._constTerm_F(*args)
    elif Expr._matchargs_constTerm_IF(args):
      return Expr._constTerm_IF(*args)
    elif Expr._matchargs_constTerm__3F(args):
      return Expr._constTerm__3F(*args)
    else:
      argtypestr = "constTerm(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tconstTerm(float)"),(2,"\tconstTerm(int,float)"),(1,"\tconstTerm([float])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getShape(self,*args):
    if   Expression._matchargs_getShape_(args):
      return Expression._getShape_(self,*args)
    else:
      argtypestr = "getShape(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetShape()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def zeros(*args):
    if   Expr._matchargs_zeros_I(args):
      return Expr._zeros_I(*args)
    else:
      argtypestr = "zeros(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tzeros(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def neg(*args):
    if   Expr._matchargs_neg_Omosek_fusion_Expression_2(args):
      return Expr._neg_Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_neg_Omosek_fusion_Variable_2(args):
      return Expr._neg_Omosek_fusion_Variable_2(*args)
    else:
      argtypestr = "neg(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tneg(mosek.fusion.Expression)"),(1,"\tneg(mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def mul(*args):
    if   Expr._matchargs_mul_FOmosek_fusion_Variable_2(args):
      return Expr._mul_FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_mul__3FOmosek_fusion_Variable_2(args):
      return Expr._mul__3FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Variable_2_3_3F(args):
      return Expr._mul_Omosek_fusion_Variable_2_3_3F(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Variable_2F(args):
      return Expr._mul_Omosek_fusion_Variable_2F(*args)
    elif Expr._matchargs_mul__3_3FOmosek_fusion_Variable_2(args):
      return Expr._mul__3_3FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
      return Expr._mul_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(args):
      return Expr._mul_Omosek_fusion_Expression_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Expression_2F(args):
      return Expr._mul_Omosek_fusion_Expression_2F(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Variable_2_3F(args):
      return Expr._mul_Omosek_fusion_Variable_2_3F(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Expression_2_3F(args):
      return Expr._mul_Omosek_fusion_Expression_2_3F(*args)
    elif Expr._matchargs_mul__3FOmosek_fusion_Expression_2(args):
      return Expr._mul__3FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_mul_FOmosek_fusion_Expression_2(args):
      return Expr._mul_FOmosek_fusion_Expression_2(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(args):
      return Expr._mul_Omosek_fusion_Matrix_2Omosek_fusion_Expression_2(*args)
    elif Expr._matchargs_mul_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
      return Expr._mul_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(*args)
    else:
      argtypestr = "mul(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tmul(float,mosek.fusion.Variable)"),(2,"\tmul([float],mosek.fusion.Variable)"),(2,"\tmul(mosek.fusion.Variable,[[float]])"),(2,"\tmul(mosek.fusion.Variable,float)"),(2,"\tmul([[float]],mosek.fusion.Variable)"),(2,"\tmul(mosek.fusion.Matrix,mosek.fusion.Variable)"),(2,"\tmul(mosek.fusion.Expression,mosek.fusion.Matrix)"),(2,"\tmul(mosek.fusion.Expression,float)"),(2,"\tmul(mosek.fusion.Variable,[float])"),(2,"\tmul(mosek.fusion.Expression,[float])"),(2,"\tmul([float],mosek.fusion.Expression)"),(2,"\tmul(float,mosek.fusion.Expression)"),(2,"\tmul(mosek.fusion.Matrix,mosek.fusion.Expression)"),(2,"\tmul(mosek.fusion.Variable,mosek.fusion.Matrix)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def dot(*args):
    if   Expr._matchargs_dot_Omosek_fusion_Expression_2_3F(args):
      return Expr._dot_Omosek_fusion_Expression_2_3F(*args)
    elif Expr._matchargs_dot__3FOmosek_fusion_Variable_2(args):
      return Expr._dot__3FOmosek_fusion_Variable_2(*args)
    elif Expr._matchargs_dot_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(args):
      return Expr._dot_Omosek_fusion_Matrix_2Omosek_fusion_Variable_2(*args)
    elif Expr._matchargs_dot_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(args):
      return Expr._dot_Omosek_fusion_Variable_2Omosek_fusion_Matrix_2(*args)
    elif Expr._matchargs_dot_Omosek_fusion_Variable_2_3F(args):
      return Expr._dot_Omosek_fusion_Variable_2_3F(*args)
    elif Expr._matchargs_dot__3FOmosek_fusion_Expression_2(args):
      return Expr._dot__3FOmosek_fusion_Expression_2(*args)
    else:
      argtypestr = "dot(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdot(mosek.fusion.Expression,[float])"),(2,"\tdot([float],mosek.fusion.Variable)"),(2,"\tdot(mosek.fusion.Matrix,mosek.fusion.Variable)"),(2,"\tdot(mosek.fusion.Variable,mosek.fusion.Matrix)"),(2,"\tdot(mosek.fusion.Variable,[float])"),(2,"\tdot([float],mosek.fusion.Expression)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(4:5-5330:4)
class Parameters:
  def __init__(self,*args):
    pass
  @staticmethod
  def _matchargs_string_1to_1solveform_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(8:10-14:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_solveform_value(basestring)")
  def __string_1to_1solveform_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "primal"):
      return 1
    elif (v == "dual"):
      return 2
    elif (v == "free"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1problemitem_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(16:10-22:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_problemitem_value(basestring)")
  def __string_1to_1problemitem_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "var"):
      return 0
    elif (v == "cone"):
      return 2
    elif (v == "con"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1accmode_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(24:10-29:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_accmode_value(basestring)")
  def __string_1to_1accmode_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "var"):
      return 0
    elif (v == "con"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1sensitivitytype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(31:10-36:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_sensitivitytype_value(basestring)")
  def __string_1to_1sensitivitytype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "optimalPartition"):
      return 1
    elif (v == "basis"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1uplo_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(38:10-43:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_uplo_value(basestring)")
  def __string_1to_1uplo_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "lo"):
      return 0
    elif (v == "up"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1intpnthotstart_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(45:10-52:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_intpnthotstart_value(basestring)")
  def __string_1to_1intpnthotstart_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "primal"):
      return 1
    elif (v == "none"):
      return 0
    elif (v == "dual"):
      return 2
    elif (v == "primalDual"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1sparam_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(54:10-83:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_sparam_value(basestring)")
  def __string_1to_1sparam_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "paramCommentSign"):
      return 9
    elif (v == "mioDebugString"):
      return 8
    elif (v == "feasrepairNamePrefix"):
      return 3
    elif (v == "basSolFileName"):
      return 0
    elif (v == "readMpsObjName"):
      return 13
    elif (v == "feasrepairNameWsumviol"):
      return 5
    elif (v == "feasrepairNameSeparator"):
      return 4
    elif (v == "paramWriteFileName"):
      return 11
    elif (v == "intSolFileName"):
      return 6
    elif (v == "readMpsRhsName"):
      return 15
    elif (v == "statFileName"):
      return 22
    elif (v == "writeLpGenVarName"):
      return 25
    elif (v == "dataFileName"):
      return 1
    elif (v == "readMpsRanName"):
      return 14
    elif (v == "solFilterXcLow"):
      return 18
    elif (v == "solFilterXcUpr"):
      return 19
    elif (v == "readMpsBouName"):
      return 12
    elif (v == "solFilterXxUpr"):
      return 21
    elif (v == "statName"):
      return 24
    elif (v == "paramReadFileName"):
      return 10
    elif (v == "itrSolFileName"):
      return 7
    elif (v == "sensitivityFileName"):
      return 16
    elif (v == "debugFileName"):
      return 2
    elif (v == "statKey"):
      return 23
    elif (v == "sensitivityResFileName"):
      return 17
    elif (v == "solFilterXxLow"):
      return 20
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1iparam_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(85:10-295:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_iparam_value(basestring)")
  def __string_1to_1iparam_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "simStabilityPriority"):
      return 169
    elif (v == "simPrimalPhaseoneMethod"):
      return 160
    elif (v == "infeasReportAuto"):
      return 21
    elif (v == "mioNodeOptimizer"):
      return 89
    elif (v == "writeIgnoreIncompatiblePsdItems"):
      return 190
    elif (v == "presolveLevel"):
      return 118
    elif (v == "logNonconvex"):
      return 57
    elif (v == "mioMtUserCb"):
      return 88
    elif (v == "presolveUse"):
      return 123
    elif (v == "logSensitivityOpt"):
      return 64
    elif (v == "opfWriteSolItg"):
      return 109
    elif (v == "writeBasHead"):
      return 179
    elif (v == "mioBranchPrioritiesUse"):
      return 72
    elif (v == "mioCutLevelTree"):
      return 78
    elif (v == "feasrepairOptimize"):
      return 18
    elif (v == "readMpsRelax"):
      return 138
    elif (v == "opfWriteParameters"):
      return 106
    elif (v == "readCon"):
      return 127
    elif (v == "writeIntVariables"):
      return 193
    elif (v == "logConcurrent"):
      return 46
    elif (v == "intpntOrderMethod"):
      return 32
    elif (v == "opfWriteSolItr"):
      return 110
    elif (v == "logSensitivity"):
      return 63
    elif (v == "readQnz"):
      return 140
    elif (v == "logInfeasAna"):
      return 53
    elif (v == "simPrimalSelection"):
      return 162
    elif (v == "mioCutCmir"):
      return 76
    elif (v == "writeIntConstraints"):
      return 191
    elif (v == "sensitivityType"):
      return 145
    elif (v == "simDualRestrictSelection"):
      return 150
    elif (v == "logMioFreq"):
      return 56
    elif (v == "opfWriteSolBas"):
      return 108
    elif (v == "mioRootOptimizer"):
      return 97
    elif (v == "writeFreeCon"):
      return 184
    elif (v == "presolveElimFill"):
      return 115
    elif (v == "nonconvexMaxIterations"):
      return 101
    elif (v == "mioLocalBranchNumber"):
      return 83
    elif (v == "writeGenericNames"):
      return 185
    elif (v == "warningLevel"):
      return 177
    elif (v == "logBiFreq"):
      return 44
    elif (v == "concurrentPriorityDualSimplex"):
      return 14
    elif (v == "logPresolve"):
      return 61
    elif (v == "writeLpStrictFormat"):
      return 196
    elif (v == "writeSolConstraints"):
      return 201
    elif (v == "intpntOffColTrh"):
      return 31
    elif (v == "readAnz"):
      return 126
    elif (v == "mioMode"):
      return 87
    elif (v == "primalRepairOptimizer"):
      return 124
    elif (v == "readLpDropNewVarsInBou"):
      return 133
    elif (v == "logSim"):
      return 65
    elif (v == "mtSpincount"):
      return 100
    elif (v == "solutionCallback"):
      return 175
    elif (v == "mioRinsMaxNodes"):
      return 96
    elif (v == "simScalingMethod"):
      return 167
    elif (v == "logSimFreq"):
      return 66
    elif (v == "presolveMaxNumReductions"):
      return 122
    elif (v == "writeLpQuotedNames"):
      return 195
    elif (v == "logFactor"):
      return 49
    elif (v == "autoUpdateSolInfo"):
      return 4
    elif (v == "readMpsWidth"):
      return 139
    elif (v == "timingLevel"):
      return 176
    elif (v == "logOrder"):
      return 59
    elif (v == "mioCutLevelRoot"):
      return 77
    elif (v == "paramReadIgnError"):
      return 114
    elif (v == "basisSolveUsePlusOne"):
      return 5
    elif (v == "biIgnoreNumError"):
      return 8
    elif (v == "mioNodeSelection"):
      return 90
    elif (v == "anaSolPrintViolated"):
      return 2
    elif (v == "solReadWidth"):
      return 174
    elif (v == "intpntMaxNumRefinementSteps"):
      return 30
    elif (v == "logSimMinor"):
      return 67
    elif (v == "simMaxIterations"):
      return 156
    elif (v == "mioProbingLevel"):
      return 95
    elif (v == "intpntMaxIterations"):
      return 28
    elif (v == "cacheLicense"):
      return 10
    elif (v == "logBi"):
      return 43
    elif (v == "intpntMaxNumCor"):
      return 29
    elif (v == "writeLpLineWidth"):
      return 194
    elif (v == "compressStatfile"):
      return 12
    elif (v == "solReadNameWidth"):
      return 173
    elif (v == "licenseDebug"):
      return 38
    elif (v == "licTrhExpiryWrn"):
      return 37
    elif (v == "anaSolBasis"):
      return 1
    elif (v == "presolveEliminatorMaxNumTries"):
      return 116
    elif (v == "writeGenericNamesIo"):
      return 186
    elif (v == "concurrentNumOptimizers"):
      return 13
    elif (v == "simRefactorFreq"):
      return 163
    elif (v == "simDualSelection"):
      return 151
    elif (v == "simSolveForm"):
      return 168
    elif (v == "checkConvexity"):
      return 11
    elif (v == "qoSeparableReformulation"):
      return 125
    elif (v == "writeIgnoreIncompatibleItems"):
      return 188
    elif (v == "readTaskIgnoreParam"):
      return 141
    elif (v == "mioOptimizerMode"):
      return 91
    elif (v == "logIntpnt"):
      return 54
    elif (v == "logMio"):
      return 55
    elif (v == "simHotstart"):
      return 153
    elif (v == "logParam"):
      return 60
    elif (v == "writeDataFormat"):
      return 182
    elif (v == "simExploitDupvec"):
      return 152
    elif (v == "mioBranchDir"):
      return 71
    elif (v == "intpntFactorDebugLvl"):
      return 25
    elif (v == "licensePauseTime"):
      return 39
    elif (v == "mioPresolveAggregate"):
      return 92
    elif (v == "writeTaskIncSol"):
      return 205
    elif (v == "biMaxIterations"):
      return 9
    elif (v == "simHotstartLu"):
      return 154
    elif (v == "presolveLindepRelWorkTrh"):
      return 120
    elif (v == "opfWriteSolutions"):
      return 111
    elif (v == "logFeasRepair"):
      return 50
    elif (v == "presolveLindepUse"):
      return 121
    elif (v == "intpntHotstart"):
      return 27
    elif (v == "opfWriteHeader"):
      return 104
    elif (v == "mioContSol"):
      return 74
    elif (v == "writeIntHead"):
      return 192
    elif (v == "intpntStartingPoint"):
      return 36
    elif (v == "writeSolBarvariables"):
      return 200
    elif (v == "simMaxNumSetbacks"):
      return 157
    elif (v == "concurrentPriorityPrimalSimplex"):
      return 17
    elif (v == "readMpsObjSense"):
      return 137
    elif (v == "logSimNetworkFreq"):
      return 68
    elif (v == "intpntDiffStep"):
      return 24
    elif (v == "simScaling"):
      return 166
    elif (v == "writeLpTermsPerLine"):
      return 197
    elif (v == "sensitivityAll"):
      return 143
    elif (v == "writeIgnoreIncompatibleConicItems"):
      return 187
    elif (v == "biIgnoreMaxIter"):
      return 7
    elif (v == "presolveLindepAbsWorkTrh"):
      return 119
    elif (v == "intpntSolveForm"):
      return 35
    elif (v == "opfMaxTermsPerLine"):
      return 103
    elif (v == "writePrecision"):
      return 199
    elif (v == "simBasisFactorUse"):
      return 146
    elif (v == "writeXmlMode"):
      return 206
    elif (v == "intpntRegularizationUse"):
      return 33
    elif (v == "biCleanOptimizer"):
      return 6
    elif (v == "mioPresolveProbing"):
      return 93
    elif (v == "infeasPreferPrimal"):
      return 20
    elif (v == "writeIgnoreIncompatibleNlItems"):
      return 189
    elif (v == "writeBasVariables"):
      return 180
    elif (v == "logStorage"):
      return 69
    elif (v == "mioPresolveUse"):
      return 94
    elif (v == "readLpQuotedNames"):
      return 134
    elif (v == "intpntBasis"):
      return 23
    elif (v == "logCutSecondOpt"):
      return 47
    elif (v == "readMpsKeepInt"):
      return 136
    elif (v == "mioMaxNumSolutions"):
      return 86
    elif (v == "readDebug"):
      return 131
    elif (v == "writeSolVariables"):
      return 204
    elif (v == "sensitivityOptimizer"):
      return 144
    elif (v == "writeMpsInt"):
      return 198
    elif (v == "licenseWait"):
      return 41
    elif (v == "concurrentPriorityFreeSimplex"):
      return 15
    elif (v == "readKeepFreeCon"):
      return 132
    elif (v == "logFile"):
      return 51
    elif (v == "concurrentPriorityIntpnt"):
      return 16
    elif (v == "simNonSingular"):
      return 158
    elif (v == "writeDataParam"):
      return 183
    elif (v == "simDegen"):
      return 147
    elif (v == "opfWriteHints"):
      return 105
    elif (v == "presolveEliminatorUse"):
      return 117
    elif (v == "allocAddQnz"):
      return 0
    elif (v == "mioHotstart"):
      return 81
    elif (v == "readMpsFormat"):
      return 135
    elif (v == "paramReadCaseName"):
      return 113
    elif (v == "logOptimizer"):
      return 58
    elif (v == "mioMaxNumBranches"):
      return 84
    elif (v == "simPrimalCrash"):
      return 159
    elif (v == "mioConstructSol"):
      return 73
    elif (v == "autoSortABeforeOpt"):
      return 3
    elif (v == "mioStrongBranch"):
      return 98
    elif (v == "simDualPhaseoneMethod"):
      return 149
    elif (v == "simInteger"):
      return 155
    elif (v == "mioUseMultithreadedOptimizer"):
      return 99
    elif (v == "simPrimalRestrictSelection"):
      return 161
    elif (v == "readCone"):
      return 128
    elif (v == "optimizer"):
      return 112
    elif (v == "maxNumWarnings"):
      return 70
    elif (v == "licenseSuppressExpireWrns"):
      return 40
    elif (v == "mioCutCg"):
      return 75
    elif (v == "writeSolIgnoreInvalidNames"):
      return 203
    elif (v == "writeSolHead"):
      return 202
    elif (v == "writeBasConstraints"):
      return 178
    elif (v == "logExpand"):
      return 48
    elif (v == "mioFeaspumpLevel"):
      return 79
    elif (v == "infeasGenericNames"):
      return 19
    elif (v == "logResponse"):
      return 62
    elif (v == "log"):
      return 42
    elif (v == "infeasReportLevel"):
      return 22
    elif (v == "writeDataCompressed"):
      return 181
    elif (v == "simSwitchOptimizer"):
      return 170
    elif (v == "readDataCompressed"):
      return 129
    elif (v == "solFilterKeepRanged"):
      return 172
    elif (v == "opfWriteProblem"):
      return 107
    elif (v == "numThreads"):
      return 102
    elif (v == "logCheckConvexity"):
      return 45
    elif (v == "readDataFormat"):
      return 130
    elif (v == "simDualCrash"):
      return 148
    elif (v == "readVar"):
      return 142
    elif (v == "logHead"):
      return 52
    elif (v == "simReformulation"):
      return 164
    elif (v == "simSaveLu"):
      return 165
    elif (v == "intpntFactorMethod"):
      return 26
    elif (v == "mioMaxNumRelaxs"):
      return 85
    elif (v == "solFilterKeepBasic"):
      return 171
    elif (v == "mioHeuristicLevel"):
      return 80
    elif (v == "mioKeepBasis"):
      return 82
    elif (v == "intpntScaling"):
      return 34
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1solsta_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(297:10-315:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_solsta_value(basestring)")
  def __string_1to_1solsta_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "dualInfeasCer"):
      return 6
    elif (v == "primInfeasCer"):
      return 5
    elif (v == "unknown"):
      return 0
    elif (v == "nearOptimal"):
      return 8
    elif (v == "nearPrimInfeasCer"):
      return 12
    elif (v == "primFeas"):
      return 2
    elif (v == "nearIntegerOptimal"):
      return 15
    elif (v == "nearDualFeas"):
      return 10
    elif (v == "integerOptimal"):
      return 14
    elif (v == "nearDualInfeasCer"):
      return 13
    elif (v == "nearPrimAndDualFeas"):
      return 11
    elif (v == "optimal"):
      return 1
    elif (v == "primAndDualFeas"):
      return 4
    elif (v == "nearPrimFeas"):
      return 9
    elif (v == "dualFeas"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1objsense_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(317:10-322:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_objsense_value(basestring)")
  def __string_1to_1objsense_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "minimize"):
      return 0
    elif (v == "maximize"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1solitem_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(324:10-335:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_solitem_value(basestring)")
  def __string_1to_1solitem_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "suc"):
      return 4
    elif (v == "xc"):
      return 0
    elif (v == "xx"):
      return 1
    elif (v == "y"):
      return 2
    elif (v == "slx"):
      return 5
    elif (v == "sux"):
      return 6
    elif (v == "snx"):
      return 7
    elif (v == "slc"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1boundkey_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(337:10-345:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_boundkey_value(basestring)")
  def __string_1to_1boundkey_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "fx"):
      return 2
    elif (v == "lo"):
      return 0
    elif (v == "fr"):
      return 3
    elif (v == "up"):
      return 1
    elif (v == "ra"):
      return 4
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1internal_1iinf_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(347:10-457:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_internal_iinf_value(basestring)")
  def __string_1to_1internal_1iinf_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "presolveNumvar"):
      return 75
    elif (v == "presolveNumnza"):
      return 74
    elif (v == "presolveFnumnza"):
      return 47
    elif (v == "presolveForceConNum"):
      return 55
    elif (v == "intpntFactorNum"):
      return 11
    elif (v == "presolveForceVarNumCon"):
      return 58
    elif (v == "presolveFnumvlo"):
      return 51
    elif (v == "simNetworkDualHotstartBasisRank"):
      return 88
    elif (v == "simNumNetworkVar"):
      return 96
    elif (v == "simNumDualIntegerPivots"):
      return 93
    elif (v == "presolveEliminatorSkippedSpace"):
      return 39
    elif (v == "presolveFnumcup"):
      return 46
    elif (v == "intpntNumqcones"):
      return 28
    elif (v == "presolveLindepWork"):
      return 64
    elif (v == "presolveOutofspace"):
      return 82
    elif (v == "intpntFactorDim"):
      return 10
    elif (v == "presolveLindepPivots"):
      return 62
    elif (v == "presolveNumvra"):
      return 80
    elif (v == "simNumDualBoundswaps"):
      return 92
    elif (v == "presolveNumclo"):
      return 69
    elif (v == "simPrimalTrust"):
      return 106
    elif (v == "presolveNumDouChains"):
      return 66
    elif (v == "intpntNumvar"):
      return 30
    elif (v == "presolveForceVarNum"):
      return 57
    elif (v == "simNumPrimalBoundswaps"):
      return 97
    elif (v == "simPrimalDualHotstartNumBasics"):
      return 100
    elif (v == "concurrentNumThreads"):
      return 3
    elif (v == "presolveFnumcon"):
      return 44
    elif (v == "presolveLindepNum"):
      return 59
    elif (v == "simPrimalHotstartBasisRank"):
      return 103
    elif (v == "presolveNumcra"):
      return 72
    elif (v == "numLuFactorizations"):
      return 32
    elif (v == "intpntNumbndconevar"):
      return 23
    elif (v == "concurrentOptimizerThread5"):
      return 9
    elif (v == "concurrentOptimizerThread2"):
      return 6
    elif (v == "concurrentOptimizerThread3"):
      return 7
    elif (v == "concurrentOptimizerThread0"):
      return 4
    elif (v == "concurrentOptimizerThread1"):
      return 5
    elif (v == "simPrimalHotstartNumBasics"):
      return 104
    elif (v == "simDualHotstartBasisRank"):
      return 84
    elif (v == "intpntNumcon"):
      return 25
    elif (v == "presolveFnumcfx"):
      return 41
    elif (v == "simDualTrust"):
      return 87
    elif (v == "presolveFnumcfr"):
      return 40
    elif (v == "presolveFnumvra"):
      return 53
    elif (v == "presolveNumcfr"):
      return 67
    elif (v == "presolveNumcnl"):
      return 70
    elif (v == "presolveNumcfx"):
      return 68
    elif (v == "intpntMaxbarvardim"):
      return 15
    elif (v == "simNetworkPrimalHotstartNumBasics"):
      return 91
    elif (v == "simNetworkPrimalHotstartBasisRank"):
      return 90
    elif (v == "presolveNumcup"):
      return 73
    elif (v == "simPrimalDualDoPrimalLog"):
      return 98
    elif (v == "presolvePivOnConNum"):
      return 83
    elif (v == "concurrentOptimizerThread4"):
      return 8
    elif (v == "concurrentNumOptimizers"):
      return 2
    elif (v == "intpntFactorNumSolve"):
      return 12
    elif (v == "intpntMinconedim"):
      return 17
    elif (v == "presolveNumvup"):
      return 81
    elif (v == "intpntNumblo"):
      return 22
    elif (v == "presolveFnumcra"):
      return 45
    elif (v == "intpntMaxconedim"):
      return 16
    elif (v == "presolveLindepSkipped"):
      return 63
    elif (v == "optObjectiveSense"):
      return 33
    elif (v == "presolveNumvnl"):
      return 79
    elif (v == "presolveNumvfr"):
      return 76
    elif (v == "presolveNumvfx"):
      return 77
    elif (v == "intpntNumcone"):
      return 26
    elif (v == "simDualHotstartNumBasics"):
      return 85
    elif (v == "presolveFnumvar"):
      return 48
    elif (v == "intpntNumbarvar"):
      return 19
    elif (v == "simNumDupvec"):
      return 94
    elif (v == "intpntFirRefIter"):
      return 13
    elif (v == "presolveFnumclo"):
      return 42
    elif (v == "simNetworkDualHotstartNumBasics"):
      return 89
    elif (v == "biDualInfo"):
      return 0
    elif (v == "presolveForceConNumVar"):
      return 56
    elif (v == "intpntNumbfr"):
      return 20
    elif (v == "nonconvexIter"):
      return 31
    elif (v == "intpntNumrqcones"):
      return 29
    elif (v == "intpntNumbfx"):
      return 21
    elif (v == "presolveFnumvup"):
      return 54
    elif (v == "intpntNumbup"):
      return 24
    elif (v == "simPrimalDualTrust"):
      return 102
    elif (v == "presolveFnumvnl"):
      return 52
    elif (v == "presolveLindepNumTries"):
      return 60
    elif (v == "biPrimalInfo"):
      return 1
    elif (v == "presolveNumvlo"):
      return 78
    elif (v == "optimizer"):
      return 34
    elif (v == "simNumNetworkCon"):
      return 95
    elif (v == "presolveNumcon"):
      return 71
    elif (v == "simDualNumSetbacks"):
      return 86
    elif (v == "presolveFnumvfr"):
      return 49
    elif (v == "simPrimalNumSetbacks"):
      return 105
    elif (v == "simPrimalDualHotstartBasisRank"):
      return 99
    elif (v == "presolveFnumvfx"):
      return 50
    elif (v == "simPrimalDualNumSetbacks"):
      return 101
    elif (v == "intpntGpOrderEmployed"):
      return 14
    elif (v == "presolveLindepNumTruncTries"):
      return 61
    elif (v == "presolveNumConsInDouChains"):
      return 65
    elif (v == "intpntNumRefSteps"):
      return 18
    elif (v == "presolveFnumcnl"):
      return 43
    elif (v == "intpntNumconevar"):
      return 27
    elif (v == "presolveEliNumTries"):
      return 38
    elif (v == "presolveEliNum"):
      return 37
    elif (v == "presolveCompressedStackSize"):
      return 36
    elif (v == "presolveBadPrecision"):
      return 35
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1basindtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(459:10-467:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_basindtype_value(basestring)")
  def __string_1to_1basindtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "always"):
      return 1
    elif (v == "noError"):
      return 2
    elif (v == "never"):
      return 0
    elif (v == "ifFeasible"):
      return 3
    elif (v == "reservered"):
      return 4
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1branchdir_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(469:10-475:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_branchdir_value(basestring)")
  def __string_1to_1branchdir_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "down"):
      return 2
    elif (v == "up"):
      return 1
    elif (v == "free"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1liinfitem_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(477:10-494:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_liinfitem_value(basestring)")
  def __string_1to_1liinfitem_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "biCleanPrimalIter"):
      return 6
    elif (v == "intpntFactorNumNz"):
      return 9
    elif (v == "mioIntpntIter"):
      return 10
    elif (v == "biCleanPrimalDualIter"):
      return 4
    elif (v == "biCleanPrimalDualDegIter"):
      return 3
    elif (v == "biCleanPrimalDegIter"):
      return 2
    elif (v == "biCleanDualIter"):
      return 1
    elif (v == "rdNumqnz"):
      return 13
    elif (v == "rdNumanz"):
      return 12
    elif (v == "biPrimalIter"):
      return 8
    elif (v == "biDualIter"):
      return 7
    elif (v == "biCleanDualDegIter"):
      return 0
    elif (v == "mioSimplexIter"):
      return 11
    elif (v == "biCleanPrimalDualSubIter"):
      return 5
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1streamtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(496:10-503:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_streamtype_value(basestring)")
  def __string_1to_1streamtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "msg"):
      return 1
    elif (v == "wrn"):
      return 3
    elif (v == "log"):
      return 0
    elif (v == "err"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1simhotstart_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(505:10-511:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_simhotstart_value(basestring)")
  def __string_1to_1simhotstart_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "none"):
      return 0
    elif (v == "statusKeys"):
      return 2
    elif (v == "free"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1callbackcode_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(513:10-630:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_callbackcode_value(basestring)")
  def __string_1to_1callbackcode_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "endIntpnt"):
      return 45
    elif (v == "beginPrimalDualSimplexBi"):
      return 21
    elif (v == "endNetworkPrimalSimplex"):
      return 49
    elif (v == "updatePrimalSimplexBi"):
      return 112
    elif (v == "endMio"):
      return 47
    elif (v == "beginNetworkDualSimplex"):
      return 13
    elif (v == "endPrimalRepair"):
      return 57
    elif (v == "endConcurrent"):
      return 36
    elif (v == "newIntMio"):
      return 96
    elif (v == "imPrimalSimplex"):
      return 90
    elif (v == "endSimplexNetworkDetect"):
      return 66
    elif (v == "endNetworkDualSimplex"):
      return 48
    elif (v == "imIntpnt"):
      return 74
    elif (v == "imDualBi"):
      return 70
    elif (v == "beginFullConvexityCheck"):
      return 8
    elif (v == "beginDualBi"):
      return 3
    elif (v == "beginDualSensitivity"):
      return 4
    elif (v == "imMioPrimalSimplex"):
      return 81
    elif (v == "beginPrimalBi"):
      return 19
    elif (v == "beginConcurrent"):
      return 1
    elif (v == "updateDualBi"):
      return 101
    elif (v == "imDualSimplex"):
      return 72
    elif (v == "beginPrimalRepair"):
      return 22
    elif (v == "beginLicenseWait"):
      return 11
    elif (v == "imNetworkPrimalSimplex"):
      return 83
    elif (v == "endNetworkSimplex"):
      return 50
    elif (v == "conic"):
      return 33
    elif (v == "imQoReformulate"):
      return 91
    elif (v == "beginConic"):
      return 2
    elif (v == "updateDualSimplexBi"):
      return 103
    elif (v == "endOptimizer"):
      return 52
    elif (v == "updatePresolve"):
      return 107
    elif (v == "imSimplex"):
      return 93
    elif (v == "readOpf"):
      return 99
    elif (v == "imLicenseWait"):
      return 75
    elif (v == "beginNetworkSimplex"):
      return 15
    elif (v == "endConic"):
      return 37
    elif (v == "updateNetworkDualSimplex"):
      return 104
    elif (v == "beginQcqoReformulate"):
      return 27
    elif (v == "endDualSensitivity"):
      return 39
    elif (v == "endPrimalSimplexBi"):
      return 61
    elif (v == "readOpfSection"):
      return 100
    elif (v == "imLu"):
      return 76
    elif (v == "endDualSimplexBi"):
      return 42
    elif (v == "endLicenseWait"):
      return 46
    elif (v == "imPresolve"):
      return 86
    elif (v == "beginDualSetupBi"):
      return 5
    elif (v == "endInfeasAna"):
      return 44
    elif (v == "intpnt"):
      return 95
    elif (v == "updatePrimalBi"):
      return 108
    elif (v == "noncovex"):
      return 97
    elif (v == "updatePrimalDualSimplexBi"):
      return 110
    elif (v == "updateNonconvex"):
      return 106
    elif (v == "endDualBi"):
      return 38
    elif (v == "endRead"):
      return 63
    elif (v == "beginPrimalSimplexBi"):
      return 26
    elif (v == "beginSimplexNetworkDetect"):
      return 31
    elif (v == "imPrimalDualSimplex"):
      return 88
    elif (v == "updatePrimalSimplex"):
      return 111
    elif (v == "dualSimplex"):
      return 34
    elif (v == "imFullConvexityCheck"):
      return 73
    elif (v == "primalSimplex"):
      return 98
    elif (v == "beginNonconvex"):
      return 16
    elif (v == "imSimplexBi"):
      return 94
    elif (v == "beginDualSimplex"):
      return 6
    elif (v == "beginPrimalSimplex"):
      return 25
    elif (v == "endNonconvex"):
      return 51
    elif (v == "beginPrimalSetupBi"):
      return 24
    elif (v == "imRead"):
      return 92
    elif (v == "beginOptimizer"):
      return 17
    elif (v == "beginRead"):
      return 28
    elif (v == "imNonconvex"):
      return 84
    elif (v == "endPrimalSimplex"):
      return 60
    elif (v == "endPrimalDualSimplexBi"):
      return 56
    elif (v == "imBi"):
      return 68
    elif (v == "imNetworkDualSimplex"):
      return 82
    elif (v == "endDualSetupBi"):
      return 40
    elif (v == "endBi"):
      return 35
    elif (v == "endPrimalSetupBi"):
      return 59
    elif (v == "beginWrite"):
      return 32
    elif (v == "endSimplexBi"):
      return 65
    elif (v == "endPrimalSensitivity"):
      return 58
    elif (v == "beginSimplex"):
      return 29
    elif (v == "endPresolve"):
      return 53
    elif (v == "beginInfeasAna"):
      return 9
    elif (v == "beginPrimalDualSimplex"):
      return 20
    elif (v == "beginPrimalSensitivity"):
      return 23
    elif (v == "beginDualSimplexBi"):
      return 7
    elif (v == "endQcqoReformulate"):
      return 62
    elif (v == "imPrimalSensivity"):
      return 89
    elif (v == "endWrite"):
      return 67
    elif (v == "endDualSimplex"):
      return 41
    elif (v == "updatePrimalDualSimplex"):
      return 109
    elif (v == "beginSimplexBi"):
      return 30
    elif (v == "beginIntpnt"):
      return 10
    elif (v == "imDualSensivity"):
      return 71
    elif (v == "endSimplex"):
      return 64
    elif (v == "endPrimalBi"):
      return 54
    elif (v == "imMio"):
      return 77
    elif (v == "updateDualSimplex"):
      return 102
    elif (v == "imMioIntpnt"):
      return 79
    elif (v == "endPrimalDualSimplex"):
      return 55
    elif (v == "imConic"):
      return 69
    elif (v == "imMioPresolve"):
      return 80
    elif (v == "beginBi"):
      return 0
    elif (v == "imMioDualSimplex"):
      return 78
    elif (v == "writeOpf"):
      return 113
    elif (v == "updateNetworkPrimalSimplex"):
      return 105
    elif (v == "endFullConvexityCheck"):
      return 43
    elif (v == "imOrder"):
      return 85
    elif (v == "imPrimalBi"):
      return 87
    elif (v == "beginPresolve"):
      return 18
    elif (v == "beginMio"):
      return 12
    elif (v == "beginNetworkPrimalSimplex"):
      return 14
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1symmattype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(632:10-636:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_symmattype_value(basestring)")
  def __string_1to_1symmattype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "sparse"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1feature_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(638:10-645:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_feature_value(basestring)")
  def __string_1to_1feature_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "ptom"):
      return 2
    elif (v == "pton"):
      return 1
    elif (v == "pts"):
      return 0
    elif (v == "ptox"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1mark_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(647:10-652:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_mark_value(basestring)")
  def __string_1to_1mark_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "lo"):
      return 0
    elif (v == "up"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1conetype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(654:10-659:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_conetype_value(basestring)")
  def __string_1to_1conetype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "quad"):
      return 0
    elif (v == "rquad"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1feasrepairtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(661:10-667:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_feasrepairtype_value(basestring)")
  def __string_1to_1feasrepairtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "optimizeNone"):
      return 0
    elif (v == "optimizeCombined"):
      return 2
    elif (v == "optimizePenalty"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1iomode_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(669:10-675:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_iomode_value(basestring)")
  def __string_1to_1iomode_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "read"):
      return 0
    elif (v == "write"):
      return 1
    elif (v == "readwrite"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1internal_1liinf_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(677:10-687:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_internal_liinf_value(basestring)")
  def __string_1to_1internal_1liinf_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "intpntLenbarvar"):
      return 5
    elif (v == "intpntFactorNumNzBefore"):
      return 2
    elif (v == "intpntFactorGpOrderSparseLNz"):
      return 0
    elif (v == "intpntFactorMlOrderSparseLNz"):
      return 1
    elif (v == "intpntFactorUpdatedVNz"):
      return 3
    elif (v == "intpntFactorVNz"):
      return 4
    elif (v == "presolveStackSize"):
      return 6
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1simseltype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(689:10-698:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_simseltype_value(basestring)")
  def __string_1to_1simseltype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "full"):
      return 1
    elif (v == "partial"):
      return 5
    elif (v == "free"):
      return 0
    elif (v == "ase"):
      return 2
    elif (v == "devex"):
      return 3
    elif (v == "se"):
      return 4
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1msgkey_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(700:10-706:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_msgkey_value(basestring)")
  def __string_1to_1msgkey_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "readingFile"):
      return 1000
    elif (v == "writingFile"):
      return 1001
    elif (v == "mpsSelected"):
      return 1100
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1miomode_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(708:10-714:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_miomode_value(basestring)")
  def __string_1to_1miomode_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "ignored"):
      return 0
    elif (v == "lazy"):
      return 2
    elif (v == "satisfied"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1dinfitem_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(716:10-789:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_dinfitem_value(basestring)")
  def __string_1to_1dinfitem_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "solItgPviolcones"):
      return 57
    elif (v == "intpntPrimalFeas"):
      return 13
    elif (v == "solItrDviolbarvar"):
      return 61
    elif (v == "mioCmirSeperationTime"):
      return 17
    elif (v == "solBasDviolvar"):
      return 50
    elif (v == "presolveEliTime"):
      return 33
    elif (v == "mioOptimizerTime"):
      return 25
    elif (v == "intpntFactorNumFlops"):
      return 10
    elif (v == "mioTime"):
      return 30
    elif (v == "biDualTime"):
      return 4
    elif (v == "solItrPviolcon"):
      return 67
    elif (v == "simNetworkTime"):
      return 43
    elif (v == "presolveTime"):
      return 35
    elif (v == "presolveLindepTime"):
      return 34
    elif (v == "simDualTime"):
      return 39
    elif (v == "mioProbingTime"):
      return 26
    elif (v == "mioRootCutgenTime"):
      return 27
    elif (v == "simObj"):
      return 44
    elif (v == "mioObjRelGap"):
      return 24
    elif (v == "solBasPrimalObj"):
      return 51
    elif (v == "mioHeuristicTime"):
      return 20
    elif (v == "mioCgSeperationTime"):
      return 16
    elif (v == "solItgPviolbarvar"):
      return 55
    elif (v == "optimizerTime"):
      return 32
    elif (v == "mioRootPresolveTime"):
      return 29
    elif (v == "solItgPviolcon"):
      return 56
    elif (v == "intpntDualObj"):
      return 9
    elif (v == "intpntTime"):
      return 15
    elif (v == "mioConstructSolutionObj"):
      return 18
    elif (v == "simFeas"):
      return 40
    elif (v == "simPrimalTime"):
      return 46
    elif (v == "simTime"):
      return 47
    elif (v == "simNetworkPrimalTime"):
      return 42
    elif (v == "mioDualBoundAfterPresolve"):
      return 19
    elif (v == "biCleanTime"):
      return 3
    elif (v == "qcqoReformulateTime"):
      return 37
    elif (v == "solItrDualObj"):
      return 60
    elif (v == "solItrPviolcones"):
      return 68
    elif (v == "intpntDualFeas"):
      return 8
    elif (v == "concurrentTime"):
      return 7
    elif (v == "solItrPviolbarvar"):
      return 66
    elif (v == "rdTime"):
      return 38
    elif (v == "solBasDviolcon"):
      return 49
    elif (v == "solItrPrimalObj"):
      return 65
    elif (v == "solItrPviolvar"):
      return 69
    elif (v == "solItrDviolcon"):
      return 62
    elif (v == "simNetworkDualTime"):
      return 41
    elif (v == "solItgPrimalObj"):
      return 54
    elif (v == "mioObjInt"):
      return 23
    elif (v == "mioUserObjCut"):
      return 31
    elif (v == "solItgPviolitg"):
      return 58
    elif (v == "intpntOptStatus"):
      return 11
    elif (v == "primalRepairPenaltyObj"):
      return 36
    elif (v == "mioObjBound"):
      return 22
    elif (v == "biCleanDualTime"):
      return 0
    elif (v == "biTime"):
      return 6
    elif (v == "solBasDualObj"):
      return 48
    elif (v == "biCleanPrimalDualTime"):
      return 1
    elif (v == "solItgPviolvar"):
      return 59
    elif (v == "intpntPrimalObj"):
      return 14
    elif (v == "intpntOrderTime"):
      return 12
    elif (v == "biPrimalTime"):
      return 5
    elif (v == "solBasPviolcon"):
      return 52
    elif (v == "mioObjAbsGap"):
      return 21
    elif (v == "solItrDviolvar"):
      return 64
    elif (v == "solItrDviolcones"):
      return 63
    elif (v == "solBasPviolvar"):
      return 53
    elif (v == "simPrimalDualTime"):
      return 45
    elif (v == "biCleanPrimalTime"):
      return 2
    elif (v == "mioRootOptimizerTime"):
      return 28
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1parametertype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(791:10-798:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_parametertype_value(basestring)")
  def __string_1to_1parametertype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "invalidType"):
      return 0
    elif (v == "strType"):
      return 3
    elif (v == "douType"):
      return 1
    elif (v == "intType"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1rescodetype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(800:10-808:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_rescodetype_value(basestring)")
  def __string_1to_1rescodetype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "wrn"):
      return 1
    elif (v == "trm"):
      return 2
    elif (v == "unk"):
      return 4
    elif (v == "ok"):
      return 0
    elif (v == "err"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1prosta_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(810:10-825:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_prosta_value(basestring)")
  def __string_1to_1prosta_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "primAndDualInfeas"):
      return 6
    elif (v == "primInfeas"):
      return 4
    elif (v == "illPosed"):
      return 7
    elif (v == "unknown"):
      return 0
    elif (v == "primFeas"):
      return 2
    elif (v == "nearPrimAndDualFeas"):
      return 8
    elif (v == "nearDualFeas"):
      return 10
    elif (v == "primInfeasOrUnbounded"):
      return 11
    elif (v == "primAndDualFeas"):
      return 1
    elif (v == "dualInfeas"):
      return 5
    elif (v == "nearPrimFeas"):
      return 9
    elif (v == "dualFeas"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1scalingtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(827:10-834:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_scalingtype_value(basestring)")
  def __string_1to_1scalingtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "none"):
      return 1
    elif (v == "moderate"):
      return 2
    elif (v == "aggressive"):
      return 3
    elif (v == "free"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1rescode_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(836:10-1279:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_rescode_value(basestring)")
  def __string_1to_1rescode_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "errParamType"):
      return 1218
    elif (v == "errInvSkx"):
      return 1268
    elif (v == "errMulAElement"):
      return 1254
    elif (v == "errInvalidNameInSolFile"):
      return 1170
    elif (v == "errInvalidNetworkProblem"):
      return 1504
    elif (v == "errMpsMulQsec"):
      return 1113
    elif (v == "errSenIndexInvalid"):
      return 3055
    elif (v == "errInvSkn"):
      return 1274
    elif (v == "errInvSkc"):
      return 1267
    elif (v == "errIndexIsTooLarge"):
      return 1204
    elif (v == "errCbfDuplicateBcoord"):
      return 7115
    elif (v == "errFeasrepairCannotRelax"):
      return 1700
    elif (v == "errInvConeTypeStr"):
      return 1271
    elif (v == "wrnLicenseFeatureExpire"):
      return 505
    elif (v == "errInvalidCompression"):
      return 1800
    elif (v == "wrnZerosInSparseRow"):
      return 705
    elif (v == "wrnSolFileIgnoredCon"):
      return 351
    elif (v == "errCbfDuplicateInt"):
      return 7110
    elif (v == "errArgIsTooLarge"):
      return 1227
    elif (v == "errLauSingularMatrix"):
      return 7000
    elif (v == "errUserNloFunc"):
      return 1432
    elif (v == "wrnZeroAij"):
      return 63
    elif (v == "errLauUnknown"):
      return 7001
    elif (v == "errLpWriteConicProblem"):
      return 1163
    elif (v == "errUpperBoundIsANan"):
      return 1391
    elif (v == "errSymMatDuplicate"):
      return 3944
    elif (v == "errIndexArrIsTooSmall"):
      return 1221
    elif (v == "errLicenseMax"):
      return 1016
    elif (v == "wrnDuplicateConstraintNames"):
      return 850
    elif (v == "errInvalidFormatType"):
      return 1283
    elif (v == "errNoPrimalInfeasCer"):
      return 2000
    elif (v == "errTooManyConcurrentTasks"):
      return 3090
    elif (v == "trmStall"):
      return 10006
    elif (v == "errOpfPrematureEof"):
      return 1172
    elif (v == "errLivingTasks"):
      return 1066
    elif (v == "errMaxnumcone"):
      return 1304
    elif (v == "errNumvarlim"):
      return 1251
    elif (v == "wrnUsingGenericNames"):
      return 503
    elif (v == "errRepairInvalidProblem"):
      return 1710
    elif (v == "errParamValueStr"):
      return 1217
    elif (v == "errQobjUpperTriangle"):
      return 1415
    elif (v == "errLowerBoundIsANan"):
      return 1390
    elif (v == "errNullPointer"):
      return 1065
    elif (v == "errParamNameStr"):
      return 1208
    elif (v == "errParamIsTooSmall"):
      return 1216
    elif (v == "errSolverProbtype"):
      return 1259
    elif (v == "errInfIntIndex"):
      return 1220
    elif (v == "errUserNloEvalHessubi"):
      return 1440
    elif (v == "errUserNloEvalHessubj"):
      return 1441
    elif (v == "errOpenDl"):
      return 1030
    elif (v == "errLast"):
      return 1262
    elif (v == "errLpEmpty"):
      return 1151
    elif (v == "errLicenseServerVersion"):
      return 1026
    elif (v == "errThreadMutexInit"):
      return 1045
    elif (v == "errInvNameItem"):
      return 1280
    elif (v == "errCbfTooManyConstraints"):
      return 7103
    elif (v == "wrnLargeLoBound"):
      return 52
    elif (v == "errSenBoundInvalidUp"):
      return 3053
    elif (v == "errMpsDuplicateQElement"):
      return 1121
    elif (v == "errDuplicateBarvariableNames"):
      return 4502
    elif (v == "errConeType"):
      return 1305
    elif (v == "errCbfInvalidVarType"):
      return 7111
    elif (v == "wrnAnaAlmostIntBounds"):
      return 904
    elif (v == "wrnConstructInvalidSolItg"):
      return 807
    elif (v == "errNullTask"):
      return 1061
    elif (v == "wrnLicenseExpire"):
      return 500
    elif (v == "errSpace"):
      return 1051
    elif (v == "errNullEnv"):
      return 1060
    elif (v == "errNumconlim"):
      return 1250
    elif (v == "errRepairOptimizationFailed"):
      return 1711
    elif (v == "errUnhandledSolutionStatus"):
      return 6010
    elif (v == "errCbfUnsupported"):
      return 7122
    elif (v == "wrnOpenParamFile"):
      return 50
    elif (v == "errInvalidVarName"):
      return 1077
    elif (v == "ok"):
      return 0
    elif (v == "errSenSolutionStatus"):
      return 3057
    elif (v == "errSizeLicenseCon"):
      return 1010
    elif (v == "errReadFormat"):
      return 1090
    elif (v == "wrnLargeCj"):
      return 57
    elif (v == "errCbfNoVersionSpecified"):
      return 7105
    elif (v == "errLicenseExpired"):
      return 1001
    elif (v == "errArgumentDimension"):
      return 1201
    elif (v == "errNanInBlc"):
      return 1461
    elif (v == "errNanInBlx"):
      return 1471
    elif (v == "errSymMatInvalidRowIndex"):
      return 3940
    elif (v == "errNonUniqueArray"):
      return 5000
    elif (v == "errInvalidFileFormatForSymMat"):
      return 4000
    elif (v == "errMpsMulConName"):
      return 1112
    elif (v == "errLicenseServer"):
      return 1015
    elif (v == "wrnTooFewBasisVars"):
      return 400
    elif (v == "errMpsInvBoundKey"):
      return 1108
    elif (v == "errThreadCreate"):
      return 1048
    elif (v == "errInvalidMaxNum"):
      return 1247
    elif (v == "errInvalidIomode"):
      return 1801
    elif (v == "errApiArrayTooSmall"):
      return 3001
    elif (v == "errInvalidAij"):
      return 1473
    elif (v == "errConeSize"):
      return 1301
    elif (v == "errUserFuncRet"):
      return 1430
    elif (v == "errMpsConeType"):
      return 1117
    elif (v == "errParamIsTooLarge"):
      return 1215
    elif (v == "wrnPresolveOutofspace"):
      return 802
    elif (v == "errSizeLicenseIntvar"):
      return 1012
    elif (v == "errNoOptimizerVarType"):
      return 1552
    elif (v == "errCbfTooFewVariables"):
      return 7117
    elif (v == "errGlobalInvConicProblem"):
      return 1503
    elif (v == "errMioNoOptimizer"):
      return 1551
    elif (v == "errLauArgTrans"):
      return 7008
    elif (v == "errArgumentPermArray"):
      return 1299
    elif (v == "errInvalidFileFormatForCones"):
      return 4005
    elif (v == "errObjQNotPsd"):
      return 1295
    elif (v == "errInternal"):
      return 3000
    elif (v == "errLpInvalidVarName"):
      return 1154
    elif (v == "errLpIncompatible"):
      return 1150
    elif (v == "errNoSolutionInCallback"):
      return 2500
    elif (v == "errInfLintIndex"):
      return 1225
    elif (v == "wrnTooManyBasisVars"):
      return 405
    elif (v == "errSpaceNoInfo"):
      return 1081
    elif (v == "wrnNzInUprTri"):
      return 200
    elif (v == "errInvQconSubi"):
      return 1405
    elif (v == "errCbfInvalidConType"):
      return 7112
    elif (v == "errInvQconSubk"):
      return 1404
    elif (v == "errInvQconSubj"):
      return 1406
    elif (v == "errArgumentType"):
      return 1198
    elif (v == "errEndOfFile"):
      return 1059
    elif (v == "errNonlinearEquality"):
      return 1290
    elif (v == "errNrArguments"):
      return 1199
    elif (v == "errConQNotPsd"):
      return 1293
    elif (v == "errInvalidConeName"):
      return 1078
    elif (v == "errInvalidConName"):
      return 1076
    elif (v == "errNonlinearRanged"):
      return 1292
    elif (v == "errWriteOpfInvalidVarName"):
      return 1156
    elif (v == "errSenFormat"):
      return 3050
    elif (v == "errNonconvex"):
      return 1291
    elif (v == "errUnbStepSize"):
      return 3100
    elif (v == "errMpsUndefVarName"):
      return 1106
    elif (v == "errInvalidFileName"):
      return 1056
    elif (v == "errFileWrite"):
      return 1054
    elif (v == "errMbtIncompatible"):
      return 2550
    elif (v == "errCannotHandleNl"):
      return 2506
    elif (v == "errNoBasisSol"):
      return 1600
    elif (v == "errOrdInvalid"):
      return 1131
    elif (v == "errApiCbConnect"):
      return 3002
    elif (v == "errObjQNotNsd"):
      return 1296
    elif (v == "errMpsNonSymmetricQ"):
      return 1120
    elif (v == "errUnknown"):
      return 1050
    elif (v == "errInfType"):
      return 1232
    elif (v == "errLinkFileDll"):
      return 1040
    elif (v == "wrnDuplicateVariableNames"):
      return 851
    elif (v == "errParamNameDou"):
      return 1206
    elif (v == "wrnDuplicateBarvariableNames"):
      return 852
    elif (v == "errNoBarsForSolution"):
      return 3916
    elif (v == "errThreadMutexLock"):
      return 1046
    elif (v == "errNonlinearFunctionsNotAllowed"):
      return 1428
    elif (v == "errLpFreeConstraint"):
      return 1155
    elif (v == "errLicenseInvalidHostid"):
      return 1025
    elif (v == "errInvConeType"):
      return 1272
    elif (v == "errInfIntName"):
      return 1231
    elif (v == "errCbfDuplicateObj"):
      return 7107
    elif (v == "errApiInternal"):
      return 3999
    elif (v == "errSenIndexRange"):
      return 3052
    elif (v == "errCbfInvalidIntIndex"):
      return 7121
    elif (v == "wrnParamNameDou"):
      return 510
    elif (v == "errInvQobjSubi"):
      return 1401
    elif (v == "errInvQobjSubj"):
      return 1402
    elif (v == "trmUserCallback"):
      return 10007
    elif (v == "errArgumentLenneq"):
      return 1197
    elif (v == "errInArgument"):
      return 1200
    elif (v == "errMaxnumvar"):
      return 1241
    elif (v == "errMpsInvField"):
      return 1101
    elif (v == "errAdInvalidOperand"):
      return 3104
    elif (v == "errOpfFormat"):
      return 1168
    elif (v == "wrnAnaLargeBounds"):
      return 900
    elif (v == "errCannotCloneNl"):
      return 2505
    elif (v == "errSymMatNotLowerTringular"):
      return 3942
    elif (v == "errMpsMulCsec"):
      return 1116
    elif (v == "errUserFuncRetData"):
      return 1431
    elif (v == "errInvConicProblem"):
      return 1502
    elif (v == "errInvAptre"):
      return 1253
    elif (v == "errBasisFactor"):
      return 1610
    elif (v == "errInvalidWchar"):
      return 2901
    elif (v == "errCbfParse"):
      return 7100
    elif (v == "wrnRquadConesWithRootFixedAtZero"):
      return 931
    elif (v == "errSizeLicense"):
      return 1005
    elif (v == "errNanInC"):
      return 1470
    elif (v == "errLpInvalidConName"):
      return 1171
    elif (v == "errMioInvalidRootOptimizer"):
      return 7130
    elif (v == "errHugeAij"):
      return 1380
    elif (v == "errCbfTooFewConstraints"):
      return 7118
    elif (v == "errAdMissingOperand"):
      return 3105
    elif (v == "errDuplicateConeNames"):
      return 4503
    elif (v == "errMbtInvalid"):
      return 2551
    elif (v == "wrnConstructNoSolItg"):
      return 810
    elif (v == "errObjectiveRange"):
      return 1260
    elif (v == "errMpsTabInField3"):
      return 1126
    elif (v == "errInfDouName"):
      return 1230
    elif (v == "errNegativeAppend"):
      return 1264
    elif (v == "errInvSk"):
      return 1270
    elif (v == "errParamNameInt"):
      return 1207
    elif (v == "errBasis"):
      return 1266
    elif (v == "errMaxnumbarvar"):
      return 1242
    elif (v == "wrnAnaEmptyCols"):
      return 902
    elif (v == "trmInternal"):
      return 10030
    elif (v == "errInvVarType"):
      return 1258
    elif (v == "errOpfNewVariable"):
      return 1169
    elif (v == "errFlexlm"):
      return 1014
    elif (v == "errLpWriteGecoProblem"):
      return 1164
    elif (v == "trmInternalStop"):
      return 10031
    elif (v == "errCbfTooFewInts"):
      return 7119
    elif (v == "wrnParamNameInt"):
      return 511
    elif (v == "errConeRepVar"):
      return 1303
    elif (v == "errInvProblem"):
      return 1500
    elif (v == "errLauArgN"):
      return 7003
    elif (v == "errLauArgM"):
      return 7002
    elif (v == "errLauArgK"):
      return 7004
    elif (v == "wrnNoDualizer"):
      return 950
    elif (v == "errMpsMulQobj"):
      return 1114
    elif (v == "wrnParamIgnoredCmio"):
      return 516
    elif (v == "errThreadMutexUnlock"):
      return 1047
    elif (v == "errInvQconVal"):
      return 1407
    elif (v == "errLuMaxNumTries"):
      return 2800
    elif (v == "wrnDroppedNzQobj"):
      return 201
    elif (v == "errBarVarDim"):
      return 3920
    elif (v == "trmMioNearRelGap"):
      return 10003
    elif (v == "errSenInvalidRegexp"):
      return 3056
    elif (v == "errLicenseVersion"):
      return 1002
    elif (v == "errSymMatInvalidValue"):
      return 3943
    elif (v == "errDataFileExt"):
      return 1055
    elif (v == "wrnLpDropVariable"):
      return 85
    elif (v == "errInfDouIndex"):
      return 1219
    elif (v == "errCbfDuplicateObjacoord"):
      return 7114
    elif (v == "errFactor"):
      return 1650
    elif (v == "errInvalidBranchPriority"):
      return 3201
    elif (v == "wrnParamNameStr"):
      return 512
    elif (v == "errMaxnumcon"):
      return 1240
    elif (v == "errLicenseFeature"):
      return 1018
    elif (v == "errReadLpNonexistingName"):
      return 1162
    elif (v == "errMpsNullVarName"):
      return 1104
    elif (v == "errCbfTooManyInts"):
      return 7120
    elif (v == "errMioInternal"):
      return 5010
    elif (v == "errLicenseNoServerSupport"):
      return 1027
    elif (v == "wrnSparMaxLen"):
      return 66
    elif (v == "errLicenseNoServerLine"):
      return 1028
    elif (v == "errConeIndex"):
      return 1300
    elif (v == "errProItem"):
      return 1281
    elif (v == "errCbfDuplicateAcoord"):
      return 7116
    elif (v == "errQconSubiTooSmall"):
      return 1408
    elif (v == "trmNumMaxNumIntSolutions"):
      return 10015
    elif (v == "errMpsTabInField2"):
      return 1125
    elif (v == "wrnMioInfeasibleFinal"):
      return 270
    elif (v == "errNoSnxForBasSol"):
      return 2953
    elif (v == "errMpsTabInField5"):
      return 1127
    elif (v == "wrnWriteDiscardedCfix"):
      return 804
    elif (v == "errInternalTestFailed"):
      return 3500
    elif (v == "errFileOpen"):
      return 1052
    elif (v == "wrnIgnoreInteger"):
      return 250
    elif (v == "errInvalidTask"):
      return 1064
    elif (v == "errDuplicateConstraintNames"):
      return 4500
    elif (v == "trmNumericalProblem"):
      return 10025
    elif (v == "errApiFatalError"):
      return 3005
    elif (v == "errInvOptimizer"):
      return 1550
    elif (v == "errRemoveConeVariable"):
      return 1310
    elif (v == "errSolFileInvalidNumber"):
      return 1350
    elif (v == "errFileRead"):
      return 1053
    elif (v == "errUpperTriangle"):
      return 6020
    elif (v == "wrnSolFilter"):
      return 300
    elif (v == "errMpsNoObjective"):
      return 1110
    elif (v == "errToconicConversionFail"):
      return 7200
    elif (v == "errConeOverlap"):
      return 1302
    elif (v == "errInvalidStream"):
      return 1062
    elif (v == "errInvalidAmplStub"):
      return 3700
    elif (v == "wrnLargeConFx"):
      return 54
    elif (v == "errCbfSyntax"):
      return 7106
    elif (v == "wrnAnaCZero"):
      return 901
    elif (v == "errTaskInvalid"):
      return 2561
    elif (v == "errMpsInvConKey"):
      return 1107
    elif (v == "errNoDualInfeasCer"):
      return 2001
    elif (v == "errFeasrepairInconsistentBound"):
      return 1702
    elif (v == "errInvalidBranchDirection"):
      return 3200
    elif (v == "errCbfInvalidDomainDimension"):
      return 7113
    elif (v == "errInfiniteBound"):
      return 1400
    elif (v == "errLauArgTransb"):
      return 7006
    elif (v == "errInvalidIdx"):
      return 1246
    elif (v == "errLauArgTransa"):
      return 7005
    elif (v == "errIdenticalTasks"):
      return 3101
    elif (v == "errWriteMpsInvalidName"):
      return 1153
    elif (v == "errInvalidWhichsol"):
      return 1228
    elif (v == "wrnLicenseServer"):
      return 501
    elif (v == "errMpsInvalidObjsense"):
      return 1122
    elif (v == "errInvSkStr"):
      return 1269
    elif (v == "errDupName"):
      return 1071
    elif (v == "wrnLargeBound"):
      return 51
    elif (v == "errOptimizerLicense"):
      return 1013
    elif (v == "errFileLicense"):
      return 1007
    elif (v == "errSolitem"):
      return 1237
    elif (v == "errPostsolve"):
      return 1580
    elif (v == "errPlatformNotLicensed"):
      return 1019
    elif (v == "errSenBoundInvalidLo"):
      return 3054
    elif (v == "errMpsSplittedVar"):
      return 1111
    elif (v == "errThreadCondInit"):
      return 1049
    elif (v == "errInvalidProblemType"):
      return 6000
    elif (v == "errCbfNoVariables"):
      return 7102
    elif (v == "errWhichitemNotAllowed"):
      return 1238
    elif (v == "errNewerDll"):
      return 1036
    elif (v == "errMaxLenIsTooSmall"):
      return 1289
    elif (v == "wrnEmptyName"):
      return 502
    elif (v == "errProbLicense"):
      return 1006
    elif (v == "wrnAnaCloseBounds"):
      return 903
    elif (v == "errArgIsTooSmall"):
      return 1226
    elif (v == "errWriteLpNonUniqueName"):
      return 1161
    elif (v == "errMpsInvSecName"):
      return 1109
    elif (v == "errLpFileFormat"):
      return 1157
    elif (v == "errLicenseCannotConnect"):
      return 1021
    elif (v == "errDuplicateVariableNames"):
      return 4501
    elif (v == "errInvBk"):
      return 1255
    elif (v == "errNanInDoubleData"):
      return 1450
    elif (v == "errNameMaxLen"):
      return 1750
    elif (v == "errOrdInvalidBranchDir"):
      return 1130
    elif (v == "errWritingFile"):
      return 1166
    elif (v == "errMpsUndefConName"):
      return 1105
    elif (v == "errArgumentIsTooLarge"):
      return 5005
    elif (v == "trmMaxIterations"):
      return 10000
    elif (v == "wrnSolFileIgnoredVar"):
      return 352
    elif (v == "errIndexIsTooSmall"):
      return 1203
    elif (v == "trmMioNearAbsGap"):
      return 10004
    elif (v == "errInvalidAccmode"):
      return 2520
    elif (v == "errLasti"):
      return 1286
    elif (v == "errNoInitEnv"):
      return 1063
    elif (v == "errUndefSolution"):
      return 1265
    elif (v == "errLastj"):
      return 1288
    elif (v == "wrnParamStrValue"):
      return 515
    elif (v == "errInfLintName"):
      return 1234
    elif (v == "errMissingLicenseFile"):
      return 1008
    elif (v == "errSenNumerical"):
      return 3058
    elif (v == "errNoDualForItgSol"):
      return 2950
    elif (v == "errOverflow"):
      return 1590
    elif (v == "errFirsti"):
      return 1285
    elif (v == "errMixedProblem"):
      return 1501
    elif (v == "errSymMatInvalidColIndex"):
      return 3941
    elif (v == "errNanInBux"):
      return 1472
    elif (v == "errLicenseMoseklmDaemon"):
      return 1017
    elif (v == "errConeTypeStr"):
      return 1306
    elif (v == "errNanInBuc"):
      return 1462
    elif (v == "errParamIndex"):
      return 1210
    elif (v == "errLicense"):
      return 1000
    elif (v == "errInvalidBarvarName"):
      return 1079
    elif (v == "errIndex"):
      return 1235
    elif (v == "errFirstj"):
      return 1287
    elif (v == "errSenUnhandledProblemType"):
      return 3080
    elif (v == "errSizeLicenseNumcores"):
      return 3900
    elif (v == "errNoBarxForSolution"):
      return 3915
    elif (v == "errInvNumi"):
      return 2503
    elif (v == "errInvNumj"):
      return 2504
    elif (v == "errMioInvalidNodeOptimizer"):
      return 7131
    elif (v == "errAdInvalidOperator"):
      return 3103
    elif (v == "trmMioNumBranches"):
      return 10009
    elif (v == "errLpDupSlackName"):
      return 1152
    elif (v == "errWriteLpFormat"):
      return 1158
    elif (v == "errMpsNullConName"):
      return 1103
    elif (v == "errCbfObjSense"):
      return 7101
    elif (v == "wrnEliminatorSpace"):
      return 801
    elif (v == "wrnZerosInSparseCol"):
      return 710
    elif (v == "wrnIncompleteLinearDependencyCheck"):
      return 800
    elif (v == "errInvalidSymMatDim"):
      return 3950
    elif (v == "errInvalidSurplus"):
      return 1275
    elif (v == "errMaxnumqnz"):
      return 1243
    elif (v == "errInvalidUtf8"):
      return 2900
    elif (v == "errInvalidObjName"):
      return 1075
    elif (v == "errParamName"):
      return 1205
    elif (v == "errAdInvalidCodelist"):
      return 3102
    elif (v == "errConcurrentOptimizer"):
      return 3059
    elif (v == "wrnLargeAij"):
      return 62
    elif (v == "errCbfDuplicateVar"):
      return 7109
    elif (v == "errMpsFile"):
      return 1100
    elif (v == "wrnNoGlobalOptimizer"):
      return 251
    elif (v == "errFeasrepairSolvingRelaxed"):
      return 1701
    elif (v == "trmMaxNumSetbacks"):
      return 10020
    elif (v == "errSizeLicenseVar"):
      return 1011
    elif (v == "wrnMpsSplitBouVector"):
      return 72
    elif (v == "errInt64ToInt32Cast"):
      return 3800
    elif (v == "errAdMissingReturn"):
      return 3106
    elif (v == "wrnLargeUpBound"):
      return 53
    elif (v == "errInfeasUndefined"):
      return 3910
    elif (v == "wrnNoNonlinearFunctionWrite"):
      return 450
    elif (v == "errQconUpperTriangle"):
      return 1417
    elif (v == "errMpsInvSecOrder"):
      return 1115
    elif (v == "errCbfDuplicateCon"):
      return 7108
    elif (v == "wrnConstructSolutionInfeas"):
      return 805
    elif (v == "errConQNotNsd"):
      return 1294
    elif (v == "errFixedBoundValues"):
      return 1425
    elif (v == "wrnMpsSplitRhsVector"):
      return 70
    elif (v == "errYIsUndefined"):
      return 1449
    elif (v == "errLicenseCannotAllocate"):
      return 1020
    elif (v == "errMioNotLoaded"):
      return 1553
    elif (v == "errCbfTooManyVariables"):
      return 7104
    elif (v == "errTooSmallMaxnumanz"):
      return 1252
    elif (v == "errTaskIncompatible"):
      return 2560
    elif (v == "errInvalidObjectiveSense"):
      return 1445
    elif (v == "wrnDuplicateConeNames"):
      return 853
    elif (v == "wrnNameMaxLen"):
      return 65
    elif (v == "wrnWriteChangedNames"):
      return 803
    elif (v == "errLpFormat"):
      return 1160
    elif (v == "errInvalidFileFormatForGeneralNl"):
      return 4010
    elif (v == "errMpsConeOverlap"):
      return 1118
    elif (v == "trmMioNumRelaxs"):
      return 10008
    elif (v == "errInvalidSolFileName"):
      return 1057
    elif (v == "errUserNloEval"):
      return 1433
    elif (v == "errOlderDll"):
      return 1035
    elif (v == "errMpsConeRepeat"):
      return 1119
    elif (v == "errInvQobjVal"):
      return 1403
    elif (v == "wrnMpsSplitRanVector"):
      return 71
    elif (v == "errSpaceLeaking"):
      return 1080
    elif (v == "errXmlInvalidProblemType"):
      return 3600
    elif (v == "errReadLpMissingEndTag"):
      return 1159
    elif (v == "trmMaxTime"):
      return 10001
    elif (v == "wrnQuadConesWithRootFixedAtZero"):
      return 930
    elif (v == "errWhichsol"):
      return 1236
    elif (v == "errConeOverlapAppend"):
      return 1307
    elif (v == "errBasisSingular"):
      return 1615
    elif (v == "wrnTooManyThreadsConcurrent"):
      return 750
    elif (v == "errQconSubiTooLarge"):
      return 1409
    elif (v == "errSenUndefName"):
      return 3051
    elif (v == "wrnLpOldQuadFormat"):
      return 80
    elif (v == "errMpsInvMarker"):
      return 1102
    elif (v == "errNegativeSurplus"):
      return 1263
    elif (v == "errInvBkx"):
      return 1257
    elif (v == "errMpsInvalidObjName"):
      return 1128
    elif (v == "errIndexArrIsTooLarge"):
      return 1222
    elif (v == "errNoDualInfoForItgSol"):
      return 3300
    elif (v == "trmObjectiveRange"):
      return 10002
    elif (v == "wrnUndefSolFileName"):
      return 350
    elif (v == "errInvBkc"):
      return 1256
    elif (v == "errBlankName"):
      return 1070
    elif (v == "errFirst"):
      return 1261
    elif (v == "errHugeC"):
      return 1375
    elif (v == "errUndefinedObjectiveSense"):
      return 1446
    elif (v == "errTooSmallMaxNumNz"):
      return 1245
    elif (v == "errInvMarki"):
      return 2501
    elif (v == "errInvMarkj"):
      return 2502
    elif (v == "errNameIsNull"):
      return 1760
    elif (v == "errLauArgUplo"):
      return 7007
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1mionodeseltype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1281:10-1290:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_mionodeseltype_value(basestring)")
  def __string_1to_1mionodeseltype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "pseudo"):
      return 5
    elif (v == "hybrid"):
      return 4
    elif (v == "free"):
      return 0
    elif (v == "worst"):
      return 3
    elif (v == "best"):
      return 2
    elif (v == "first"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1transpose_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1292:10-1297:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_transpose_value(basestring)")
  def __string_1to_1transpose_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "yes"):
      return 1
    elif (v == "no"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1onoffkey_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1299:10-1304:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_onoffkey_value(basestring)")
  def __string_1to_1onoffkey_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "on"):
      return 1
    elif (v == "off"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1simdegen_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1306:10-1314:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_simdegen_value(basestring)")
  def __string_1to_1simdegen_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "none"):
      return 0
    elif (v == "moderate"):
      return 3
    elif (v == "minimum"):
      return 4
    elif (v == "aggressive"):
      return 2
    elif (v == "free"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1dataformat_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1316:10-1327:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_dataformat_value(basestring)")
  def __string_1to_1dataformat_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "xml"):
      return 4
    elif (v == "task"):
      return 6
    elif (v == "extension"):
      return 0
    elif (v == "cb"):
      return 7
    elif (v == "freeMps"):
      return 5
    elif (v == "lp"):
      return 2
    elif (v == "op"):
      return 3
    elif (v == "mps"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1orderingtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1329:10-1338:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_orderingtype_value(basestring)")
  def __string_1to_1orderingtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "none"):
      return 5
    elif (v == "forceGraphpar"):
      return 4
    elif (v == "appminloc"):
      return 1
    elif (v == "tryGraphpar"):
      return 3
    elif (v == "free"):
      return 0
    elif (v == "experimental"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1problemtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1340:10-1349:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_problemtype_value(basestring)")
  def __string_1to_1problemtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "qcqo"):
      return 2
    elif (v == "lo"):
      return 0
    elif (v == "conic"):
      return 4
    elif (v == "geco"):
      return 3
    elif (v == "mixed"):
      return 5
    elif (v == "qo"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1inftype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1351:10-1357:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_inftype_value(basestring)")
  def __string_1to_1inftype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "douType"):
      return 0
    elif (v == "lintType"):
      return 2
    elif (v == "intType"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1dparam_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1359:10-1432:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_dparam_value(basestring)")
  def __string_1to_1dparam_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "lowerObjCutFiniteTrh"):
      return 39
    elif (v == "mioMaxTime"):
      return 42
    elif (v == "basisTolS"):
      return 2
    elif (v == "presolveTolS"):
      return 63
    elif (v == "upperObjCut"):
      return 68
    elif (v == "intpntCoTolDfeas"):
      return 15
    elif (v == "dataTolAijLarge"):
      return 7
    elif (v == "mioTolAbsGap"):
      return 48
    elif (v == "upperObjCutFiniteTrh"):
      return 69
    elif (v == "mioTolAbsRelaxInt"):
      return 49
    elif (v == "nonconvexTolOpt"):
      return 58
    elif (v == "nonconvexTolFeas"):
      return 57
    elif (v == "mioTolMaxCutFracRhs"):
      return 51
    elif (v == "simplexAbsTolPiv"):
      return 67
    elif (v == "mioTolRelDualBoundImprovement"):
      return 53
    elif (v == "mioHeuristicTime"):
      return 41
    elif (v == "checkConvexityRelTol"):
      return 4
    elif (v == "presolveTolX"):
      return 64
    elif (v == "intpntNlTolMuRed"):
      return 23
    elif (v == "mioNearTolRelGap"):
      return 45
    elif (v == "mioTolMinCutFracRhs"):
      return 52
    elif (v == "presolveTolRelLindep"):
      return 62
    elif (v == "dataTolAij"):
      return 5
    elif (v == "feasrepairTol"):
      return 14
    elif (v == "intpntTolDsafe"):
      return 29
    elif (v == "mioTolFeas"):
      return 50
    elif (v == "intpntTolInfeas"):
      return 30
    elif (v == "intpntNlTolNearRel"):
      return 24
    elif (v == "optimizerMaxTime"):
      return 59
    elif (v == "dataTolX"):
      return 13
    elif (v == "anaSolInfeasTol"):
      return 0
    elif (v == "mioRelAddCutLimited"):
      return 46
    elif (v == "intpntTolMuRed"):
      return 31
    elif (v == "intpntCoTolMuRed"):
      return 17
    elif (v == "intpntCoTolRelGap"):
      return 20
    elif (v == "lowerObjCut"):
      return 38
    elif (v == "mioDisableTermTime"):
      return 40
    elif (v == "intpntTolRelStep"):
      return 36
    elif (v == "mioTolX"):
      return 56
    elif (v == "dataTolCHuge"):
      return 10
    elif (v == "simLuTolRelPiv"):
      return 66
    elif (v == "dataTolCjLarge"):
      return 11
    elif (v == "intpntNlTolRelStep"):
      return 27
    elif (v == "intpntTolStepSize"):
      return 37
    elif (v == "intpntTolPfeas"):
      return 33
    elif (v == "basisRelTolS"):
      return 1
    elif (v == "presolveTolAbsLindep"):
      return 60
    elif (v == "intpntCoTolInfeas"):
      return 16
    elif (v == "mioRelGapConst"):
      return 47
    elif (v == "presolveTolAij"):
      return 61
    elif (v == "mioMaxTimeAprxOpt"):
      return 43
    elif (v == "intpntTolPath"):
      return 32
    elif (v == "intpntNlMeritBal"):
      return 21
    elif (v == "basisTolX"):
      return 3
    elif (v == "intpntTolRelGap"):
      return 35
    elif (v == "dataTolAijHuge"):
      return 6
    elif (v == "dataTolBoundWrn"):
      return 9
    elif (v == "dataTolBoundInf"):
      return 8
    elif (v == "intpntTolPsafe"):
      return 34
    elif (v == "intpntCoTolNearRel"):
      return 18
    elif (v == "intpntNlTolPfeas"):
      return 25
    elif (v == "intpntNlTolDfeas"):
      return 22
    elif (v == "mioTolRelGap"):
      return 54
    elif (v == "intpntTolDfeas"):
      return 28
    elif (v == "mioNearTolAbsGap"):
      return 44
    elif (v == "mioTolRelRelaxInt"):
      return 55
    elif (v == "qcqoReformulateRelDropTol"):
      return 65
    elif (v == "dataTolQij"):
      return 12
    elif (v == "intpntNlTolRelGap"):
      return 26
    elif (v == "intpntCoTolPfeas"):
      return 19
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1simdupvec_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1434:10-1440:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_simdupvec_value(basestring)")
  def __string_1to_1simdupvec_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "on"):
      return 1
    elif (v == "off"):
      return 0
    elif (v == "free"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1compresstype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1442:10-1448:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_compresstype_value(basestring)")
  def __string_1to_1compresstype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "gzip"):
      return 2
    elif (v == "none"):
      return 0
    elif (v == "free"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1nametype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1450:10-1456:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_nametype_value(basestring)")
  def __string_1to_1nametype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "gen"):
      return 0
    elif (v == "lp"):
      return 2
    elif (v == "mps"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1mpsformat_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1458:10-1464:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_mpsformat_value(basestring)")
  def __string_1to_1mpsformat_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "strict"):
      return 0
    elif (v == "relaxed"):
      return 1
    elif (v == "free"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1variabletype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1466:10-1471:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_variabletype_value(basestring)")
  def __string_1to_1variabletype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "typeInt"):
      return 1
    elif (v == "typeCont"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1checkconvexitytype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1473:10-1479:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_checkconvexitytype_value(basestring)")
  def __string_1to_1checkconvexitytype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "simple"):
      return 1
    elif (v == "none"):
      return 0
    elif (v == "full"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1language_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1481:10-1486:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_language_value(basestring)")
  def __string_1to_1language_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "dan"):
      return 1
    elif (v == "eng"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1startpointtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1488:10-1495:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_startpointtype_value(basestring)")
  def __string_1to_1startpointtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "guess"):
      return 1
    elif (v == "satisfyBounds"):
      return 3
    elif (v == "constant"):
      return 2
    elif (v == "free"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1soltype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1497:10-1503:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_soltype_value(basestring)")
  def __string_1to_1soltype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "itg"):
      return 2
    elif (v == "itr"):
      return 0
    elif (v == "bas"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1scalingmethod_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1505:10-1510:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_scalingmethod_value(basestring)")
  def __string_1to_1scalingmethod_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "pow2"):
      return 0
    elif (v == "free"):
      return 1
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1value_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1512:10-1517:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_value_value(basestring)")
  def __string_1to_1value_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "maxStrLen"):
      return 1024
    elif (v == "licenseBufferLength"):
      return 20
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1stakey_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1519:10-1529:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_stakey_value(basestring)")
  def __string_1to_1stakey_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "supbas"):
      return 2
    elif (v == "bas"):
      return 1
    elif (v == "fix"):
      return 5
    elif (v == "low"):
      return 3
    elif (v == "inf"):
      return 6
    elif (v == "unk"):
      return 0
    elif (v == "upr"):
      return 4
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1simreform_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1531:10-1538:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_simreform_value(basestring)")
  def __string_1to_1simreform_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "on"):
      return 1
    elif (v == "aggressive"):
      return 3
    elif (v == "off"):
      return 0
    elif (v == "free"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1iinfitem_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1540:10-1640:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_iinfitem_value(basestring)")
  def __string_1to_1iinfitem_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "rdNumintvar"):
      return 54
    elif (v == "mioNumGcdCuts"):
      return 32
    elif (v == "rdNumbarvar"):
      return 51
    elif (v == "mioNumDisaggCuts"):
      return 30
    elif (v == "solBasSolsta"):
      return 87
    elif (v == "stoNumATransposes"):
      return 96
    elif (v == "simSolveDual"):
      return 85
    elif (v == "mioNumcon"):
      return 42
    elif (v == "optNumvar"):
      return 49
    elif (v == "simNumvar"):
      return 74
    elif (v == "stoNumARealloc"):
      return 95
    elif (v == "mioNumLatticeCuts"):
      return 37
    elif (v == "simNetworkPrimalDegIter"):
      return 68
    elif (v == "rdNumq"):
      return 55
    elif (v == "mioNumFlowCoverCuts"):
      return 31
    elif (v == "mioNumBasisCuts"):
      return 24
    elif (v == "anaProNumCon"):
      return 0
    elif (v == "anaProNumVarInt"):
      return 11
    elif (v == "simNetworkDualInfIter"):
      return 66
    elif (v == "anaProNumVarCont"):
      return 8
    elif (v == "simDualIter"):
      return 62
    elif (v == "simDualDegIter"):
      return 58
    elif (v == "intpntIter"):
      return 17
    elif (v == "simNumcon"):
      return 73
    elif (v == "simPrimalDualIter"):
      return 80
    elif (v == "anaProNumConUp"):
      return 5
    elif (v == "mioNumKnapsurCoverCuts"):
      return 36
    elif (v == "simPrimalDualHotstart"):
      return 77
    elif (v == "intpntSolveDual"):
      return 19
    elif (v == "simNetworkDualHotstart"):
      return 64
    elif (v == "optimizeResponse"):
      return 50
    elif (v == "mioNumGomoryCuts"):
      return 33
    elif (v == "solItrProsta"):
      return 92
    elif (v == "mioNumCoefRedcCuts"):
      return 28
    elif (v == "rdProtype"):
      return 57
    elif (v == "mioNumCardgubCuts"):
      return 26
    elif (v == "solItrSolsta"):
      return 93
    elif (v == "mioNumLiftCuts"):
      return 38
    elif (v == "anaProNumConFr"):
      return 2
    elif (v == "simPrimalDualHotstartLu"):
      return 78
    elif (v == "mioNumint"):
      return 43
    elif (v == "solItgSolsta"):
      return 91
    elif (v == "simDualInfIter"):
      return 61
    elif (v == "mioNumvar"):
      return 44
    elif (v == "mioConstructSolution"):
      return 21
    elif (v == "anaProNumVar"):
      return 6
    elif (v == "stoNumACacheFlushes"):
      return 94
    elif (v == "solIntProsta"):
      return 88
    elif (v == "simNetworkDualDegIter"):
      return 63
    elif (v == "solIntSolsta"):
      return 89
    elif (v == "rdNumvar"):
      return 56
    elif (v == "simPrimalDualDegIter"):
      return 76
    elif (v == "anaProNumVarLo"):
      return 12
    elif (v == "solBasProsta"):
      return 86
    elif (v == "simNetworkPrimalIter"):
      return 72
    elif (v == "anaProNumConLo"):
      return 3
    elif (v == "mioNumContraCuts"):
      return 29
    elif (v == "simNetworkDualHotstartLu"):
      return 65
    elif (v == "simNetworkPrimalInfIter"):
      return 71
    elif (v == "simPrimalHotstart"):
      return 81
    elif (v == "mioNumBranch"):
      return 25
    elif (v == "mioNumGubCoverCuts"):
      return 34
    elif (v == "mioNumRelax"):
      return 41
    elif (v == "mioNumObjCuts"):
      return 39
    elif (v == "mioNumIntSolutions"):
      return 35
    elif (v == "simPrimalHotstartLu"):
      return 82
    elif (v == "mioConstructNumRoundings"):
      return 20
    elif (v == "anaProNumConEq"):
      return 1
    elif (v == "anaProNumVarRa"):
      return 13
    elif (v == "mioObjBoundDefined"):
      return 45
    elif (v == "simPrimalInfIter"):
      return 83
    elif (v == "rdNumcon"):
      return 52
    elif (v == "rdNumcone"):
      return 53
    elif (v == "anaProNumVarFr"):
      return 10
    elif (v == "mioNumActiveNodes"):
      return 23
    elif (v == "anaProNumVarBin"):
      return 7
    elif (v == "simNetworkPrimalHotstartLu"):
      return 70
    elif (v == "simPrimalIter"):
      return 84
    elif (v == "simDualHotstart"):
      return 59
    elif (v == "mioInitialSolution"):
      return 22
    elif (v == "intpntNumThreads"):
      return 18
    elif (v == "simDualHotstartLu"):
      return 60
    elif (v == "anaProNumVarUp"):
      return 14
    elif (v == "simNetworkDualIter"):
      return 67
    elif (v == "mioNumCliqueCuts"):
      return 27
    elif (v == "anaProNumVarEq"):
      return 9
    elif (v == "intpntFactorDimDense"):
      return 16
    elif (v == "concurrentFastestOptimizer"):
      return 15
    elif (v == "mioUserObjCut"):
      return 47
    elif (v == "simNetworkPrimalHotstart"):
      return 69
    elif (v == "simPrimalDualInfIter"):
      return 79
    elif (v == "anaProNumConRa"):
      return 4
    elif (v == "mioNumPlanLocCuts"):
      return 40
    elif (v == "mioTotalNumCuts"):
      return 46
    elif (v == "optNumcon"):
      return 48
    elif (v == "solItgProsta"):
      return 90
    elif (v == "simPrimalDegIter"):
      return 75
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1xmlwriteroutputtype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1642:10-1647:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_xmlwriteroutputtype_value(basestring)")
  def __string_1to_1xmlwriteroutputtype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "col"):
      return 1
    elif (v == "row"):
      return 0
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1optimizertype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1649:10-1663:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_optimizertype_value(basestring)")
  def __string_1to_1optimizertype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "intpnt"):
      return 1
    elif (v == "concurrent"):
      return 10
    elif (v == "mixedIntConic"):
      return 8
    elif (v == "mixedInt"):
      return 9
    elif (v == "dualSimplex"):
      return 4
    elif (v == "free"):
      return 0
    elif (v == "primalDualSimplex"):
      return 5
    elif (v == "conic"):
      return 2
    elif (v == "primalSimplex"):
      return 3
    elif (v == "networkPrimalSimplex"):
      return 7
    elif (v == "freeSimplex"):
      return 6
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1presolvemode_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1665:10-1671:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_presolvemode_value(basestring)")
  def __string_1to_1presolvemode_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "on"):
      return 1
    elif (v == "off"):
      return 0
    elif (v == "free"):
      return 2
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1internal_1dinf_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1673:10-1750:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_internal_dinf_value(basestring)")
  def __string_1to_1internal_1dinf_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "biPrimalFeas"):
      return 8
    elif (v == "presolveDupvarTime"):
      return 58
    elif (v == "intpntFactorBvTime"):
      return 18
    elif (v == "biPrimalObj"):
      return 9
    elif (v == "biDualDone"):
      return 2
    elif (v == "intpntFactorBvtbvTime"):
      return 20
    elif (v == "presolveSubDomvarTime"):
      return 61
    elif (v == "intpntFactorMlOrderSparseLFlops"):
      return 30
    elif (v == "presolveSetupTime"):
      return 60
    elif (v == "biFactorWork"):
      return 6
    elif (v == "intpntFactorHatSchurFlops"):
      return 24
    elif (v == "intpntGfeas"):
      return 41
    elif (v == "intpntFactorHatSchurPushTime"):
      return 28
    elif (v == "biPrimalDone"):
      return 7
    elif (v == "intpntFactorDenseLFlops"):
      return 21
    elif (v == "simPrimalObj"):
      return 73
    elif (v == "nonconvexPinfe"):
      return 52
    elif (v == "intpntFactorSparseLTime"):
      return 38
    elif (v == "intpntCompGap"):
      return 12
    elif (v == "nonconvexDobj"):
      return 51
    elif (v == "simNetworkDualObj"):
      return 69
    elif (v == "simNetworkPrimalObj"):
      return 71
    elif (v == "presolveSubRelaxTime"):
      return 62
    elif (v == "sensitivityDualTime"):
      return 64
    elif (v == "biCrashTime"):
      return 1
    elif (v == "intpntFactorHatSchurPushFlops"):
      return 27
    elif (v == "sensitivityPrimalTime"):
      return 65
    elif (v == "intpntFactorBarSchurFlops"):
      return 14
    elif (v == "presolveAcoltTime"):
      return 55
    elif (v == "intpntFactorSetupDetectDenseTime"):
      return 33
    elif (v == "biDualFeas"):
      return 3
    elif (v == "presolveDupconTime"):
      return 57
    elif (v == "intpntFactorHatSchurPullTime"):
      return 26
    elif (v == "concurrentWinningTime"):
      return 10
    elif (v == "intpntInitIterTime"):
      return 43
    elif (v == "intpntFactorSchurFlops"):
      return 31
    elif (v == "nonconvexDinfe"):
      return 50
    elif (v == "primalSimplexInftime"):
      return 63
    elif (v == "intpntInitSearchTime"):
      return 44
    elif (v == "intpntFactorSchurTime"):
      return 32
    elif (v == "intpntFactorBarSchurTime"):
      return 16
    elif (v == "intpntFactorBarSchurDeTabTime"):
      return 13
    elif (v == "intpntFactorBvFlops"):
      return 17
    elif (v == "intpntFactorBvtbvFlops"):
      return 19
    elif (v == "intpntGpOrderSavedFlops"):
      return 42
    elif (v == "intpntFactorTime"):
      return 39
    elif (v == "intpntMu"):
      return 45
    elif (v == "intpntFormSearchTime"):
      return 40
    elif (v == "simDualFeas"):
      return 66
    elif (v == "presolveCheckproTime"):
      return 56
    elif (v == "simPrimalFeas"):
      return 72
    elif (v == "biFactorTime"):
      return 5
    elif (v == "intpntFactorSparseLFlops"):
      return 37
    elif (v == "intpntSolveTime"):
      return 48
    elif (v == "intpntFactorHatSchurPullFlops"):
      return 25
    elif (v == "intpntFactorSetupMlOrderTime"):
      return 35
    elif (v == "biCrashLuTime"):
      return 0
    elif (v == "intpntUpdateTime"):
      return 49
    elif (v == "intpntSolveSparseLTime"):
      return 47
    elif (v == "intpntFactorDenseLTime"):
      return 22
    elif (v == "dualSimplexInftime"):
      return 11
    elif (v == "biDualObj"):
      return 4
    elif (v == "intpntFactorSetupGpOrderTime"):
      return 34
    elif (v == "simNetworkDualFeas"):
      return 68
    elif (v == "intpntFactorSetupTime"):
      return 36
    elif (v == "presolveFinalTime"):
      return 59
    elif (v == "simNetworkPrimalFeas"):
      return 70
    elif (v == "intpntFactorBarSchurSpTabTime"):
      return 15
    elif (v == "intpntSolveDenseLTime"):
      return 46
    elif (v == "simDualObj"):
      return 67
    elif (v == "intpntFactorHatSchurTime"):
      return 29
    elif (v == "nonconvexPobj"):
      return 53
    elif (v == "nonconvexTime"):
      return 54
    elif (v == "intpntFactorGpOrderSparseLFlops"):
      return 23
    else:
      return (- 1)
  @staticmethod
  def _matchargs_string_1to_1miocontsoltype_1value_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1752:10-1759:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("string_to_miocontsoltype_value(basestring)")
  def __string_1to_1miocontsoltype_1value_S(v):
    if   False:
      return (- 1)
    elif (v == "itg"):
      return 2
    elif (v == "none"):
      return 0
    elif (v == "root"):
      return 1
    elif (v == "itgRel"):
      return 3
    else:
      return (- 1)
  @staticmethod
  def _matchargs_setParameter_Omosek_fusion_Model_2SS(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if not isinstance(args[2],basestring): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(1762:9-3559:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setParameter(mosek.fusion.Model,basestring,basestring)")
  def _setParameter_Omosek_fusion_Model_2SS(M,name,value):
    if   False:
      pass
    elif (name == "simStabilityPriority"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 100):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_STABILITY_PRIORITY",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simStabilityPriority)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simStabilityPriority)")
    elif (name == "simPrimalPhaseoneMethod"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 10):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalPhaseoneMethod)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalPhaseoneMethod)")
    elif (name == "mioNodeOptimizer"):
      v = ( Parameters.__string_1to_1optimizertype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioNodeOptimizer)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_NODE_OPTIMIZER",v) )
    elif (name == "presolveLevel"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLevel)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLevel)")
    elif (name == "logNonconvex"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_NONCONVEX",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logNonconvex)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logNonconvex)")
    elif (name == "mioMtUserCb"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMtUserCb)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_MT_USER_CB",v) )
    elif (name == "presolveUse"):
      v = ( Parameters.__string_1to_1presolvemode_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveUse)")
      ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_USE",v) )
    elif (name == "mioBranchPrioritiesUse"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioBranchPrioritiesUse)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_BRANCH_PRIORITIES_USE",v) )
    elif (name == "mioCutLevelTree"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_CUT_LEVEL_TREE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutLevelTree)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutLevelTree)")
    elif (name == "logConcurrent"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_CONCURRENT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logConcurrent)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logConcurrent)")
    elif (name == "intpntOrderMethod"):
      v = ( Parameters.__string_1to_1orderingtype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntOrderMethod)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_METHOD",v) )
    elif (name == "logInfeasAna"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logInfeasAna)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logInfeasAna)")
    elif (name == "simPrimalSelection"):
      v = ( Parameters.__string_1to_1simseltype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalSelection)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_SELECTION",v) )
    elif (name == "mioCutCmir"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutCmir)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CMIR",v) )
    elif (name == "simDualRestrictSelection"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 100):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simDualRestrictSelection)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simDualRestrictSelection)")
    elif (name == "logMioFreq"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logMioFreq)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logMioFreq)")
    elif (name == "mioRootOptimizer"):
      v = ( Parameters.__string_1to_1optimizertype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioRootOptimizer)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_OPTIMIZER",v) )
    elif (name == "presolveElimFill"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIM_FILL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolveElimFill)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveElimFill)")
    elif (name == "mioLocalBranchNumber"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_LOCAL_BRANCH_NUMBER",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioLocalBranchNumber)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioLocalBranchNumber)")
    elif (name == "warningLevel"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_WARNING_LEVEL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (warningLevel)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (warningLevel)")
    elif (name == "logBiFreq"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logBiFreq)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logBiFreq)")
    elif (name == "concurrentPriorityDualSimplex"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_DUAL_SIMPLEX",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityDualSimplex)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityDualSimplex)")
    elif (name == "logPresolve"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logPresolve)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logPresolve)")
    elif (name == "intpntOffColTrh"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntOffColTrh)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntOffColTrh)")
    elif (name == "mioMode"):
      v = ( Parameters.__string_1to_1miomode_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMode)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_MODE",v) )
    elif (name == "logSim"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logSim)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logSim)")
    elif (name == "mtSpincount"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 1000000000):
          ( M._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mtSpincount)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mtSpincount)")
    elif (name == "mioRinsMaxNodes"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   ((- 1) <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioRinsMaxNodes)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioRinsMaxNodes)")
    elif (name == "simScalingMethod"):
      v = ( Parameters.__string_1to_1scalingmethod_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simScalingMethod)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_SCALING_METHOD",v) )
    elif (name == "logSimFreq"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logSimFreq)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logSimFreq)")
    elif (name == "presolveMaxNumReductions"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_MAX_NUM_REDUCTIONS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolveMaxNumReductions)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveMaxNumReductions)")
    elif (name == "logFactor"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_FACTOR",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logFactor)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logFactor)")
    elif (name == "autoUpdateSolInfo"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (autoUpdateSolInfo)")
      ( M._task_1put_1param_SI("MSK_IPAR_AUTO_UPDATE_SOL_INFO",v) )
    elif (name == "timingLevel"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_TIMING_LEVEL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (timingLevel)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (timingLevel)")
    elif (name == "logOrder"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logOrder)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logOrder)")
    elif (name == "mioCutLevelRoot"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_CUT_LEVEL_ROOT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutLevelRoot)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutLevelRoot)")
    elif (name == "biIgnoreNumError"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (biIgnoreNumError)")
      ( M._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_NUM_ERROR",v) )
    elif (name == "mioNodeSelection"):
      v = ( Parameters.__string_1to_1mionodeseltype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioNodeSelection)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_NODE_SELECTION",v) )
    elif (name == "intpntMaxNumRefinementSteps"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntMaxNumRefinementSteps)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntMaxNumRefinementSteps)")
    elif (name == "logSimMinor"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logSimMinor)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logSimMinor)")
    elif (name == "simMaxIterations"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simMaxIterations)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simMaxIterations)")
    elif (name == "mioProbingLevel"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioProbingLevel)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioProbingLevel)")
    elif (name == "intpntMaxIterations"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntMaxIterations)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntMaxIterations)")
    elif (name == "cacheLicense"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (cacheLicense)")
      ( M._task_1put_1param_SI("MSK_IPAR_CACHE_LICENSE",v) )
    elif (name == "logBi"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_BI",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logBi)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logBi)")
    elif (name == "intpntMaxNumCor"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   ((- 1) <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntMaxNumCor)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntMaxNumCor)")
    elif (name == "licenseDebug"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (licenseDebug)")
      ( M._task_1put_1param_SI("MSK_IPAR_LICENSE_DEBUG",v) )
    elif (name == "licTrhExpiryWrn"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LIC_TRH_EXPIRY_WRN",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (licTrhExpiryWrn)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (licTrhExpiryWrn)")
    elif (name == "presolveEliminatorMaxNumTries"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolveEliminatorMaxNumTries)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    elif (name == "concurrentNumOptimizers"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_NUM_OPTIMIZERS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentNumOptimizers)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentNumOptimizers)")
    elif (name == "simRefactorFreq"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simRefactorFreq)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simRefactorFreq)")
    elif (name == "simDualSelection"):
      v = ( Parameters.__string_1to_1simseltype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simDualSelection)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_SELECTION",v) )
    elif (name == "simSolveForm"):
      v = ( Parameters.__string_1to_1solveform_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simSolveForm)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_SOLVE_FORM",v) )
    elif (name == "mioOptimizerMode"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 1):
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_OPTIMIZER_MODE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioOptimizerMode)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioOptimizerMode)")
    elif (name == "logIntpnt"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logIntpnt)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logIntpnt)")
    elif (name == "logMio"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_MIO",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logMio)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logMio)")
    elif (name == "simHotstart"):
      v = ( Parameters.__string_1to_1simhotstart_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simHotstart)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART",v) )
    elif (name == "logParam"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_PARAM",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logParam)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logParam)")
    elif (name == "simExploitDupvec"):
      v = ( Parameters.__string_1to_1simdupvec_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simExploitDupvec)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_EXPLOIT_DUPVEC",v) )
    elif (name == "mioBranchDir"):
      v = ( Parameters.__string_1to_1branchdir_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioBranchDir)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_BRANCH_DIR",v) )
    elif (name == "intpntFactorDebugLvl"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_FACTOR_DEBUG_LVL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntFactorDebugLvl)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntFactorDebugLvl)")
    elif (name == "licensePauseTime"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 1000000):
          ( M._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (licensePauseTime)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (licensePauseTime)")
    elif (name == "mioPresolveAggregate"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioPresolveAggregate)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_PRESOLVE_AGGREGATE",v) )
    elif (name == "biMaxIterations"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (biMaxIterations)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (biMaxIterations)")
    elif (name == "simHotstartLu"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simHotstartLu)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART_LU",v) )
    elif (name == "presolveLindepRelWorkTrh"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLindepRelWorkTrh)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLindepRelWorkTrh)")
    elif (name == "logFeasRepair"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_FEAS_REPAIR",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logFeasRepair)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logFeasRepair)")
    elif (name == "presolveLindepUse"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLindepUse)")
      ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_USE",v) )
    elif (name == "intpntHotstart"):
      v = ( Parameters.__string_1to_1intpnthotstart_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntHotstart)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_HOTSTART",v) )
    elif (name == "mioContSol"):
      v = ( Parameters.__string_1to_1miocontsoltype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioContSol)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_CONT_SOL",v) )
    elif (name == "intpntStartingPoint"):
      v = ( Parameters.__string_1to_1startpointtype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntStartingPoint)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_STARTING_POINT",v) )
    elif (name == "simMaxNumSetbacks"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simMaxNumSetbacks)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simMaxNumSetbacks)")
    elif (name == "concurrentPriorityPrimalSimplex"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_PRIMAL_SIMPLEX",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityPrimalSimplex)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityPrimalSimplex)")
    elif (name == "logSimNetworkFreq"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM_NETWORK_FREQ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logSimNetworkFreq)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logSimNetworkFreq)")
    elif (name == "intpntDiffStep"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntDiffStep)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_DIFF_STEP",v) )
    elif (name == "simScaling"):
      v = ( Parameters.__string_1to_1scalingtype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simScaling)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_SCALING",v) )
    elif (name == "biIgnoreMaxIter"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (biIgnoreMaxIter)")
      ( M._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_MAX_ITER",v) )
    elif (name == "presolveLindepAbsWorkTrh"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLindepAbsWorkTrh)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    elif (name == "intpntSolveForm"):
      v = ( Parameters.__string_1to_1solveform_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntSolveForm)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_SOLVE_FORM",v) )
    elif (name == "simBasisFactorUse"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simBasisFactorUse)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_BASIS_FACTOR_USE",v) )
    elif (name == "intpntRegularizationUse"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntRegularizationUse)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_REGULARIZATION_USE",v) )
    elif (name == "biCleanOptimizer"):
      v = ( Parameters.__string_1to_1optimizertype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (biCleanOptimizer)")
      ( M._task_1put_1param_SI("MSK_IPAR_BI_CLEAN_OPTIMIZER",v) )
    elif (name == "mioPresolveProbing"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioPresolveProbing)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_PRESOLVE_PROBING",v) )
    elif (name == "infeasPreferPrimal"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (infeasPreferPrimal)")
      ( M._task_1put_1param_SI("MSK_IPAR_INFEAS_PREFER_PRIMAL",v) )
    elif (name == "logStorage"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_STORAGE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logStorage)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logStorage)")
    elif (name == "mioPresolveUse"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioPresolveUse)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_PRESOLVE_USE",v) )
    elif (name == "intpntBasis"):
      v = ( Parameters.__string_1to_1basindtype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntBasis)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_BASIS",v) )
    elif (name == "logCutSecondOpt"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logCutSecondOpt)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logCutSecondOpt)")
    elif (name == "mioMaxNumSolutions"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxNumSolutions)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxNumSolutions)")
    elif (name == "licenseWait"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (licenseWait)")
      ( M._task_1put_1param_SI("MSK_IPAR_LICENSE_WAIT",v) )
    elif (name == "concurrentPriorityFreeSimplex"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_FREE_SIMPLEX",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityFreeSimplex)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityFreeSimplex)")
    elif (name == "logFile"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_FILE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logFile)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logFile)")
    elif (name == "concurrentPriorityIntpnt"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_INTPNT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityIntpnt)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityIntpnt)")
    elif (name == "simNonSingular"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simNonSingular)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_NON_SINGULAR",v) )
    elif (name == "simDegen"):
      v = ( Parameters.__string_1to_1simdegen_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simDegen)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_DEGEN",v) )
    elif (name == "presolveEliminatorUse"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveEliminatorUse)")
      ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_USE",v) )
    elif (name == "allocAddQnz"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_ALLOC_ADD_QNZ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (allocAddQnz)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (allocAddQnz)")
    elif (name == "mioHotstart"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioHotstart)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_HOTSTART",v) )
    elif (name == "logOptimizer"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_OPTIMIZER",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logOptimizer)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logOptimizer)")
    elif (name == "mioMaxNumBranches"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxNumBranches)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxNumBranches)")
    elif (name == "simPrimalCrash"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalCrash)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalCrash)")
    elif (name == "mioConstructSol"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioConstructSol)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_CONSTRUCT_SOL",v) )
    elif (name == "autoSortABeforeOpt"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (autoSortABeforeOpt)")
      ( M._task_1put_1param_SI("MSK_IPAR_AUTO_SORT_A_BEFORE_OPT",v) )
    elif (name == "mioStrongBranch"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_STRONG_BRANCH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioStrongBranch)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioStrongBranch)")
    elif (name == "simDualPhaseoneMethod"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 10):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simDualPhaseoneMethod)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simDualPhaseoneMethod)")
    elif (name == "simInteger"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 10):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_INTEGER",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simInteger)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simInteger)")
    elif (name == "mioUseMultithreadedOptimizer"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioUseMultithreadedOptimizer)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_USE_MULTITHREADED_OPTIMIZER",v) )
    elif (name == "simPrimalRestrictSelection"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 100):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalRestrictSelection)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalRestrictSelection)")
    elif (name == "optimizer"):
      v = ( Parameters.__string_1to_1optimizertype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (optimizer)")
      ( M._task_1put_1param_SI("MSK_IPAR_OPTIMIZER",v) )
    elif (name == "maxNumWarnings"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MAX_NUM_WARNINGS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (maxNumWarnings)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (maxNumWarnings)")
    elif (name == "licenseSuppressExpireWrns"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (licenseSuppressExpireWrns)")
      ( M._task_1put_1param_SI("MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS",v) )
    elif (name == "mioCutCg"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutCg)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CG",v) )
    elif (name == "logExpand"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logExpand)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logExpand)")
    elif (name == "mioFeaspumpLevel"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (v <= 3):
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_FEASPUMP_LEVEL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioFeaspumpLevel)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioFeaspumpLevel)")
    elif (name == "logResponse"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logResponse)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logResponse)")
    elif (name == "log"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (log)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log)")
    elif (name == "simSwitchOptimizer"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simSwitchOptimizer)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_SWITCH_OPTIMIZER",v) )
    elif (name == "numThreads"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (numThreads)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (numThreads)")
    elif (name == "logCheckConvexity"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_CHECK_CONVEXITY",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logCheckConvexity)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logCheckConvexity)")
    elif (name == "simDualCrash"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simDualCrash)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simDualCrash)")
    elif (name == "logHead"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_LOG_HEAD",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (logHead)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logHead)")
    elif (name == "simReformulation"):
      v = ( Parameters.__string_1to_1simreform_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simReformulation)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_REFORMULATION",v) )
    elif (name == "simSaveLu"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (simSaveLu)")
      ( M._task_1put_1param_SI("MSK_IPAR_SIM_SAVE_LU",v) )
    elif (name == "intpntFactorMethod"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   (0 <= v):
          ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_FACTOR_METHOD",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntFactorMethod)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntFactorMethod)")
    elif (name == "mioMaxNumRelaxs"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxNumRelaxs)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxNumRelaxs)")
    elif (name == "solFilterKeepBasic"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (solFilterKeepBasic)")
      ( M._task_1put_1param_SI("MSK_IPAR_SOL_FILTER_KEEP_BASIC",v) )
    elif (name == "mioHeuristicLevel"):
      try:
        v = ( Utils.Tools._toInt_S (value) )

        if   True:
          ( M._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioHeuristicLevel)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioHeuristicLevel)")
    elif (name == "mioKeepBasis"):
      v = ( Parameters.__string_1to_1onoffkey_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioKeepBasis)")
      ( M._task_1put_1param_SI("MSK_IPAR_MIO_KEEP_BASIS",v) )
    elif (name == "intpntScaling"):
      v = ( Parameters.__string_1to_1scalingtype_1value_S (value) )

      if   (v < 0):
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntScaling)")
      ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_SCALING",v) )
    elif (name == "lowerObjCutFiniteTrh"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (lowerObjCutFiniteTrh)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lowerObjCutFiniteTrh)")
    elif (name == "mioMaxTime"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_MAX_TIME",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxTime)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxTime)")
    elif (name == "basisTolS"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-09 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_BASIS_TOL_S",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (basisTolS)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basisTolS)")
    elif (name == "presolveTolS"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_S",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolS)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolS)")
    elif (name == "upperObjCut"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_UPPER_OBJ_CUT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (upperObjCut)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (upperObjCut)")
    elif (name == "intpntCoTolDfeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_DFEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolDfeas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolDfeas)")
    elif (name == "mioTolAbsGap"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_ABS_GAP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolAbsGap)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolAbsGap)")
    elif (name == "upperObjCutFiniteTrh"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (upperObjCutFiniteTrh)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (upperObjCutFiniteTrh)")
    elif (name == "mioTolAbsRelaxInt"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-09 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolAbsRelaxInt)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolAbsRelaxInt)")
    elif (name == "mioTolMaxCutFracRhs"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_MAX_CUT_FRAC_RHS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolMaxCutFracRhs)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolMaxCutFracRhs)")
    elif (name == "simplexAbsTolPiv"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-12 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simplexAbsTolPiv)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simplexAbsTolPiv)")
    elif (name == "mioTolRelDualBoundImprovement"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolRelDualBoundImprovement)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolRelDualBoundImprovement)")
    elif (name == "mioHeuristicTime"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_HEURISTIC_TIME",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioHeuristicTime)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioHeuristicTime)")
    elif (name == "presolveTolX"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_X",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolX)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolX)")
    elif (name == "mioNearTolRelGap"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_NEAR_TOL_REL_GAP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioNearTolRelGap)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioNearTolRelGap)")
    elif (name == "mioTolMinCutFracRhs"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_MIN_CUT_FRAC_RHS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolMinCutFracRhs)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolMinCutFracRhs)")
    elif (name == "presolveTolRelLindep"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolRelLindep)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolRelLindep)")
    elif (name == "intpntTolDsafe"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-04 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_DSAFE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolDsafe)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolDsafe)")
    elif (name == "mioTolFeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_FEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolFeas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolFeas)")
    elif (name == "intpntTolInfeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_INFEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolInfeas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolInfeas)")
    elif (name == "optimizerMaxTime"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_OPTIMIZER_MAX_TIME",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (optimizerMaxTime)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (optimizerMaxTime)")
    elif (name == "anaSolInfeasTol"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_ANA_SOL_INFEAS_TOL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (anaSolInfeasTol)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (anaSolInfeasTol)")
    elif (name == "mioRelAddCutLimited"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 2.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_REL_ADD_CUT_LIMITED",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioRelAddCutLimited)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioRelAddCutLimited)")
    elif (name == "intpntTolMuRed"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_MU_RED",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolMuRed)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolMuRed)")
    elif (name == "intpntCoTolMuRed"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_MU_RED",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolMuRed)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolMuRed)")
    elif (name == "intpntCoTolRelGap"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolRelGap)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolRelGap)")
    elif (name == "lowerObjCut"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_LOWER_OBJ_CUT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (lowerObjCut)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lowerObjCut)")
    elif (name == "mioDisableTermTime"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   True:
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_DISABLE_TERM_TIME",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioDisableTermTime)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioDisableTermTime)")
    elif (name == "intpntTolRelStep"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 9.999990e-01):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_REL_STEP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolRelStep)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolRelStep)")
    elif (name == "mioTolX"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_X",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolX)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolX)")
    elif (name == "simLuTolRelPiv"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 9.999990e-01):
          ( M._task_1put_1param_SF("MSK_DPAR_SIM_LU_TOL_REL_PIV",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (simLuTolRelPiv)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simLuTolRelPiv)")
    elif (name == "intpntTolStepSize"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_STEP_SIZE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolStepSize)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolStepSize)")
    elif (name == "intpntTolPfeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PFEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolPfeas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolPfeas)")
    elif (name == "basisRelTolS"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_BASIS_REL_TOL_S",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (basisRelTolS)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basisRelTolS)")
    elif (name == "presolveTolAbsLindep"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolAbsLindep)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolAbsLindep)")
    elif (name == "intpntCoTolInfeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_INFEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolInfeas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolInfeas)")
    elif (name == "mioRelGapConst"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-15 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_REL_GAP_CONST",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioRelGapConst)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioRelGapConst)")
    elif (name == "presolveTolAij"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-15 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_AIJ",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolAij)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolAij)")
    elif (name == "mioMaxTimeAprxOpt"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_MAX_TIME_APRX_OPT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxTimeAprxOpt)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxTimeAprxOpt)")
    elif (name == "intpntTolPath"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 9.999000e-01):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PATH",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolPath)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolPath)")
    elif (name == "basisTolX"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-09 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_BASIS_TOL_X",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (basisTolX)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basisTolX)")
    elif (name == "intpntTolRelGap"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-14 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_REL_GAP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolRelGap)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolRelGap)")
    elif (name == "intpntTolPsafe"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e-04 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PSAFE",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolPsafe)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolPsafe)")
    elif (name == "intpntCoTolNearRel"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (1.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolNearRel)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolNearRel)")
    elif (name == "mioTolRelGap"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_GAP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolRelGap)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolRelGap)")
    elif (name == "intpntTolDfeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_DFEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolDfeas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolDfeas)")
    elif (name == "mioNearTolAbsGap"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_NEAR_TOL_ABS_GAP",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioNearTolAbsGap)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioNearTolAbsGap)")
    elif (name == "mioTolRelRelaxInt"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (0.000000e+00 <= v):
          ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_RELAX_INT",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolRelRelaxInt)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolRelRelaxInt)")
    elif (name == "intpntCoTolPfeas"):
      try:
        v = ( Utils.Tools._toDouble_S (value) )

        if   (v <= 1.000000e+00):
          ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_PFEAS",v) )
        else:
          raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolPfeas)")
      except mosek.fusion.ValueConversionError, e:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolPfeas)")
    else:
      raise mosek.fusion.ParameterError("Unknown parameter")
  @staticmethod
  def _matchargs_setParameter_Omosek_fusion_Model_2SI(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if not isinstance(args[2],int): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(3562:9-4668:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setParameter(mosek.fusion.Model,basestring,int)")
  def _setParameter_Omosek_fusion_Model_2SI(M,name,value):
    if   False:
      pass
    elif (name == "simStabilityPriority"):
      v = value

      if   (v <= 100):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_STABILITY_PRIORITY",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simStabilityPriority)")
    elif (name == "simPrimalPhaseoneMethod"):
      v = value

      if   (v <= 10):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalPhaseoneMethod)")
    elif (name == "mioNodeOptimizer"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioNodeOptimizer)")
    elif (name == "presolveLevel"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLevel)")
    elif (name == "logNonconvex"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_NONCONVEX",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logNonconvex)")
    elif (name == "mioMtUserCb"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioMtUserCb)")
    elif (name == "presolveUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (presolveUse)")
    elif (name == "mioBranchPrioritiesUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioBranchPrioritiesUse)")
    elif (name == "mioCutLevelTree"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_CUT_LEVEL_TREE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutLevelTree)")
    elif (name == "logConcurrent"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_CONCURRENT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logConcurrent)")
    elif (name == "intpntOrderMethod"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntOrderMethod)")
    elif (name == "logInfeasAna"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logInfeasAna)")
    elif (name == "simPrimalSelection"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalSelection)")
    elif (name == "mioCutCmir"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutCmir)")
    elif (name == "simDualRestrictSelection"):
      v = value

      if   (v <= 100):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simDualRestrictSelection)")
    elif (name == "logMioFreq"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logMioFreq)")
    elif (name == "mioRootOptimizer"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioRootOptimizer)")
    elif (name == "presolveElimFill"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIM_FILL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveElimFill)")
    elif (name == "mioLocalBranchNumber"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_LOCAL_BRANCH_NUMBER",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioLocalBranchNumber)")
    elif (name == "warningLevel"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_WARNING_LEVEL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (warningLevel)")
    elif (name == "logBiFreq"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logBiFreq)")
    elif (name == "concurrentPriorityDualSimplex"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_DUAL_SIMPLEX",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityDualSimplex)")
    elif (name == "logPresolve"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logPresolve)")
    elif (name == "intpntOffColTrh"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntOffColTrh)")
    elif (name == "mioMode"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioMode)")
    elif (name == "logSim"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logSim)")
    elif (name == "mtSpincount"):
      v = value

      if   (v <= 1000000000):
        ( M._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mtSpincount)")
    elif (name == "mioRinsMaxNodes"):
      v = value

      if   ((- 1) <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioRinsMaxNodes)")
    elif (name == "simScalingMethod"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simScalingMethod)")
    elif (name == "logSimFreq"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logSimFreq)")
    elif (name == "presolveMaxNumReductions"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_MAX_NUM_REDUCTIONS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveMaxNumReductions)")
    elif (name == "logFactor"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_FACTOR",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logFactor)")
    elif (name == "autoUpdateSolInfo"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (autoUpdateSolInfo)")
    elif (name == "timingLevel"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_TIMING_LEVEL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (timingLevel)")
    elif (name == "logOrder"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logOrder)")
    elif (name == "mioCutLevelRoot"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_CUT_LEVEL_ROOT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutLevelRoot)")
    elif (name == "biIgnoreNumError"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (biIgnoreNumError)")
    elif (name == "mioNodeSelection"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioNodeSelection)")
    elif (name == "intpntMaxNumRefinementSteps"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntMaxNumRefinementSteps)")
    elif (name == "logSimMinor"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logSimMinor)")
    elif (name == "simMaxIterations"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simMaxIterations)")
    elif (name == "mioProbingLevel"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioProbingLevel)")
    elif (name == "intpntMaxIterations"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntMaxIterations)")
    elif (name == "cacheLicense"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (cacheLicense)")
    elif (name == "logBi"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_BI",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logBi)")
    elif (name == "intpntMaxNumCor"):
      v = value

      if   ((- 1) <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntMaxNumCor)")
    elif (name == "licenseDebug"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (licenseDebug)")
    elif (name == "licTrhExpiryWrn"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LIC_TRH_EXPIRY_WRN",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (licTrhExpiryWrn)")
    elif (name == "presolveEliminatorMaxNumTries"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    elif (name == "concurrentNumOptimizers"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_NUM_OPTIMIZERS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentNumOptimizers)")
    elif (name == "simRefactorFreq"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simRefactorFreq)")
    elif (name == "simDualSelection"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simDualSelection)")
    elif (name == "simSolveForm"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simSolveForm)")
    elif (name == "mioOptimizerMode"):
      v = value

      if   (v <= 1):
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_OPTIMIZER_MODE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioOptimizerMode)")
    elif (name == "logIntpnt"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logIntpnt)")
    elif (name == "logMio"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_MIO",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logMio)")
    elif (name == "simHotstart"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simHotstart)")
    elif (name == "logParam"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_PARAM",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logParam)")
    elif (name == "simExploitDupvec"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simExploitDupvec)")
    elif (name == "mioBranchDir"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioBranchDir)")
    elif (name == "intpntFactorDebugLvl"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_FACTOR_DEBUG_LVL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntFactorDebugLvl)")
    elif (name == "licensePauseTime"):
      v = value

      if   (v <= 1000000):
        ( M._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (licensePauseTime)")
    elif (name == "mioPresolveAggregate"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioPresolveAggregate)")
    elif (name == "biMaxIterations"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (biMaxIterations)")
    elif (name == "simHotstartLu"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simHotstartLu)")
    elif (name == "presolveLindepRelWorkTrh"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLindepRelWorkTrh)")
    elif (name == "logFeasRepair"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_FEAS_REPAIR",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logFeasRepair)")
    elif (name == "presolveLindepUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLindepUse)")
    elif (name == "intpntHotstart"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntHotstart)")
    elif (name == "mioContSol"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioContSol)")
    elif (name == "intpntStartingPoint"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntStartingPoint)")
    elif (name == "simMaxNumSetbacks"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simMaxNumSetbacks)")
    elif (name == "concurrentPriorityPrimalSimplex"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_PRIMAL_SIMPLEX",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityPrimalSimplex)")
    elif (name == "logSimNetworkFreq"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_SIM_NETWORK_FREQ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logSimNetworkFreq)")
    elif (name == "intpntDiffStep"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntDiffStep)")
    elif (name == "simScaling"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simScaling)")
    elif (name == "biIgnoreMaxIter"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (biIgnoreMaxIter)")
    elif (name == "presolveLindepAbsWorkTrh"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    elif (name == "intpntSolveForm"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntSolveForm)")
    elif (name == "simBasisFactorUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simBasisFactorUse)")
    elif (name == "intpntRegularizationUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntRegularizationUse)")
    elif (name == "biCleanOptimizer"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (biCleanOptimizer)")
    elif (name == "mioPresolveProbing"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioPresolveProbing)")
    elif (name == "infeasPreferPrimal"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (infeasPreferPrimal)")
    elif (name == "logStorage"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_STORAGE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logStorage)")
    elif (name == "mioPresolveUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioPresolveUse)")
    elif (name == "intpntBasis"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntBasis)")
    elif (name == "logCutSecondOpt"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logCutSecondOpt)")
    elif (name == "mioMaxNumSolutions"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxNumSolutions)")
    elif (name == "licenseWait"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (licenseWait)")
    elif (name == "concurrentPriorityFreeSimplex"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_FREE_SIMPLEX",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityFreeSimplex)")
    elif (name == "logFile"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_FILE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logFile)")
    elif (name == "concurrentPriorityIntpnt"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_CONCURRENT_PRIORITY_INTPNT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityIntpnt)")
    elif (name == "simNonSingular"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simNonSingular)")
    elif (name == "simDegen"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simDegen)")
    elif (name == "presolveEliminatorUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (presolveEliminatorUse)")
    elif (name == "allocAddQnz"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_ALLOC_ADD_QNZ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (allocAddQnz)")
    elif (name == "mioHotstart"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioHotstart)")
    elif (name == "logOptimizer"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_OPTIMIZER",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logOptimizer)")
    elif (name == "mioMaxNumBranches"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxNumBranches)")
    elif (name == "simPrimalCrash"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalCrash)")
    elif (name == "mioConstructSol"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioConstructSol)")
    elif (name == "autoSortABeforeOpt"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (autoSortABeforeOpt)")
    elif (name == "mioStrongBranch"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_STRONG_BRANCH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioStrongBranch)")
    elif (name == "simDualPhaseoneMethod"):
      v = value

      if   (v <= 10):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simDualPhaseoneMethod)")
    elif (name == "simInteger"):
      v = value

      if   (v <= 10):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_INTEGER",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simInteger)")
    elif (name == "mioUseMultithreadedOptimizer"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioUseMultithreadedOptimizer)")
    elif (name == "simPrimalRestrictSelection"):
      v = value

      if   (v <= 100):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalRestrictSelection)")
    elif (name == "optimizer"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (optimizer)")
    elif (name == "maxNumWarnings"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MAX_NUM_WARNINGS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (maxNumWarnings)")
    elif (name == "licenseSuppressExpireWrns"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (licenseSuppressExpireWrns)")
    elif (name == "mioCutCg"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutCg)")
    elif (name == "logExpand"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logExpand)")
    elif (name == "mioFeaspumpLevel"):
      v = value

      if   (v <= 3):
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_FEASPUMP_LEVEL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioFeaspumpLevel)")
    elif (name == "logResponse"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logResponse)")
    elif (name == "log"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (log)")
    elif (name == "simSwitchOptimizer"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simSwitchOptimizer)")
    elif (name == "numThreads"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (numThreads)")
    elif (name == "logCheckConvexity"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_CHECK_CONVEXITY",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logCheckConvexity)")
    elif (name == "simDualCrash"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simDualCrash)")
    elif (name == "logHead"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_LOG_HEAD",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (logHead)")
    elif (name == "simReformulation"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simReformulation)")
    elif (name == "simSaveLu"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simSaveLu)")
    elif (name == "intpntFactorMethod"):
      v = value

      if   (0 <= v):
        ( M._task_1put_1param_SI("MSK_IPAR_INTPNT_FACTOR_METHOD",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntFactorMethod)")
    elif (name == "mioMaxNumRelaxs"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxNumRelaxs)")
    elif (name == "solFilterKeepBasic"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (solFilterKeepBasic)")
    elif (name == "mioHeuristicLevel"):
      v = value

      if   True:
        ( M._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioHeuristicLevel)")
    elif (name == "mioKeepBasis"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioKeepBasis)")
    elif (name == "intpntScaling"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntScaling)")
    elif (name == "lowerObjCutFiniteTrh"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lowerObjCutFiniteTrh)")
    elif (name == "mioMaxTime"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_MAX_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxTime)")
    elif (name == "basisTolS"):
      v = float(value)

      if   (1.000000e-09 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_BASIS_TOL_S",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basisTolS)")
    elif (name == "presolveTolS"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_S",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolS)")
    elif (name == "upperObjCut"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_UPPER_OBJ_CUT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (upperObjCut)")
    elif (name == "intpntCoTolDfeas"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_DFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolDfeas)")
    elif (name == "mioTolAbsGap"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_ABS_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolAbsGap)")
    elif (name == "upperObjCutFiniteTrh"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (upperObjCutFiniteTrh)")
    elif (name == "mioTolAbsRelaxInt"):
      v = float(value)

      if   (1.000000e-09 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolAbsRelaxInt)")
    elif (name == "mioTolMaxCutFracRhs"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_MAX_CUT_FRAC_RHS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolMaxCutFracRhs)")
    elif (name == "simplexAbsTolPiv"):
      v = float(value)

      if   (1.000000e-12 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simplexAbsTolPiv)")
    elif (name == "mioTolRelDualBoundImprovement"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolRelDualBoundImprovement)")
    elif (name == "mioHeuristicTime"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_HEURISTIC_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioHeuristicTime)")
    elif (name == "presolveTolX"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_X",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolX)")
    elif (name == "mioNearTolRelGap"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_NEAR_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioNearTolRelGap)")
    elif (name == "mioTolMinCutFracRhs"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_MIN_CUT_FRAC_RHS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolMinCutFracRhs)")
    elif (name == "presolveTolRelLindep"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolRelLindep)")
    elif (name == "intpntTolDsafe"):
      v = float(value)

      if   (1.000000e-04 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_DSAFE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolDsafe)")
    elif (name == "mioTolFeas"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_FEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolFeas)")
    elif (name == "intpntTolInfeas"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_INFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolInfeas)")
    elif (name == "optimizerMaxTime"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_OPTIMIZER_MAX_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (optimizerMaxTime)")
    elif (name == "anaSolInfeasTol"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_ANA_SOL_INFEAS_TOL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (anaSolInfeasTol)")
    elif (name == "mioRelAddCutLimited"):
      v = float(value)

      if   (v <= 2.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_REL_ADD_CUT_LIMITED",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioRelAddCutLimited)")
    elif (name == "intpntTolMuRed"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_MU_RED",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolMuRed)")
    elif (name == "intpntCoTolMuRed"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_MU_RED",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolMuRed)")
    elif (name == "intpntCoTolRelGap"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolRelGap)")
    elif (name == "lowerObjCut"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_LOWER_OBJ_CUT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lowerObjCut)")
    elif (name == "mioDisableTermTime"):
      v = float(value)

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_DISABLE_TERM_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioDisableTermTime)")
    elif (name == "intpntTolRelStep"):
      v = float(value)

      if   (v <= 9.999990e-01):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_REL_STEP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolRelStep)")
    elif (name == "mioTolX"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_X",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolX)")
    elif (name == "simLuTolRelPiv"):
      v = float(value)

      if   (v <= 9.999990e-01):
        ( M._task_1put_1param_SF("MSK_DPAR_SIM_LU_TOL_REL_PIV",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simLuTolRelPiv)")
    elif (name == "intpntTolStepSize"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_STEP_SIZE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolStepSize)")
    elif (name == "intpntTolPfeas"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolPfeas)")
    elif (name == "basisRelTolS"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_BASIS_REL_TOL_S",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basisRelTolS)")
    elif (name == "presolveTolAbsLindep"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolAbsLindep)")
    elif (name == "intpntCoTolInfeas"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_INFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolInfeas)")
    elif (name == "mioRelGapConst"):
      v = float(value)

      if   (1.000000e-15 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_REL_GAP_CONST",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioRelGapConst)")
    elif (name == "presolveTolAij"):
      v = float(value)

      if   (1.000000e-15 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_AIJ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolAij)")
    elif (name == "mioMaxTimeAprxOpt"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_MAX_TIME_APRX_OPT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxTimeAprxOpt)")
    elif (name == "intpntTolPath"):
      v = float(value)

      if   (v <= 9.999000e-01):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PATH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolPath)")
    elif (name == "basisTolX"):
      v = float(value)

      if   (1.000000e-09 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_BASIS_TOL_X",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basisTolX)")
    elif (name == "intpntTolRelGap"):
      v = float(value)

      if   (1.000000e-14 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolRelGap)")
    elif (name == "intpntTolPsafe"):
      v = float(value)

      if   (1.000000e-04 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PSAFE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolPsafe)")
    elif (name == "intpntCoTolNearRel"):
      v = float(value)

      if   (1.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolNearRel)")
    elif (name == "mioTolRelGap"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolRelGap)")
    elif (name == "intpntTolDfeas"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_DFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolDfeas)")
    elif (name == "mioNearTolAbsGap"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_NEAR_TOL_ABS_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioNearTolAbsGap)")
    elif (name == "mioTolRelRelaxInt"):
      v = float(value)

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_RELAX_INT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolRelRelaxInt)")
    elif (name == "intpntCoTolPfeas"):
      v = float(value)

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_PFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolPfeas)")
    else:
      raise mosek.fusion.ParameterError("Unknown parameter")
  @staticmethod
  def _matchargs_setParameter_Omosek_fusion_Model_2SF(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Model): return False
    if not isinstance(args[1],basestring): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: bld/bradford/final/default/intelc-13.1.3/monty-0.0.0/fusion/src/Parameters.mbi(4671:9-5327:1)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setParameter(mosek.fusion.Model,basestring,float)")
  def _setParameter_Omosek_fusion_Model_2SF(M,name,value):
    if   False:
      pass
    elif (name == "simStabilityPriority"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simStabilityPriority)")
    elif (name == "simPrimalPhaseoneMethod"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalPhaseoneMethod)")
    elif (name == "mioNodeOptimizer"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioNodeOptimizer)")
    elif (name == "presolveLevel"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLevel)")
    elif (name == "logNonconvex"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logNonconvex)")
    elif (name == "mioMtUserCb"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioMtUserCb)")
    elif (name == "presolveUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (presolveUse)")
    elif (name == "mioBranchPrioritiesUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioBranchPrioritiesUse)")
    elif (name == "mioCutLevelTree"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutLevelTree)")
    elif (name == "logConcurrent"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logConcurrent)")
    elif (name == "intpntOrderMethod"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntOrderMethod)")
    elif (name == "logInfeasAna"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logInfeasAna)")
    elif (name == "simPrimalSelection"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalSelection)")
    elif (name == "mioCutCmir"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutCmir)")
    elif (name == "simDualRestrictSelection"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simDualRestrictSelection)")
    elif (name == "logMioFreq"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logMioFreq)")
    elif (name == "mioRootOptimizer"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioRootOptimizer)")
    elif (name == "presolveElimFill"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (presolveElimFill)")
    elif (name == "mioLocalBranchNumber"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioLocalBranchNumber)")
    elif (name == "warningLevel"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (warningLevel)")
    elif (name == "logBiFreq"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logBiFreq)")
    elif (name == "concurrentPriorityDualSimplex"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityDualSimplex)")
    elif (name == "logPresolve"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logPresolve)")
    elif (name == "intpntOffColTrh"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntOffColTrh)")
    elif (name == "mioMode"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioMode)")
    elif (name == "logSim"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logSim)")
    elif (name == "mtSpincount"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mtSpincount)")
    elif (name == "mioRinsMaxNodes"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioRinsMaxNodes)")
    elif (name == "simScalingMethod"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simScalingMethod)")
    elif (name == "logSimFreq"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logSimFreq)")
    elif (name == "presolveMaxNumReductions"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (presolveMaxNumReductions)")
    elif (name == "logFactor"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logFactor)")
    elif (name == "autoUpdateSolInfo"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (autoUpdateSolInfo)")
    elif (name == "timingLevel"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (timingLevel)")
    elif (name == "logOrder"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logOrder)")
    elif (name == "mioCutLevelRoot"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutLevelRoot)")
    elif (name == "biIgnoreNumError"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (biIgnoreNumError)")
    elif (name == "mioNodeSelection"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioNodeSelection)")
    elif (name == "intpntMaxNumRefinementSteps"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntMaxNumRefinementSteps)")
    elif (name == "logSimMinor"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logSimMinor)")
    elif (name == "simMaxIterations"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simMaxIterations)")
    elif (name == "mioProbingLevel"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioProbingLevel)")
    elif (name == "intpntMaxIterations"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntMaxIterations)")
    elif (name == "cacheLicense"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (cacheLicense)")
    elif (name == "logBi"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logBi)")
    elif (name == "intpntMaxNumCor"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntMaxNumCor)")
    elif (name == "licenseDebug"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (licenseDebug)")
    elif (name == "licTrhExpiryWrn"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (licTrhExpiryWrn)")
    elif (name == "presolveEliminatorMaxNumTries"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    elif (name == "concurrentNumOptimizers"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentNumOptimizers)")
    elif (name == "simRefactorFreq"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simRefactorFreq)")
    elif (name == "simDualSelection"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simDualSelection)")
    elif (name == "simSolveForm"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simSolveForm)")
    elif (name == "mioOptimizerMode"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioOptimizerMode)")
    elif (name == "logIntpnt"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logIntpnt)")
    elif (name == "logMio"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logMio)")
    elif (name == "simHotstart"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simHotstart)")
    elif (name == "logParam"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logParam)")
    elif (name == "simExploitDupvec"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simExploitDupvec)")
    elif (name == "mioBranchDir"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioBranchDir)")
    elif (name == "intpntFactorDebugLvl"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntFactorDebugLvl)")
    elif (name == "licensePauseTime"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (licensePauseTime)")
    elif (name == "mioPresolveAggregate"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioPresolveAggregate)")
    elif (name == "biMaxIterations"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (biMaxIterations)")
    elif (name == "simHotstartLu"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simHotstartLu)")
    elif (name == "presolveLindepRelWorkTrh"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLindepRelWorkTrh)")
    elif (name == "logFeasRepair"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logFeasRepair)")
    elif (name == "presolveLindepUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLindepUse)")
    elif (name == "intpntHotstart"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntHotstart)")
    elif (name == "mioContSol"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioContSol)")
    elif (name == "intpntStartingPoint"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntStartingPoint)")
    elif (name == "simMaxNumSetbacks"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simMaxNumSetbacks)")
    elif (name == "concurrentPriorityPrimalSimplex"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityPrimalSimplex)")
    elif (name == "logSimNetworkFreq"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logSimNetworkFreq)")
    elif (name == "intpntDiffStep"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntDiffStep)")
    elif (name == "simScaling"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simScaling)")
    elif (name == "biIgnoreMaxIter"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (biIgnoreMaxIter)")
    elif (name == "presolveLindepAbsWorkTrh"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    elif (name == "intpntSolveForm"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntSolveForm)")
    elif (name == "simBasisFactorUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simBasisFactorUse)")
    elif (name == "intpntRegularizationUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntRegularizationUse)")
    elif (name == "biCleanOptimizer"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (biCleanOptimizer)")
    elif (name == "mioPresolveProbing"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioPresolveProbing)")
    elif (name == "infeasPreferPrimal"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (infeasPreferPrimal)")
    elif (name == "logStorage"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logStorage)")
    elif (name == "mioPresolveUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioPresolveUse)")
    elif (name == "intpntBasis"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntBasis)")
    elif (name == "logCutSecondOpt"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logCutSecondOpt)")
    elif (name == "mioMaxNumSolutions"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxNumSolutions)")
    elif (name == "licenseWait"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (licenseWait)")
    elif (name == "concurrentPriorityFreeSimplex"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityFreeSimplex)")
    elif (name == "logFile"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logFile)")
    elif (name == "concurrentPriorityIntpnt"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (concurrentPriorityIntpnt)")
    elif (name == "simNonSingular"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simNonSingular)")
    elif (name == "simDegen"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simDegen)")
    elif (name == "presolveEliminatorUse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (presolveEliminatorUse)")
    elif (name == "allocAddQnz"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (allocAddQnz)")
    elif (name == "mioHotstart"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioHotstart)")
    elif (name == "logOptimizer"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logOptimizer)")
    elif (name == "mioMaxNumBranches"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxNumBranches)")
    elif (name == "simPrimalCrash"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalCrash)")
    elif (name == "mioConstructSol"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioConstructSol)")
    elif (name == "autoSortABeforeOpt"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (autoSortABeforeOpt)")
    elif (name == "mioStrongBranch"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioStrongBranch)")
    elif (name == "simDualPhaseoneMethod"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simDualPhaseoneMethod)")
    elif (name == "simInteger"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simInteger)")
    elif (name == "mioUseMultithreadedOptimizer"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioUseMultithreadedOptimizer)")
    elif (name == "simPrimalRestrictSelection"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simPrimalRestrictSelection)")
    elif (name == "optimizer"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (optimizer)")
    elif (name == "maxNumWarnings"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (maxNumWarnings)")
    elif (name == "licenseSuppressExpireWrns"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (licenseSuppressExpireWrns)")
    elif (name == "mioCutCg"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioCutCg)")
    elif (name == "logExpand"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logExpand)")
    elif (name == "mioFeaspumpLevel"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioFeaspumpLevel)")
    elif (name == "logResponse"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logResponse)")
    elif (name == "log"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (log)")
    elif (name == "simSwitchOptimizer"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simSwitchOptimizer)")
    elif (name == "numThreads"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (numThreads)")
    elif (name == "logCheckConvexity"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logCheckConvexity)")
    elif (name == "simDualCrash"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simDualCrash)")
    elif (name == "logHead"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (logHead)")
    elif (name == "simReformulation"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simReformulation)")
    elif (name == "simSaveLu"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (simSaveLu)")
    elif (name == "intpntFactorMethod"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntFactorMethod)")
    elif (name == "mioMaxNumRelaxs"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxNumRelaxs)")
    elif (name == "solFilterKeepBasic"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (solFilterKeepBasic)")
    elif (name == "mioHeuristicLevel"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioHeuristicLevel)")
    elif (name == "mioKeepBasis"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (mioKeepBasis)")
    elif (name == "intpntScaling"):
      raise mosek.fusion.ParameterError("Invalid value for parameter (intpntScaling)")
    elif (name == "lowerObjCutFiniteTrh"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lowerObjCutFiniteTrh)")
    elif (name == "mioMaxTime"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_MAX_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxTime)")
    elif (name == "basisTolS"):
      v = value

      if   (1.000000e-09 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_BASIS_TOL_S",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basisTolS)")
    elif (name == "presolveTolS"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_S",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolS)")
    elif (name == "upperObjCut"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_UPPER_OBJ_CUT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (upperObjCut)")
    elif (name == "intpntCoTolDfeas"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_DFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolDfeas)")
    elif (name == "mioTolAbsGap"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_ABS_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolAbsGap)")
    elif (name == "upperObjCutFiniteTrh"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (upperObjCutFiniteTrh)")
    elif (name == "mioTolAbsRelaxInt"):
      v = value

      if   (1.000000e-09 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolAbsRelaxInt)")
    elif (name == "mioTolMaxCutFracRhs"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_MAX_CUT_FRAC_RHS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolMaxCutFracRhs)")
    elif (name == "simplexAbsTolPiv"):
      v = value

      if   (1.000000e-12 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simplexAbsTolPiv)")
    elif (name == "mioTolRelDualBoundImprovement"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolRelDualBoundImprovement)")
    elif (name == "mioHeuristicTime"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_HEURISTIC_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioHeuristicTime)")
    elif (name == "presolveTolX"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_X",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolX)")
    elif (name == "mioNearTolRelGap"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_NEAR_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioNearTolRelGap)")
    elif (name == "mioTolMinCutFracRhs"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_MIN_CUT_FRAC_RHS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolMinCutFracRhs)")
    elif (name == "presolveTolRelLindep"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolRelLindep)")
    elif (name == "intpntTolDsafe"):
      v = value

      if   (1.000000e-04 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_DSAFE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolDsafe)")
    elif (name == "mioTolFeas"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_FEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolFeas)")
    elif (name == "intpntTolInfeas"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_INFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolInfeas)")
    elif (name == "optimizerMaxTime"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_OPTIMIZER_MAX_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (optimizerMaxTime)")
    elif (name == "anaSolInfeasTol"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_ANA_SOL_INFEAS_TOL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (anaSolInfeasTol)")
    elif (name == "mioRelAddCutLimited"):
      v = value

      if   (v <= 2.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_REL_ADD_CUT_LIMITED",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioRelAddCutLimited)")
    elif (name == "intpntTolMuRed"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_MU_RED",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolMuRed)")
    elif (name == "intpntCoTolMuRed"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_MU_RED",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolMuRed)")
    elif (name == "intpntCoTolRelGap"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolRelGap)")
    elif (name == "lowerObjCut"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_LOWER_OBJ_CUT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (lowerObjCut)")
    elif (name == "mioDisableTermTime"):
      v = value

      if   True:
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_DISABLE_TERM_TIME",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioDisableTermTime)")
    elif (name == "intpntTolRelStep"):
      v = value

      if   (v <= 9.999990e-01):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_REL_STEP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolRelStep)")
    elif (name == "mioTolX"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_X",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolX)")
    elif (name == "simLuTolRelPiv"):
      v = value

      if   (v <= 9.999990e-01):
        ( M._task_1put_1param_SF("MSK_DPAR_SIM_LU_TOL_REL_PIV",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (simLuTolRelPiv)")
    elif (name == "intpntTolStepSize"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_STEP_SIZE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolStepSize)")
    elif (name == "intpntTolPfeas"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolPfeas)")
    elif (name == "basisRelTolS"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_BASIS_REL_TOL_S",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basisRelTolS)")
    elif (name == "presolveTolAbsLindep"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolAbsLindep)")
    elif (name == "intpntCoTolInfeas"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_INFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolInfeas)")
    elif (name == "mioRelGapConst"):
      v = value

      if   (1.000000e-15 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_REL_GAP_CONST",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioRelGapConst)")
    elif (name == "presolveTolAij"):
      v = value

      if   (1.000000e-15 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_PRESOLVE_TOL_AIJ",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (presolveTolAij)")
    elif (name == "mioMaxTimeAprxOpt"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_MAX_TIME_APRX_OPT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioMaxTimeAprxOpt)")
    elif (name == "intpntTolPath"):
      v = value

      if   (v <= 9.999000e-01):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PATH",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolPath)")
    elif (name == "basisTolX"):
      v = value

      if   (1.000000e-09 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_BASIS_TOL_X",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (basisTolX)")
    elif (name == "intpntTolRelGap"):
      v = value

      if   (1.000000e-14 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolRelGap)")
    elif (name == "intpntTolPsafe"):
      v = value

      if   (1.000000e-04 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_PSAFE",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolPsafe)")
    elif (name == "intpntCoTolNearRel"):
      v = value

      if   (1.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolNearRel)")
    elif (name == "mioTolRelGap"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolRelGap)")
    elif (name == "intpntTolDfeas"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_TOL_DFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntTolDfeas)")
    elif (name == "mioNearTolAbsGap"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_NEAR_TOL_ABS_GAP",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioNearTolAbsGap)")
    elif (name == "mioTolRelRelaxInt"):
      v = value

      if   (0.000000e+00 <= v):
        ( M._task_1put_1param_SF("MSK_DPAR_MIO_TOL_REL_RELAX_INT",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (mioTolRelRelaxInt)")
    elif (name == "intpntCoTolPfeas"):
      v = value

      if   (v <= 1.000000e+00):
        ( M._task_1put_1param_SF("MSK_DPAR_INTPNT_CO_TOL_PFEAS",v) )
      else:
        raise mosek.fusion.ParameterError("Invalid value for parameter (intpntCoTolPfeas)")
    else:
      raise mosek.fusion.ParameterError("Unknown parameter")
  @staticmethod
  @_cliptrace
  def setParameter(*args):
    if   Parameters._matchargs_setParameter_Omosek_fusion_Model_2SS(args):
      return Parameters._setParameter_Omosek_fusion_Model_2SS(*args)
    elif Parameters._matchargs_setParameter_Omosek_fusion_Model_2SF(args):
      return Parameters._setParameter_Omosek_fusion_Model_2SF(*args)
    elif Parameters._matchargs_setParameter_Omosek_fusion_Model_2SI(args):
      return Parameters._setParameter_Omosek_fusion_Model_2SI(*args)
    else:
      argtypestr = "setParameter(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tsetParameter(mosek.fusion.Model,basestring,basestring)"),(3,"\tsetParameter(mosek.fusion.Model,basestring,float)"),(3,"\tsetParameter(mosek.fusion.Model,basestring,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(211:5-218:5)
class FatalError(Exception):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(215:17-217:9)")
  def __constructor_S(self,msg):
    Exception.__init__(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  def __str__(self): return self.toString()
 
## origin: src/fusion/domain.mbi(25:5-35:5)
class PSDDomain:
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_PSDKey_2Omosek_fusion_Set_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.PSDKey): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.PSDKey,mosek.fusion.Set) @ src/fusion/domain.mbi(31:18-34:7)")
  def __constructor_Omosek_fusion_PSDKey_2Omosek_fusion_Set_2(self,k,shp):
    self._shape = shp
    self._key = k
  def __init__(self,*args):
    #self._protected_shape = None

    #self._protected_key = None

    self.__constructor_Omosek_fusion_PSDKey_2Omosek_fusion_Set_2(*args)
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(6:5-11:5)
class FusionException(Utils.FusionException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(10:15-9:67)")
  def __constructor_S(self,msg_):
    mosek.fusion.Utils.FusionException.__init__(self,msg_)
    self.__msg = msg_
  def __init__(self,*args):
    #self.__msg = None

    self.__constructor_S(*args)
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Errors.mbi(11:15-10:53)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    return self.__msg
  @_cliptrace
  def toString(self,*args):
    if   FusionException._matchargs_toString_(args):
      return FusionException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(172:5-184:5)
class SolutionError(FusionException):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(176:17-178:9)")
  def __constructor_S(self,msg):
    mosek.fusion.FusionException._FusionException__constructor_S(self,msg)
    pass
  @staticmethod
  def _matchargs_constructor_(args):
    if len(args) != 0:
      return False
    return True
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("__init__() @ src/fusion/Errors.mbi(181:17-183:9)")
  def __constructor_(self):
    mosek.fusion.FusionException._FusionException__constructor_S(self,"Solution is invalid or undefined")
    pass
  def __init__(self,*args):
    if   self._matchargs_constructor_S(args):
      self.__constructor_S(*args)
    elif self._matchargs_constructor_(args):
      self.__constructor_(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @_cliptrace
  def toString(self,*args):
    if   FusionException._matchargs_toString_(args):
      return FusionException._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Matrix.mbi(33:5-613:5)
class Matrix:
  @staticmethod
  def _matchargs_constructor_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int) @ src/fusion/Matrix.mbi(41:18-44:7)")
  def __constructor_II(self,di,dj):
    self._dimi = di
    self._dimj = dj
  def __init__(self,*args):
    #self._protected_dimi = None

    #self._protected_dimj = None

    self.__constructor_II(*args)
  @staticmethod
  def _matchargs_numRows_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(50:15-49:51)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numRows()")
  def _numRows_(self):
    return self._dimi
  @staticmethod
  def _matchargs_numColumns_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(55:15-54:54)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numColumns()")
  def _numColumns_(self):
    return self._dimj
  @staticmethod
  def _matchargs_numNonzeros_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(60:15-59:53)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numNonzeros()")
  def _numNonzeros_(self):
    pass
  @staticmethod
  def _matchargs_transpose_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(62:15-61:53)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("transpose()")
  def _transpose_(self):
    pass
  @staticmethod
  def _matchargs_getDataAsTriplets__3I_3I_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(77:15-81:8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getDataAsTriplets([int],[int],[float])")
  def _getDataAsTriplets__3I_3I_3F(self,subi,subj,val):
    pass
  @staticmethod
  def _matchargs_getDataAsArray_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(91:15-8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getDataAsArray()")
  def _getDataAsArray_(self):
    pass
  @staticmethod
  def _matchargs_isSparse_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(96:15-8)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("isSparse()")
  def _isSparse_(self):
    pass
  @staticmethod
  def _matchargs_get_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Matrix.mbi(99:15-98:61)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get(int,int)")
  def _get_II(self,i,j):
    pass
  @staticmethod
  def _matchargs_sparse_II_3I_3I_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(110:15-130:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparse(int,int,[int],[int],[float])")
  def _sparse_II_3I_3I_3F(nrow,ncol,subi,subj,val):



    if   (subi == None):
      si = ([ 0 for _autovar_517 in xrange(0) ])
    else:
      si = subi
    if   (subj == None):
      sj = ([ 0 for _autovar_518 in xrange(0) ])
    else:
      sj = subj
    if   (val == None):
      vl = ([ 0.0 for _autovar_519 in xrange(0) ])
    else:
      vl = val
    nnz = long(len(si))

    if   ((long(len(sj)) != nnz) or (long(len(vl)) != nnz)):
      raise mosek.fusion.SparseFormatError("Arrays defining sparse data have different lengths")
    return mosek.fusion.SparseMatrix(nrow,ncol,si,sj,vl,nnz)
  @staticmethod
  def _matchargs_sparse__3I_3I_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(139:15-154:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparse([int],[int],[float])")
  def _sparse__3I_3I_3F(subi,subj,val):
    maxi = 0

    maxj = 0

    num = int(len(subi))

    if   (num > int(len(subj))):
      num = int(len(subj))
    if   (num > int(len(val))):
      num = int(len(val))
    # src/fusion/Matrix.mbi(148:9-152:9)
    for i in xrange(0,num):
      # { @ src/fusion/Matrix.mbi(149:9-152:9)
      if   (maxi < subi[i]):
        maxi = subi[i]
      if   (maxj < subj[i]):
        maxj = subj[i]
      # } @ src/fusion/Matrix.mbi(149:9-152:9)
    return ( Matrix._sparse_II_3I_3I_3F ((maxi + 1),(maxj + 1),subi,subj,val) )
  @staticmethod
  def _matchargs_sparse__3I_3IF(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Matrix.mbi(163:15-177:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparse([int],[int],float)")
  def _sparse__3I_3IF(subi,subj,val):
    maxi = 0

    maxj = 0

    num = int(len(subi))

    if   (num > int(len(subj))):
      num = int(len(subj))
    # src/fusion/Matrix.mbi(171:9-175:9)
    for i in xrange(0,num):
      # { @ src/fusion/Matrix.mbi(172:9-175:9)
      if   (maxi < subi[i]):
        maxi = subi[i]
      if   (maxj < subj[i]):
        maxj = subj[i]
      # } @ src/fusion/Matrix.mbi(172:9-175:9)
    return ( Matrix._sparse_II_3I_3IF ((maxi + 1),(maxj + 1),subi,subj,val) )
  @staticmethod
  def _matchargs_sparse_II_3I_3IF(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[4],float): return False
    return True
  # origin: src/fusion/Matrix.mbi(188:15-198:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparse(int,int,[int],[int],float)")
  def _sparse_II_3I_3IF(nrow,ncol,subi,subj,val):
    sz = 0

    if   (subi != None):
      sz = int(len(subi))
    elif (subj != None):
      sz = int(len(subj))
    return ( Matrix._sparse_II_3I_3I_3F (nrow,ncol,subi,subj,( Utils.Tools._makevector_FI (val,sz) )) )
  @staticmethod
  def _matchargs_sparse_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Matrix.mbi(207:15-209:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparse(int,int)")
  def _sparse_II(nrow,ncol):
    return mosek.fusion.SparseMatrix(nrow,ncol,None,None,None,0l)
  @staticmethod
  def _matchargs_sparse__3_3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(216:15-239:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("sparse([[float]])")
  def _sparse__3_3F(data):
    dimi = int(len(data))

    dimj = int(len(data[0]))

    nelem = long((dimi * dimj))

    subi = ([ 0 for _autovar_520 in xrange(nelem) ])

    subj = ([ 0 for _autovar_521 in xrange(nelem) ])

    val = ([ 0.0 for _autovar_522 in xrange(nelem) ])

    k = 0

    # src/fusion/Matrix.mbi(226:9-237:9)
    i = 0

    while (i < dimi):
      ( Utils.Tools._arraycopy__3FI_3FII (data[i],0,val,k,dimj) )
      # src/fusion/Matrix.mbi(230:11-234:11)
      j = 0

      while (j < dimj):
        subi[(k + j)] = i
        subj[(k + j)] = j
        j += 1
      k = (k + dimj)
      i += 1
    return mosek.fusion.SparseMatrix(dimi,dimj,subi,subj,val)
  @staticmethod
  def _matchargs_sparse__3_3Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not isinstance(a,mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Matrix.mbi(259:15-399:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("sparse([[mosek.fusion.Matrix]])")
  def _sparse__3_3Omosek_fusion_Matrix_2(blocks):
    maxi = int(len(blocks))

    maxj = int(len(blocks[0]))

    idims = ([ 0 for _autovar_523 in xrange(maxi) ])

    jdims = ([ 0 for _autovar_524 in xrange(maxj) ])

    nelm = 0l

    k = 0

    # src/fusion/Matrix.mbi(269:9-298:9)
    i = 0

    while (i < maxi):
      # src/fusion/Matrix.mbi(271:11-297:11)
      j = 0

      while (j < maxj):
        m = blocks[i][j]

        if   (m != None):
          if   (jdims[j] == 0):
            jdims[j] = m._dimj
          elif (jdims[j] != m._dimj):
            raise mosek.fusion.SparseFormatError("Sparse matrix construction blocks are not aligned")
          if   (idims[i] == 0):
            idims[i] = m._dimi
          elif (idims[i] != m._dimi):
            raise mosek.fusion.SparseFormatError("Sparse matrix construction blocks are not aligned")
          nelm = (nelm + ( m._numNonzeros_() ))
        k += 1
        j += 1
      i += 1

    cof = ([ 0.0 for _autovar_525 in xrange(nelm) ])
    subi = ([ 0 for _autovar_526 in xrange(nelm) ])

    subj = ([ 0 for _autovar_527 in xrange(nelm) ])

    dstp = 0

    offseti = 0

    # src/fusion/Matrix.mbi(332:9-386:9)
    i = 0

    while (i < maxi):
      lidxs = ([ 0 for _autovar_528 in xrange(maxj) ])

      # src/fusion/Matrix.mbi(336:11-384:11)
      ii = 0

      while (ii < idims[i]):
        offsetj = 0

        # src/fusion/Matrix.mbi(340:13-382:13)
        j = 0

        while (j < maxj):
          m_ = blocks[i][j]

          if   (m_ != None):
            _autovar_529 = m_
            if   isinstance(_autovar_529,mosek.fusion.DenseMatrix):
              m = _autovar_529
              kk = lidxs[j]

              # src/fusion/Matrix.mbi(349:19-357:19)
              jj = 0

              while (jj < m._dimj):
                cof[dstp] = m._data[kk]
                subi[dstp] = (offseti + ii)
                subj[dstp] = (offsetj + jj)
                kk += 1
                dstp += 1
                jj += 1
              lidxs[j] = kk
            elif isinstance(_autovar_529,mosek.fusion.SparseMatrix):
              m = _autovar_529

              # src/fusion/Matrix.mbi(364:19-373:19)
              kk = lidxs[j]
              while ((kk < m._nnz) and (m._subi[kk] == ii)):
                cof[dstp] = m._val[kk]
                subj[dstp] = (m._subj[kk] + offsetj)
                subi[dstp] = (offseti + ii)
                dstp += 1
                kk += 1
              lidxs[j] = kk
            else:
              m = _autovar_529
              raise mosek.fusion.MatrixError("Unknown matrix type.")
          offsetj = (offsetj + jdims[j])
          j += 1
        ii += 1
      offseti = (offseti + idims[i])
      i += 1
    dimi = 0

    dimj = 0

    # src/fusion/Matrix.mbi(389:9-392:9)
    i = 0

    while (i < maxi):
      dimi = (dimi + idims[i])
      i += 1
    # src/fusion/Matrix.mbi(393:9-396:9)
    j = 0

    while (j < maxj):
      dimj = (dimj + jdims[j])
      j += 1
    return mosek.fusion.SparseMatrix(dimi,dimj,subi,subj,cof)
  @staticmethod
  def _matchargs_sparse_Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Matrix.mbi(409:15-449:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("sparse(mosek.fusion.Matrix)")
  def _sparse_Omosek_fusion_Matrix_2(v_):
    _autovar_530 = v_
    if   isinstance(_autovar_530,mosek.fusion.DenseMatrix):
      v = _autovar_530
      p = 0

      nelem = (v._dimi * v._dimj)

      subi = ([ 0 for _autovar_531 in xrange(nelem) ])

      subj = ([ 0 for _autovar_532 in xrange(nelem) ])

      # src/fusion/Matrix.mbi(418:11-426:11)
      i = 0

      while (i < v._dimi):
        # src/fusion/Matrix.mbi(420:13-425:13)
        j = 0

        while (j < v._dimj):
          subi[p] = i
          subj[p] = j
          p += 1
          j += 1
        i += 1
      val = ( Utils.Tools._arraycopy__3F (v._data) )

      return mosek.fusion.SparseMatrix(v._dimi,v._dimj,subi,subj,val)
    elif isinstance(_autovar_530,mosek.fusion.SparseMatrix):
      v = _autovar_530
      if   (v._nnz > 0):
        subi = ( Utils.Tools._arraycopy__3I (v._subi) )

        subj = ( Utils.Tools._arraycopy__3I (v._subj) )

        val = ( Utils.Tools._arraycopy__3F (v._val) )

        return mosek.fusion.SparseMatrix(v._dimi,v._dimj,subi,subj,val)
      else:
        return mosek.fusion.SparseMatrix(v._dimi,v._dimj,None,None,None)
    else:
      m = _autovar_530
      raise mosek.fusion.MatrixError("Unknown matrix type.")
  @staticmethod
  def _matchargs_diag__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(452:15-454:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("diag([float])")
  def _diag__3F(d):
    return ( Matrix._diag__3FI (d,0) )
  @staticmethod
  def _matchargs_diag__3FI(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Matrix.mbi(457:15-475:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("diag([float],int)")
  def _diag__3FI(d,k):
    absk = k

    if   (absk < 0):
      absk = (- k)
    dimi = (int(len(d)) + absk)

    n = int(len(d))

    if   (k >= 0):
      subi = ( Utils.Tools._range_II (0,n) )

      subj = ( Utils.Tools._range_II (k,(n + k)) )

      return mosek.fusion.SparseMatrix(dimi,dimi,subi,subj,d)
    else:
      subi = ( Utils.Tools._range_II (k,(n + k)) )

      subj = ( Utils.Tools._range_II (0,n) )

      return mosek.fusion.SparseMatrix(dimi,dimi,subi,subj,d)
  @staticmethod
  def _matchargs_antidiag__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(478:15-480:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("antidiag([float])")
  def _antidiag__3F(d):
    return ( Matrix._antidiag__3FI (d,0) )
  @staticmethod
  def _matchargs_antidiag__3FI(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Matrix.mbi(483:15-502:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("antidiag([float],int)")
  def _antidiag__3FI(d,k):
    absk = k

    if   (absk < 0):
      absk = (- k)
    dimi = (int(len(d)) + absk)

    n = int(len(d))

    if   (k >= 0):
      subi = ( Utils.Tools._range_II (k,(n + k)) )

      subj = ([ 0 for _autovar_533 in xrange(n) ])

      # src/fusion/Matrix.mbi(491:30-66)
      for i in xrange(0,n):
        subj[i] = (((n + k) - i) - 1)
      return mosek.fusion.SparseMatrix(dimi,dimi,subi,subj,d)
    else:
      subi = ( Utils.Tools._range_II (0,n) )

      subj = ([ 0 for _autovar_534 in xrange(n) ])

      # src/fusion/Matrix.mbi(498:30-64)
      for i in xrange(0,n):
        subj[i] = ((n - i) - 1)
      return mosek.fusion.SparseMatrix(dimi,dimi,subi,subj,d)
  @staticmethod
  def _matchargs_diag_IF(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Matrix.mbi(505:15-507:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("diag(int,float)")
  def _diag_IF(n,val):
    return ( Matrix._diag__3FI (( Utils.Tools._makevector_FI (val,n) ),0) )
  @staticmethod
  def _matchargs_diag_IFI(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],float): return False
    if not isinstance(args[2],int): return False
    return True
  # origin: src/fusion/Matrix.mbi(510:15-517:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("diag(int,float,int)")
  def _diag_IFI(n,val,k):
    if   ((k < n) and (k >= 0)):
      return ( Matrix._diag__3FI (( Utils.Tools._makevector_FI (val,(n - k)) ),k) )
    elif ((k > (- n)) and (k < 0)):
      return ( Matrix._diag__3FI (( Utils.Tools._makevector_FI (val,(n + k)) ),k) )
    else:
      return ( Matrix._sparse_II (n,n) )
  @staticmethod
  def _matchargs_antidiag_IF(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Matrix.mbi(520:15-522:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("antidiag(int,float)")
  def _antidiag_IF(n,val):
    return ( Matrix._antidiag__3FI (( Utils.Tools._makevector_FI (val,n) ),0) )
  @staticmethod
  def _matchargs_antidiag_IFI(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],float): return False
    if not isinstance(args[2],int): return False
    return True
  # origin: src/fusion/Matrix.mbi(525:15-532:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("antidiag(int,float,int)")
  def _antidiag_IFI(n,val,k):
    if   ((k < n) and (k >= 0)):
      return ( Matrix._antidiag__3FI (( Utils.Tools._makevector_FI (val,(n - k)) ),k) )
    elif ((k > (- n)) and (k < 0)):
      return ( Matrix._antidiag__3FI (( Utils.Tools._makevector_FI (val,(n + k)) ),k) )
    else:
      return ( Matrix._sparse_II (n,n) )
  @staticmethod
  def _matchargs_diag__3Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not isinstance(a,mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Matrix.mbi(545:15-587:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("diag([mosek.fusion.Matrix])")
  def _diag__3Omosek_fusion_Matrix_2(md):
    d = md

    numelm = 0l

    dimi = 0

    dimj = 0

    # src/fusion/Matrix.mbi(550:9-555:9)
    for i in xrange(0,int(len(md))):
      # { @ src/fusion/Matrix.mbi(551:9-555:9)
      dimi = (dimi + md[i]._dimi)
      dimj = (dimj + md[i]._dimj)
      numelm = (numelm + ( md[i]._numNonzeros_() ))
      # } @ src/fusion/Matrix.mbi(551:9-555:9)
    subi = ([ 0 for _autovar_535 in xrange(numelm) ])

    subj = ([ 0 for _autovar_536 in xrange(numelm) ])

    val = ([ 0.0 for _autovar_537 in xrange(numelm) ])

    # { @ src/fusion/Matrix.mbi(561:9-584:9)
    offseti = 0

    offsetj = 0

    k = 0l

    # src/fusion/Matrix.mbi(565:11-583:11)
    for i in xrange(0,int(len(md))):
      # { @ src/fusion/Matrix.mbi(566:11-583:11)
      N = ( md[i]._numNonzeros_() )

      msubi = ([ 0 for _autovar_538 in xrange(N) ])

      msubj = ([ 0 for _autovar_539 in xrange(N) ])

      mval = ([ 0.0 for _autovar_540 in xrange(N) ])

      ( md[i]._getDataAsTriplets__3I_3I_3F(msubi,msubj,mval) )
      ( Utils.Tools._arraycopy__3FL_3FLL (mval,0l,val,k,N) )
      # src/fusion/Matrix.mbi(574:13-578:13)
      for j in xrange(0l,N):
        # { @ src/fusion/Matrix.mbi(575:13-578:13)
        subi[(k + j)] = (msubi[j] + offseti)
        subj[(k + j)] = (msubi[j] + offsetj)
        # } @ src/fusion/Matrix.mbi(575:13-578:13)
      k = (k + N)
      offseti = (offseti + md[i]._dimi)
      offsetj = (offsetj + md[i]._dimj)
      # } @ src/fusion/Matrix.mbi(566:11-583:11)
    # } @ src/fusion/Matrix.mbi(561:9-584:9)
    return mosek.fusion.SparseMatrix(dimi,dimj,subi,subj,val)
  @staticmethod
  def _matchargs_diag_IOmosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/Matrix.mbi(596:15-600:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("diag(int,mosek.fusion.Matrix)")
  def _diag_IOmosek_fusion_Matrix_2(num,mv):
    d = ([ None for _autovar_541 in xrange(num) ])

    # src/fusion/Matrix.mbi(598:9-39)
    for i in xrange(0,num):
      d[i] = mv
    return ( Matrix._diag__3Omosek_fusion_Matrix_2 (d) )
  @staticmethod
  def _matchargs_switchDims_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(604:18-607:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("switchDims()")
  def _switchDims_(self):
    tmp = self._dimi

    self._dimi = self._dimj
    self._dimj = tmp
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(613:15-612:50)
  #@Utils.abstractmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    pass
  @_cliptrace
  def numRows(self,*args):
    if   Matrix._matchargs_numRows_(args):
      return Matrix._numRows_(self,*args)
    else:
      argtypestr = "numRows(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumRows()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def numColumns(self,*args):
    if   Matrix._matchargs_numColumns_(args):
      return Matrix._numColumns_(self,*args)
    else:
      argtypestr = "numColumns(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumColumns()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get(self,*args):
    if   Matrix._matchargs_get_II(args):
      return Matrix._get_II(self,*args)
    else:
      argtypestr = "get(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tget(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def diag(*args):
    if   Matrix._matchargs_diag_IOmosek_fusion_Matrix_2(args):
      return Matrix._diag_IOmosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_diag__3FI(args):
      return Matrix._diag__3FI(*args)
    elif Matrix._matchargs_diag__3F(args):
      return Matrix._diag__3F(*args)
    elif Matrix._matchargs_diag_IF(args):
      return Matrix._diag_IF(*args)
    elif Matrix._matchargs_diag__3Omosek_fusion_Matrix_2(args):
      return Matrix._diag__3Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_diag_IFI(args):
      return Matrix._diag_IFI(*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdiag(int,mosek.fusion.Matrix)"),(2,"\tdiag([float],int)"),(1,"\tdiag([float])"),(2,"\tdiag(int,float)"),(1,"\tdiag([mosek.fusion.Matrix])"),(3,"\tdiag(int,float,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   Matrix._matchargs_transpose_(args):
      return Matrix._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getDataAsArray(self,*args):
    if   Matrix._matchargs_getDataAsArray_(args):
      return Matrix._getDataAsArray_(self,*args)
    else:
      argtypestr = "getDataAsArray(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetDataAsArray()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def isSparse(self,*args):
    if   Matrix._matchargs_isSparse_(args):
      return Matrix._isSparse_(self,*args)
    else:
      argtypestr = "isSparse(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tisSparse()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   Matrix._matchargs_toString_(args):
      return Matrix._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def antidiag(*args):
    if   Matrix._matchargs_antidiag_IFI(args):
      return Matrix._antidiag_IFI(*args)
    elif Matrix._matchargs_antidiag_IF(args):
      return Matrix._antidiag_IF(*args)
    elif Matrix._matchargs_antidiag__3F(args):
      return Matrix._antidiag__3F(*args)
    elif Matrix._matchargs_antidiag__3FI(args):
      return Matrix._antidiag__3FI(*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tantidiag(int,float,int)"),(2,"\tantidiag(int,float)"),(1,"\tantidiag([float])"),(2,"\tantidiag([float],int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def sparse(*args):
    if   Matrix._matchargs_sparse_Omosek_fusion_Matrix_2(args):
      return Matrix._sparse_Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_sparse__3_3Omosek_fusion_Matrix_2(args):
      return Matrix._sparse__3_3Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_sparse__3I_3IF(args):
      return Matrix._sparse__3I_3IF(*args)
    elif Matrix._matchargs_sparse__3_3F(args):
      return Matrix._sparse__3_3F(*args)
    elif Matrix._matchargs_sparse_II(args):
      return Matrix._sparse_II(*args)
    elif Matrix._matchargs_sparse_II_3I_3I_3F(args):
      return Matrix._sparse_II_3I_3I_3F(*args)
    elif Matrix._matchargs_sparse_II_3I_3IF(args):
      return Matrix._sparse_II_3I_3IF(*args)
    elif Matrix._matchargs_sparse__3I_3I_3F(args):
      return Matrix._sparse__3I_3I_3F(*args)
    else:
      argtypestr = "sparse(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsparse(mosek.fusion.Matrix)"),(1,"\tsparse([[mosek.fusion.Matrix]])"),(3,"\tsparse([int],[int],float)"),(1,"\tsparse([[float]])"),(2,"\tsparse(int,int)"),(5,"\tsparse(int,int,[int],[int],[float])"),(5,"\tsparse(int,int,[int],[int],float)"),(3,"\tsparse([int],[int],[float])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getDataAsTriplets(self,*args):
    if   Matrix._matchargs_getDataAsTriplets__3I_3I_3F(args):
      return Matrix._getDataAsTriplets__3I_3I_3F(self,*args)
    else:
      argtypestr = "getDataAsTriplets(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tgetDataAsTriplets([int],[int],[float])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def numNonzeros(self,*args):
    if   Matrix._matchargs_numNonzeros_(args):
      return Matrix._numNonzeros_(self,*args)
    else:
      argtypestr = "numNonzeros(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumNonzeros()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Matrix.mbi(617:5-832:5)
class SparseMatrix(Matrix):
  @staticmethod
  def _matchargs_constructor_II_3I_3I_3F(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int,[int],[int],[float]) @ src/fusion/Matrix.mbi(657:18-699:7)")
  def __constructor_II_3I_3I_3F(self,dimi_,dimj_,subi_,subj_,val_):
    mosek.fusion.Matrix._Matrix__constructor_II(self,dimi_,dimj_)
    nelm = long(len(subi_))

    if   (nelm > int(len(subj_))):
      nelm = long(len(subj_))
    if   (nelm > int(len(val_))):
      nelm = long(len(val_))
    if   (nelm > 0):
      if   (((int(len(subi_)) < nelm) or (int(len(subj_)) < nelm)) or (int(len(val_)) < nelm)):
        raise mosek.fusion.SparseFormatError("Mismatching arrays in sparse data.")
      # src/fusion/Matrix.mbi(675:11-681:16)
      for i in xrange(0l,nelm):
        if   ((((subi_[i] < 0) or (subi_[i] >= self._dimi)) or (subj_[i] < 0)) or (subj_[i] >= self._dimj)):
          raise mosek.fusion.SparseFormatError("Subscript out of bounds.")
      ressubi = ([ 0 for _autovar_542 in xrange(1) ])

      ressubj = ([ 0 for _autovar_543 in xrange(1) ])

      resval = ([ 0.0 for _autovar_544 in xrange(1) ])

      ( CommonTools._tripletSort__3I_3I_3F_3_3I_3_3I_3_3FLII (subi_,subj_,val_,ressubi,ressubj,resval,nelm,self._dimi,self._dimj) )
      self._subi = ressubi[0]
      self._subj = ressubj[0]
      self._val = resval[0]
      self._nnz = long(len(self._val))
    else:
      self._subi = None
      self._subj = None
      self._val = None
      self._nnz = 0l
    self._subi = subi_
    self._subj = subj_
    self._val = val_
  @staticmethod
  def _matchargs_constructor_II_3I_3I_3FL(args):
    if len(args) != 6:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[5],long): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int,[int],[int],[float],long) @ src/fusion/Matrix.mbi(715:15-754:7)")
  def __constructor_II_3I_3I_3FL(self,dimi_,dimj_,subi_,subj_,val_,nelm):
    mosek.fusion.Matrix._Matrix__constructor_II(self,dimi_,dimj_)
    if   (nelm > 0):
      if   (((int(len(subi_)) < nelm) or (int(len(subj_)) < nelm)) or (int(len(val_)) < nelm)):
        raise mosek.fusion.SparseFormatError("Mismatching arrays in sparse data.")
      # src/fusion/Matrix.mbi(733:11-739:16)
      for i in xrange(0l,nelm):
        if   ((((subi_[i] < 0) or (subi_[i] >= self._dimi)) or (subj_[i] < 0)) or (subj_[i] >= self._dimj)):
          raise mosek.fusion.SparseFormatError("Subscript out of bounds.")
      ressubi = ([ 0 for _autovar_545 in xrange(1) ])

      ressubj = ([ 0 for _autovar_546 in xrange(1) ])

      resval = ([ 0.0 for _autovar_547 in xrange(1) ])

      ( CommonTools._tripletSort__3I_3I_3F_3_3I_3_3I_3_3FLII (subi_,subj_,val_,ressubi,ressubj,resval,nelm,self._dimi,self._dimj) )
      self._subi = ressubi[0]
      self._subj = ressubj[0]
      self._val = resval[0]
      self._nnz = long(len(self._val))
    else:
      self._subi = None
      self._subj = None
      self._val = None
      self._nnz = 0l
  def __init__(self,*args):
    #self._protected_subi = None

    #self._protected_subj = None

    #self._protected_val = None

    #self._protected_nnz = None

    if   self._matchargs_constructor_II_3I_3I_3F(args):
      self.__constructor_II_3I_3I_3F(*args)
    elif self._matchargs_constructor_II_3I_3I_3FL(args):
      self.__constructor_II_3I_3I_3FL(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_get_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Matrix.mbi(629:15-645:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get(int,int)")
  def _get_II(self,i,j):
    if   ((((i < 0) or (i >= self._dimi)) or (j < 0)) or (j >= self._dimj)):
      raise mosek.fusion.IndexError("Index out if bounds")
    b = 0

    e = int(len(self._subi))

    # src/fusion/Matrix.mbi(635:9-642:9)
    while ((e - b) > 1):
      p = ((b + e) / 2)

      if   ((self._subi[p] < i) or ((self._subi[p] == i) and (self._subj[p] < j))):
        b = p
      elif ((self._subi[p] > i) or ((self._subi[p] == i) and (self._subj[p] > j))):
        e = p
      else:
        return self._val[p]
    if   ((self._subi[b] == i) and (self._subj[b] == j)):
      return self._val[b]
    else:
      return 0.0
  @staticmethod
  def _matchargs_getDataAsTriplets__3I_3I_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(759:15-776:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getDataAsTriplets([int],[int],[float])")
  def _getDataAsTriplets__3I_3I_3F(self,subi_,subj_,cof_):
    if   (((long(len(subi_)) < self._nnz) or (long(len(subj_)) < self._nnz)) or (long(len(cof_)) < self._nnz)):
      raise mosek.fusion.LengthError("Output arrays are not long enough.")
    if   ((self._subi != None) and (int(len(self._subi)) > 0)):
      ( Utils.Tools._arraycopy__3IL_3ILL (self._subi,0l,subi_,0l,self._nnz) )
      ( Utils.Tools._arraycopy__3IL_3ILL (self._subj,0l,subj_,0l,self._nnz) )
      ( Utils.Tools._arraycopy__3FL_3FLL (self._val,0l,cof_,0l,self._nnz) )
  @staticmethod
  def _matchargs_getDataAsArray_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(779:15-784:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getDataAsArray()")
  def _getDataAsArray_(self):
    r = ([ 0.0 for _autovar_548 in xrange((self._dimi * self._dimj)) ])

    # src/fusion/Matrix.mbi(781:9-782:45)
    for i in xrange(0,int(len(self._subi))):
      r[((self._subi[i] * self._dimj) + self._subj[i])] = self._val[i]
    return r
  @staticmethod
  def _matchargs_isSparse_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(787:15-786:53)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("isSparse()")
  def _isSparse_(self):
    return True
  @staticmethod
  def _matchargs_transpose_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(790:15-793:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("transpose()")
  def _transpose_(self):
    return ( Matrix._sparse_II_3I_3I_3F (self._dimj,self._dimi,self._subj,self._subi,self._val) )
  @staticmethod
  def _matchargs_numNonzeros_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(797:15-799:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numNonzeros()")
  def _numNonzeros_(self):
    return self._nnz
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(802:15-813:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( ( ( ( ( sb._a_S("SparseMatrix(") )._a_I(self._dimi) )._a_S(",") )._a_I(self._dimj) )._a_S(", ") )
    if   (int(len(self._subi)) > 0):
      ( ( ( ( ( ( ( sb._a_S("(") )._a_I(self._subi[0]) )._a_S(",") )._a_I(self._subj[0]) )._a_S(",") )._a_F(self._val[0]) )._a_S(")") )
      # src/fusion/Matrix.mbi(808:11-809:76)
      for i in xrange(1,int(len(self._subi))):
        ( ( ( ( ( ( ( sb._a_S(",(") )._a_I(self._subi[i]) )._a_S(",") )._a_I(self._subj[i]) )._a_S(",") )._a_F(self._val[i]) )._a_S(")") )
    ( sb._a_S(" )") )
    return ( sb._toString_() )
  @staticmethod
  def _matchargs_formPtrb_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(817:18-831:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("formPtrb()")
  def _formPtrb_(self):
    ptrb = ([ 0l for _autovar_549 in xrange((self._dimi + 1)) ])

    pos = 0l

    # src/fusion/Matrix.mbi(821:9-827:9)
    row = 0

    while (row < self._dimi):
      ptrb[row] = pos
      # src/fusion/Matrix.mbi(824:11-826:11)
      while ((pos < self._nnz) and (self._subi[pos] == row)):
        pass
        pos += 1
      row += 1
    ptrb[self._dimi] = pos
    return ptrb
  @_cliptrace
  def numRows(self,*args):
    if   Matrix._matchargs_numRows_(args):
      return Matrix._numRows_(self,*args)
    else:
      argtypestr = "numRows(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumRows()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def numColumns(self,*args):
    if   Matrix._matchargs_numColumns_(args):
      return Matrix._numColumns_(self,*args)
    else:
      argtypestr = "numColumns(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumColumns()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get(self,*args):
    if   SparseMatrix._matchargs_get_II(args):
      return SparseMatrix._get_II(self,*args)
    else:
      argtypestr = "get(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tget(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def diag(*args):
    if   Matrix._matchargs_diag_IOmosek_fusion_Matrix_2(args):
      return Matrix._diag_IOmosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_diag__3FI(args):
      return Matrix._diag__3FI(*args)
    elif Matrix._matchargs_diag__3F(args):
      return Matrix._diag__3F(*args)
    elif Matrix._matchargs_diag_IF(args):
      return Matrix._diag_IF(*args)
    elif Matrix._matchargs_diag__3Omosek_fusion_Matrix_2(args):
      return Matrix._diag__3Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_diag_IFI(args):
      return Matrix._diag_IFI(*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdiag(int,mosek.fusion.Matrix)"),(2,"\tdiag([float],int)"),(1,"\tdiag([float])"),(2,"\tdiag(int,float)"),(1,"\tdiag([mosek.fusion.Matrix])"),(3,"\tdiag(int,float,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   SparseMatrix._matchargs_transpose_(args):
      return SparseMatrix._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getDataAsArray(self,*args):
    if   SparseMatrix._matchargs_getDataAsArray_(args):
      return SparseMatrix._getDataAsArray_(self,*args)
    else:
      argtypestr = "getDataAsArray(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetDataAsArray()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def isSparse(self,*args):
    if   SparseMatrix._matchargs_isSparse_(args):
      return SparseMatrix._isSparse_(self,*args)
    else:
      argtypestr = "isSparse(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tisSparse()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   SparseMatrix._matchargs_toString_(args):
      return SparseMatrix._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def antidiag(*args):
    if   Matrix._matchargs_antidiag_IFI(args):
      return Matrix._antidiag_IFI(*args)
    elif Matrix._matchargs_antidiag_IF(args):
      return Matrix._antidiag_IF(*args)
    elif Matrix._matchargs_antidiag__3F(args):
      return Matrix._antidiag__3F(*args)
    elif Matrix._matchargs_antidiag__3FI(args):
      return Matrix._antidiag__3FI(*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tantidiag(int,float,int)"),(2,"\tantidiag(int,float)"),(1,"\tantidiag([float])"),(2,"\tantidiag([float],int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def sparse(*args):
    if   Matrix._matchargs_sparse__3_3Omosek_fusion_Matrix_2(args):
      return Matrix._sparse__3_3Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_sparse_II(args):
      return Matrix._sparse_II(*args)
    elif Matrix._matchargs_sparse_Omosek_fusion_Matrix_2(args):
      return Matrix._sparse_Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_sparse__3_3F(args):
      return Matrix._sparse__3_3F(*args)
    elif Matrix._matchargs_sparse__3I_3IF(args):
      return Matrix._sparse__3I_3IF(*args)
    elif Matrix._matchargs_sparse_II_3I_3I_3F(args):
      return Matrix._sparse_II_3I_3I_3F(*args)
    elif Matrix._matchargs_sparse_II_3I_3IF(args):
      return Matrix._sparse_II_3I_3IF(*args)
    elif Matrix._matchargs_sparse__3I_3I_3F(args):
      return Matrix._sparse__3I_3I_3F(*args)
    else:
      argtypestr = "sparse(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsparse([[mosek.fusion.Matrix]])"),(2,"\tsparse(int,int)"),(1,"\tsparse(mosek.fusion.Matrix)"),(1,"\tsparse([[float]])"),(3,"\tsparse([int],[int],float)"),(5,"\tsparse(int,int,[int],[int],[float])"),(5,"\tsparse(int,int,[int],[int],float)"),(3,"\tsparse([int],[int],[float])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getDataAsTriplets(self,*args):
    if   SparseMatrix._matchargs_getDataAsTriplets__3I_3I_3F(args):
      return SparseMatrix._getDataAsTriplets__3I_3I_3F(self,*args)
    else:
      argtypestr = "getDataAsTriplets(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tgetDataAsTriplets([int],[int],[float])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def numNonzeros(self,*args):
    if   SparseMatrix._matchargs_numNonzeros_(args):
      return SparseMatrix._numNonzeros_(self,*args)
    else:
      argtypestr = "numNonzeros(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumNonzeros()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Matrix.mbi(837:5-1010:5)
class DenseMatrix(Matrix):
  @staticmethod
  def _matchargs_constructor_IIF(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],float): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int,float) @ src/fusion/Matrix.mbi(895:15-900:7)")
  def __constructor_IIF(self,dimi_,dimj_,value_):
    mosek.fusion.Matrix._Matrix__constructor_II(self,dimi_,dimj_)
    self._data = ([ 0.0 for _autovar_550 in xrange((dimi_ * dimj_)) ])
    # src/fusion/Matrix.mbi(898:9-54)
    for i in xrange(0,(dimi_ * dimj_)):
      self._data[i] = value_
    self._nnz = long((dimi_ * dimj_))
  @staticmethod
  def _matchargs_constructor__3_3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([[float]]) @ src/fusion/Matrix.mbi(907:15-918:7)")
  def __constructor__3_3F(self,d):
    mosek.fusion.Matrix._Matrix__constructor_II(self,int(len(d)),int(len(d[0])))
    self._data = ([ 0.0 for _autovar_551 in xrange((self._dimi * self._dimj)) ])
    k = 0

    # src/fusion/Matrix.mbi(912:9-916:9)
    i = 0

    while (i < int(len(d))):
      ( Utils.Tools._arraycopy__3FI_3FII (d[i],0,self._data,k,self._dimj) )
      k = (k + self._dimj)
      i += 1
    self._nnz = long((self._dimi * self._dimj))
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Matrix) @ src/fusion/Matrix.mbi(925:15-946:7)")
  def __constructor_Omosek_fusion_Matrix_2(self,m_):
    mosek.fusion.Matrix._Matrix__constructor_II(self,m_._dimi,m_._dimj)
    _autovar_552 = m_
    if   isinstance(_autovar_552,mosek.fusion.DenseMatrix):
      m = _autovar_552
      self._data = ( Utils.Tools._arraycopy__3F (m._data) )
    elif isinstance(_autovar_552,mosek.fusion.SparseMatrix):
      m = _autovar_552
      self._data = ( Utils.Tools._zeros_I ((m._dimi * m._dimj)) )
      # src/fusion/Matrix.mbi(936:11-939:11)
      for i in xrange(0l,m._nnz):
        # { @ src/fusion/Matrix.mbi(937:11-939:11)
        self._data[((m._subi[i] * self._dimj) + m._subj[i])] = m._val[i]
        # } @ src/fusion/Matrix.mbi(937:11-939:11)
    else:
      m = _autovar_552
      raise mosek.fusion.MatrixError("Unknown matrix type.")
    self._nnz = long((self._dimi * self._dimj))
  @staticmethod
  def _matchargs_constructor_II_3F(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int,[float]) @ src/fusion/Matrix.mbi(959:15-967:7)")
  def __constructor_II_3F(self,dimi_,dimj_,cof):
    mosek.fusion.Matrix._Matrix__constructor_II(self,dimi_,dimj_)
    self._nnz = long((dimi_ * dimj_))
    self._data = ([ 0.0 for _autovar_553 in xrange((dimi_ * dimj_)) ])
    ( Utils.Tools._arraycopy__3FI_3FII (cof,0,self._data,0,(dimi_ * dimj_)) )
  def __init__(self,*args):
    #self._protected_data = None

    #self._protected_nnz = None

    if   self._matchargs_constructor_IIF(args):
      self.__constructor_IIF(*args)
    elif self._matchargs_constructor__3_3F(args):
      self.__constructor__3_3F(*args)
    elif self._matchargs_constructor_Omosek_fusion_Matrix_2(args):
      self.__constructor_Omosek_fusion_Matrix_2(*args)
    elif self._matchargs_constructor_II_3F(args):
      self.__constructor_II_3F(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_numNonzeros_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(848:15-850:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numNonzeros()")
  def _numNonzeros_(self):
    return long((self._dimi * self._dimj))
  @staticmethod
  def _matchargs_get_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Matrix.mbi(853:15-852:82)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get(int,int)")
  def _get_II(self,i,j):
    return self._data[((i * self._dimi) + j)]
  @staticmethod
  def _matchargs_getDataAsTriplets__3I_3I_3F(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/Matrix.mbi(856:15-878:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getDataAsTriplets([int],[int],[float])")
  def _getDataAsTriplets__3I_3I_3F(self,subi,subj,cof):
    if   (((int(len(subi)) < self._nnz) or (int(len(subj)) < self._nnz)) or (int(len(cof)) < self._nnz)):
      raise mosek.fusion.LengthError("Output arrays are not long enough.")
    ( Utils.Tools._arraycopy__3FI_3FII (self._data,0,cof,0,int(len(self._data))) )
    k = 0

    # src/fusion/Matrix.mbi(869:9-877:9)
    for i in xrange(0,self._dimi):
      # { @ src/fusion/Matrix.mbi(870:9-877:9)
      # src/fusion/Matrix.mbi(871:11-876:11)
      for j in xrange(0,self._dimj):
        # { @ src/fusion/Matrix.mbi(872:11-876:11)
        subi[k] = i
        subj[k] = j
        k += 1
        # } @ src/fusion/Matrix.mbi(872:11-876:11)
      # } @ src/fusion/Matrix.mbi(870:9-877:9)
  @staticmethod
  def _matchargs_getDataAsArray_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(881:15-883:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getDataAsArray()")
  def _getDataAsArray_(self):
    return ( Utils.Tools._arraycopy__3F (self._data) )
  @staticmethod
  def _matchargs_isSparse_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(886:15-885:54)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("isSparse()")
  def _isSparse_(self):
    return False
  @staticmethod
  def _matchargs_transpose_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(971:15-989:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("transpose()")
  def _transpose_(self):
    newdata = ([ 0.0 for _autovar_554 in xrange((self._dimi * self._dimj)) ])

    srci = 0

    step = self._dimi

    # src/fusion/Matrix.mbi(977:9-987:9)
    for i in xrange(0,self._dimi):
      # { @ src/fusion/Matrix.mbi(978:9-987:9)
      dsti = i

      # src/fusion/Matrix.mbi(980:11-986:11)
      for j in xrange(0,self._dimj):
        # { @ src/fusion/Matrix.mbi(981:11-986:11)
        newdata[dsti] = self._data[srci]
        dsti = (dsti + step)
        srci += 1
        # } @ src/fusion/Matrix.mbi(981:11-986:11)
      # } @ src/fusion/Matrix.mbi(978:9-987:9)
    return mosek.fusion.DenseMatrix(self._dimj,self._dimi,newdata)
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Matrix.mbi(992:15-1009:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( sb._a_S("DenseMatrix(") )
    ( sb._a_I(self._dimi) )
    ( sb._a_S(",") )
    ( sb._a_I(self._dimj) )
    ( sb._a_S(": ") )
    k = 0

    # src/fusion/Matrix.mbi(996:9-1006:9)
    i = 0

    while (i < self._dimi):
      if   (i > 0):
        ( sb._a_S(",") )
      ( sb._a_S("[ ") )
      ( sb._a_F(self._data[k]) )
      k += 1
      # src/fusion/Matrix.mbi(1000:11-1004:11)
      j = 1

      while (j < self._dimj):
        ( sb._a_S(",") )
        ( sb._a_F(self._data[k]) )
        k += 1
        j += 1
      ( sb._a_S(" ]") )
      i += 1
    ( sb._a_S(")") )
    return ( sb._toString_() )
  @_cliptrace
  def numRows(self,*args):
    if   Matrix._matchargs_numRows_(args):
      return Matrix._numRows_(self,*args)
    else:
      argtypestr = "numRows(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumRows()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def numColumns(self,*args):
    if   Matrix._matchargs_numColumns_(args):
      return Matrix._numColumns_(self,*args)
    else:
      argtypestr = "numColumns(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumColumns()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get(self,*args):
    if   DenseMatrix._matchargs_get_II(args):
      return DenseMatrix._get_II(self,*args)
    else:
      argtypestr = "get(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tget(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def diag(*args):
    if   Matrix._matchargs_diag_IOmosek_fusion_Matrix_2(args):
      return Matrix._diag_IOmosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_diag__3FI(args):
      return Matrix._diag__3FI(*args)
    elif Matrix._matchargs_diag__3F(args):
      return Matrix._diag__3F(*args)
    elif Matrix._matchargs_diag_IF(args):
      return Matrix._diag_IF(*args)
    elif Matrix._matchargs_diag__3Omosek_fusion_Matrix_2(args):
      return Matrix._diag__3Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_diag_IFI(args):
      return Matrix._diag_IFI(*args)
    else:
      argtypestr = "diag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tdiag(int,mosek.fusion.Matrix)"),(2,"\tdiag([float],int)"),(1,"\tdiag([float])"),(2,"\tdiag(int,float)"),(1,"\tdiag([mosek.fusion.Matrix])"),(3,"\tdiag(int,float,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def transpose(self,*args):
    if   DenseMatrix._matchargs_transpose_(args):
      return DenseMatrix._transpose_(self,*args)
    else:
      argtypestr = "transpose(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttranspose()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getDataAsArray(self,*args):
    if   DenseMatrix._matchargs_getDataAsArray_(args):
      return DenseMatrix._getDataAsArray_(self,*args)
    else:
      argtypestr = "getDataAsArray(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetDataAsArray()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def isSparse(self,*args):
    if   DenseMatrix._matchargs_isSparse_(args):
      return DenseMatrix._isSparse_(self,*args)
    else:
      argtypestr = "isSparse(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tisSparse()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def toString(self,*args):
    if   DenseMatrix._matchargs_toString_(args):
      return DenseMatrix._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def antidiag(*args):
    if   Matrix._matchargs_antidiag_IFI(args):
      return Matrix._antidiag_IFI(*args)
    elif Matrix._matchargs_antidiag_IF(args):
      return Matrix._antidiag_IF(*args)
    elif Matrix._matchargs_antidiag__3F(args):
      return Matrix._antidiag__3F(*args)
    elif Matrix._matchargs_antidiag__3FI(args):
      return Matrix._antidiag__3FI(*args)
    else:
      argtypestr = "antidiag(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tantidiag(int,float,int)"),(2,"\tantidiag(int,float)"),(1,"\tantidiag([float])"),(2,"\tantidiag([float],int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def sparse(*args):
    if   Matrix._matchargs_sparse__3_3Omosek_fusion_Matrix_2(args):
      return Matrix._sparse__3_3Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_sparse_II(args):
      return Matrix._sparse_II(*args)
    elif Matrix._matchargs_sparse_Omosek_fusion_Matrix_2(args):
      return Matrix._sparse_Omosek_fusion_Matrix_2(*args)
    elif Matrix._matchargs_sparse__3_3F(args):
      return Matrix._sparse__3_3F(*args)
    elif Matrix._matchargs_sparse__3I_3IF(args):
      return Matrix._sparse__3I_3IF(*args)
    elif Matrix._matchargs_sparse_II_3I_3I_3F(args):
      return Matrix._sparse_II_3I_3I_3F(*args)
    elif Matrix._matchargs_sparse_II_3I_3IF(args):
      return Matrix._sparse_II_3I_3IF(*args)
    elif Matrix._matchargs_sparse__3I_3I_3F(args):
      return Matrix._sparse__3I_3I_3F(*args)
    else:
      argtypestr = "sparse(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsparse([[mosek.fusion.Matrix]])"),(2,"\tsparse(int,int)"),(1,"\tsparse(mosek.fusion.Matrix)"),(1,"\tsparse([[float]])"),(3,"\tsparse([int],[int],float)"),(5,"\tsparse(int,int,[int],[int],[float])"),(5,"\tsparse(int,int,[int],[int],float)"),(3,"\tsparse([int],[int],[float])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getDataAsTriplets(self,*args):
    if   DenseMatrix._matchargs_getDataAsTriplets__3I_3I_3F(args):
      return DenseMatrix._getDataAsTriplets__3I_3I_3F(self,*args)
    else:
      argtypestr = "getDataAsTriplets(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tgetDataAsTriplets([int],[int],[float])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def numNonzeros(self,*args):
    if   DenseMatrix._matchargs_numNonzeros_(args):
      return DenseMatrix._numNonzeros_(self,*args)
    else:
      argtypestr = "numNonzeros(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumNonzeros()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/CommonUtil.mbi(599:5-652:5)
class IndexCounter:
  @staticmethod
  def _matchargs_constructor_L_3I_3L(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],long): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(long,[int],[long]) @ src/fusion/CommonUtil.mbi(610:15-620:7)")
  def __constructor_L_3I_3L(self,start,dims_,strides_):
    self.__n = int(len(dims_))
    self.__ii = ([ 0 for _autovar_555 in xrange(self.__n) ])
    self.__st = ([ 0l for _autovar_556 in xrange(self.__n) ])
    # src/fusion/CommonUtil.mbi(616:22-55)
    for i in xrange(0,self.__n):
      self.__st[i] = start
    self.__strides = strides_
    self.__dims = dims_
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Set_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Set) @ src/fusion/CommonUtil.mbi(623:15-631:7)")
  def __constructor_Omosek_fusion_Set_2(self,shape):
    self.__n = shape.nd
    self.__ii = ([ 0 for _autovar_557 in xrange(self.__n) ])
    self.__st = ([ 0l for _autovar_558 in xrange(self.__n) ])
    self.__strides = ([ 0l for _autovar_559 in xrange(self.__n) ])
    # src/fusion/CommonUtil.mbi(629:27-74)
    for i in xrange(0,self.__n):
      self.__strides[i] = ( shape._stride_I(i) )
    self.__dims = ([ 0 for _autovar_560 in xrange(self.__n) ])
    # src/fusion/CommonUtil.mbi(630:27-71)
    for i in xrange(0,self.__n):
      self.__dims[i] = ( shape._dim_I(i) )
  def __init__(self,*args):
    #self.__n = None

    #self.__ii = None

    #self.__st = None

    #self.__strides = None

    #self.__dims = None

    if   self._matchargs_constructor_L_3I_3L(args):
      self.__constructor_L_3I_3L(*args)
    elif self._matchargs_constructor_Omosek_fusion_Set_2(args):
      self.__constructor_Omosek_fusion_Set_2(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_inc_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/CommonUtil.mbi(635:15-646:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("inc()")
  def _inc_(self):
    self.__ii[0] += 1
    self.__st[0] = (self.__st[0] + self.__strides[(self.__n - 1)])

    # src/fusion/CommonUtil.mbi(638:9-643:9)
    i = 0
    while ((i < (self.__n - 1)) and (self.__ii[i] == self.__dims[((self.__n - i) - 1)])):
      self.__ii[i] = 0
      self.__ii[(i + 1)] += 1
      self.__st[(i + 1)] = (self.__st[(i + 1)] + self.__strides[((self.__n - i) - 2)])
      i += 1
    # src/fusion/CommonUtil.mbi(645:9-41)
    for j in xrange(0,i):
      self.__st[j] = self.__st[i]
  @staticmethod
  def _matchargs_get_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/CommonUtil.mbi(649:15-648:49)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("get()")
  def _get_(self):
    return self.__st[0]
  @staticmethod
  def _matchargs_getIndex_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/CommonUtil.mbi(650:15-649:54)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getIndex()")
  def _getIndex_(self):
    return self.__ii
  @staticmethod
  def _matchargs_atEnd_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/CommonUtil.mbi(652:15-651:66)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("atEnd()")
  def _atEnd_(self):
    return (self.__ii[(self.__n - 1)] >= self.__dims[(self.__n - 1)])
  @_cliptrace
  def getIndex(self,*args):
    if   IndexCounter._matchargs_getIndex_(args):
      return IndexCounter._getIndex_(self,*args)
    else:
      argtypestr = "getIndex(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetIndex()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def get(self,*args):
    if   IndexCounter._matchargs_get_(args):
      return IndexCounter._get_(self,*args)
    else:
      argtypestr = "get(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tget()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def atEnd(self,*args):
    if   IndexCounter._matchargs_atEnd_(args):
      return IndexCounter._atEnd_(self,*args)
    else:
      argtypestr = "atEnd(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tatEnd()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def inc(self,*args):
    if   IndexCounter._matchargs_inc_(args):
      return IndexCounter._inc_(self,*args)
    else:
      argtypestr = "inc(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tinc()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/domain.mbi(52:5-672:5)
class Domain:
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_RelationKey_2I(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.RelationKey): return False
    if not isinstance(args[1],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.RelationKey,int) @ src/fusion/domain.mbi(87:16-101:7)")
  def __constructor_Omosek_fusion_RelationKey_2I(self,key_,size_):
    self._key = key_
    if   (size_ == 0):
      self._shape = None
    else:
      self._shape = mosek.fusion.IntSet(size_)
    self.__idxmap = None
    self.__bnd = None
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_RelationKey_2II(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],mosek.fusion.RelationKey): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.RelationKey,int,int) @ src/fusion/domain.mbi(105:16-115:7)")
  def __constructor_Omosek_fusion_RelationKey_2II(self,key_,m,n):
    self._key = key_
    self._shape = mosek.fusion.NDSet(m,n)
    self.__idxmap = None
    self.__bnd = None
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_RelationKey_2_3FB(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],mosek.fusion.RelationKey): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],bool): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.RelationKey,[float],bool) @ src/fusion/domain.mbi(119:16-142:7)")
  def __constructor_Omosek_fusion_RelationKey_2_3FB(self,key_,bnd_,scalable):
    self.__idxmap = None
    self._key = key_
    if   (bnd_ != None):
      if   (int(len(bnd_)) > 1):
        self._shape = mosek.fusion.IntSet(int(len(bnd_)))
      else:
        self._shape = None
    else:
      self._shape = None
    self.__bnd = bnd_
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_RelationKey_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.RelationKey): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.RelationKey,mosek.fusion.Matrix) @ src/fusion/domain.mbi(145:16-175:7)")
  def __constructor_Omosek_fusion_RelationKey_2Omosek_fusion_Matrix_2(self,key_,bnd_):
    self._key = key_
    self._shape = mosek.fusion.NDSet(bnd_._dimi,bnd_._dimj)
    self.__idxmap = None
    _autovar_561 = bnd_
    if   isinstance(_autovar_561,mosek.fusion.DenseMatrix):
      m = _autovar_561
      self.__bnd = m._data
    elif isinstance(_autovar_561,mosek.fusion.SparseMatrix):
      m = _autovar_561
      if   (m._val == None):
        self.__bnd = ([ 0.0 for _autovar_562 in xrange(0) ])
      else:
        self.__bnd = m._val
      self.__idxmap = mosek.fusion.Utils.IntMap()
      # src/fusion/domain.mbi(165:11-168:11)
      i = 0

      while (i < int(len(self.__bnd))):
        ( self.__idxmap._setItem_LI(( self._shape._linearidx_II(m._subi[i],m._subj[i]) ),i) )
        i += 1
    else:
      m = _autovar_561
      raise mosek.fusion.UnimplementedError("Unknown matrix type.")
  def __init__(self,*args):
    #self._protected_shape = None

    #self.__idxmap = None

    #self.__bnd = None

    #self._protected_key = None

    if   self._matchargs_constructor_Omosek_fusion_RelationKey_2I(args):
      self.__constructor_Omosek_fusion_RelationKey_2I(*args)
    elif self._matchargs_constructor_Omosek_fusion_RelationKey_2II(args):
      self.__constructor_Omosek_fusion_RelationKey_2II(*args)
    elif self._matchargs_constructor_Omosek_fusion_RelationKey_2_3FB(args):
      self.__constructor_Omosek_fusion_RelationKey_2_3FB(*args)
    elif self._matchargs_constructor_Omosek_fusion_RelationKey_2Omosek_fusion_Matrix_2(args):
      self.__constructor_Omosek_fusion_RelationKey_2Omosek_fusion_Matrix_2(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_get_1rhs_1item_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/domain.mbi(178:18-181:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get_rhs_item(int)")
  def _get_1rhs_1item_I(self,index):
    return ( self._get_1rhs_1item_L(long(index)) )
  @staticmethod
  def _matchargs_get_1rhs_1item_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/domain.mbi(184:18-212:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get_rhs_item(long)")
  def _get_1rhs_1item_L(self,index):
    if   (self.__idxmap != None):
      if   ( self.__idxmap._hasItem_L(index) ):
        return self.__bnd[( self.__idxmap._getItem_L(index) )]
      else:
        return 0.0
    else:
      if   ((self._shape == None) and (self.__bnd != None)):
        return self.__bnd[0]
      elif (self.__bnd != None):
        return self.__bnd[index]
      else:
        return 0.0
  @staticmethod
  def _matchargs_match_1shape_Omosek_fusion_Set_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/domain.mbi(215:18-225:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("match_shape(mosek.fusion.Set)")
  def _match_1shape_Omosek_fusion_Set_2(self,shp):
    if   (self._shape == None):
      return True
    else:
      return ( self._shape._compare_Omosek_fusion_Set_2(shp) )
  @staticmethod
  def _matchargs_unbounded_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/domain.mbi(232:15-234:7)
  @staticmethod
  #@Utils.methodargs() 
  #@Utils.demanglefuncname("unbounded()")
  def _unbounded_():
    return mosek.fusion.Domain(RelationKey.IsFree,None,True)
  @staticmethod
  def _matchargs_equalsTo_F(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],float): return False
    return True
  # origin: src/fusion/domain.mbi(243:15-245:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("equalsTo(float)")
  def _equalsTo_F(b):
    return mosek.fusion.Domain(RelationKey.EqualsTo,([ b]),True)
  @staticmethod
  def _matchargs_equalsTo__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/domain.mbi(252:15-254:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("equalsTo([float])")
  def _equalsTo__3F(bnd):
    return mosek.fusion.Domain(RelationKey.EqualsTo,bnd,False)
  @staticmethod
  def _matchargs_equalsTo_Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/domain.mbi(261:15-263:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("equalsTo(mosek.fusion.Matrix)")
  def _equalsTo_Omosek_fusion_Matrix_2(bnd):
    return mosek.fusion.Domain(RelationKey.EqualsTo,bnd)
  @staticmethod
  def _matchargs_lessThan_F(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],float): return False
    return True
  # origin: src/fusion/domain.mbi(271:15-273:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("lessThan(float)")
  def _lessThan_F(b):
    return mosek.fusion.Domain(RelationKey.LessThan,([ b]),True)
  @staticmethod
  def _matchargs_lessThan__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/domain.mbi(280:15-282:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("lessThan([float])")
  def _lessThan__3F(bnd):
    return mosek.fusion.Domain(RelationKey.LessThan,bnd,False)
  @staticmethod
  def _matchargs_lessThan_Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/domain.mbi(288:15-290:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("lessThan(mosek.fusion.Matrix)")
  def _lessThan_Omosek_fusion_Matrix_2(bnd):
    return mosek.fusion.Domain(RelationKey.LessThan,bnd)
  @staticmethod
  def _matchargs_greaterThan_F(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],float): return False
    return True
  # origin: src/fusion/domain.mbi(298:15-300:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("greaterThan(float)")
  def _greaterThan_F(b):
    return mosek.fusion.Domain(RelationKey.GreaterThan,([ b]),True)
  @staticmethod
  def _matchargs_greaterThan__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/domain.mbi(307:15-309:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("greaterThan([float])")
  def _greaterThan__3F(bnd):
    return mosek.fusion.Domain(RelationKey.GreaterThan,bnd,False)
  @staticmethod
  def _matchargs_greaterThan_Omosek_fusion_Matrix_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/domain.mbi(316:15-318:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("greaterThan(mosek.fusion.Matrix)")
  def _greaterThan_Omosek_fusion_Matrix_2(bnd):
    return mosek.fusion.Domain(RelationKey.GreaterThan,bnd)
  @staticmethod
  def _matchargs_inPSDCone_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/domain.mbi(333:15-335:7)
  @staticmethod
  #@Utils.methodargs() 
  #@Utils.demanglefuncname("inPSDCone()")
  def _inPSDCone_():
    return mosek.fusion.PSDDomain(PSDKey.IsSymPSD,None)
  @staticmethod
  def _matchargs_inPSDCone_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/domain.mbi(347:15-349:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("inPSDCone(int)")
  def _inPSDCone_I(n):
    return mosek.fusion.PSDDomain(PSDKey.IsSymPSD,mosek.fusion.NDSet(n,n,1))
  @staticmethod
  def _matchargs_inPSDCone_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/domain.mbi(361:15-363:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inPSDCone(int,int)")
  def _inPSDCone_II(n,m):
    return mosek.fusion.PSDDomain(PSDKey.IsSymPSD,mosek.fusion.NDSet(n,n,m))
  @staticmethod
  def _matchargs_isTrilPSD_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/domain.mbi(377:15-379:7)
  @staticmethod
  #@Utils.methodargs() 
  #@Utils.demanglefuncname("isTrilPSD()")
  def _isTrilPSD_():
    return mosek.fusion.PSDDomain(PSDKey.IsTrilPSD,None)
  @staticmethod
  def _matchargs_isTrilPSD_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/domain.mbi(393:15-395:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("isTrilPSD(int)")
  def _isTrilPSD_I(n):
    return mosek.fusion.PSDDomain(PSDKey.IsTrilPSD,mosek.fusion.NDSet(n,n,1))
  @staticmethod
  def _matchargs_isTrilPSD_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/domain.mbi(409:15-411:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("isTrilPSD(int,int)")
  def _isTrilPSD_II(n,m):
    return mosek.fusion.PSDDomain(PSDKey.IsTrilPSD,mosek.fusion.NDSet(n,n,m))
  @staticmethod
  def _matchargs_isLinPSD_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/domain.mbi(414:15-416:7)
  @staticmethod
  #@Utils.methodargs() 
  #@Utils.demanglefuncname("isLinPSD()")
  def _isLinPSD_():
    return mosek.fusion.PSDDomain(PSDKey.IsTrilPSD,None)
  @staticmethod
  def _matchargs_isLinPSD_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/domain.mbi(419:15-421:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("isLinPSD(int)")
  def _isLinPSD_I(n):
    return mosek.fusion.PSDDomain(PSDKey.IsTrilPSD,mosek.fusion.IntSet(((n * (n + 1)) / 2)))
  @staticmethod
  def _matchargs_isLinPSD_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/domain.mbi(424:15-426:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("isLinPSD(int,int)")
  def _isLinPSD_II(n,m):
    return mosek.fusion.PSDDomain(PSDKey.IsTrilPSD,mosek.fusion.NDSet(((n * (n + 1)) / 2),m))
  @staticmethod
  def _matchargs_inQCone_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/domain.mbi(433:15-435:7)
  @staticmethod
  #@Utils.methodargs() 
  #@Utils.demanglefuncname("inQCone()")
  def _inQCone_():
    return mosek.fusion.Domain(RelationKey.InQCone,0)
  @staticmethod
  def _matchargs_inQCone_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/domain.mbi(440:15-442:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("inQCone(int)")
  def _inQCone_I(size):
    return mosek.fusion.Domain(RelationKey.InQCone,size)
  @staticmethod
  def _matchargs_inQCone_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/domain.mbi(455:15-457:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inQCone(int,int)")
  def _inQCone_II(m,n):
    return mosek.fusion.Domain(RelationKey.InQCone,m,n)
  @staticmethod
  def _matchargs_inRotatedQCone_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/domain.mbi(463:15-465:7)
  @staticmethod
  #@Utils.methodargs() 
  #@Utils.demanglefuncname("inRotatedQCone()")
  def _inRotatedQCone_():
    return mosek.fusion.Domain(RelationKey.InRotatedQCone,0)
  @staticmethod
  def _matchargs_inRotatedQCone_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/domain.mbi(470:15-472:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("inRotatedQCone(int)")
  def _inRotatedQCone_I(size):
    return mosek.fusion.Domain(RelationKey.InRotatedQCone,size)
  @staticmethod
  def _matchargs_inRotatedQCone_II(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/domain.mbi(483:15-485:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRotatedQCone(int,int)")
  def _inRotatedQCone_II(m,n):
    return mosek.fusion.Domain(RelationKey.InRotatedQCone,m,n)
  @staticmethod
  def _matchargs_inRange_FF(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/domain.mbi(494:15-500:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange(float,float)")
  def _inRange_FF(lb,ub):
    if   (lb > ub):
      raise mosek.fusion.DomainError("Invalid range specified")
    return mosek.fusion.RangeDomain(( Utils.Tools._makevector_FI (lb,1) ),( Utils.Tools._makevector_FI (ub,1) ),True)
  @staticmethod
  def _matchargs_inRange_F_3F(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/domain.mbi(511:15-518:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange(float,[float])")
  def _inRange_F_3F(lb,ub):
    # src/fusion/domain.mbi(512:9-516:17)
    for i in xrange(0,int(len(ub))):
      if   (lb > ub[i]):
        raise mosek.fusion.DomainError("Invalid range specified")
    return mosek.fusion.RangeDomain(( Utils.Tools._makevector_FI (lb,int(len(ub))) ),( Utils.Tools._arraycopy__3F (ub) ),False)
  @staticmethod
  def _matchargs_inRange__3FF(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/domain.mbi(529:15-538:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange([float],float)")
  def _inRange__3FF(lb,ub):
    # src/fusion/domain.mbi(530:9-534:9)
    for i in xrange(0,int(len(lb))):
      # { @ src/fusion/domain.mbi(531:9-534:9)
      if   (lb[i] > ub):
        raise mosek.fusion.DomainError("Invalid range specified")
      # } @ src/fusion/domain.mbi(531:9-534:9)
    return mosek.fusion.RangeDomain(( Utils.Tools._arraycopy__3F (lb) ),( Utils.Tools._makevector_FI (ub,int(len(lb))) ),False)
  @staticmethod
  def _matchargs_inRange__3F_3F(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/domain.mbi(548:15-560:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange([float],[float])")
  def _inRange__3F_3F(lb,ub):
    if   (int(len(lb)) != int(len(ub))):
      raise mosek.fusion.LengthError("Mismatching lengths of upper and lower bounds.")
    # src/fusion/domain.mbi(553:9-558:17)
    for i in xrange(0,int(len(ub))):
      if   (lb[i] > ub[i]):
        raise mosek.fusion.DomainError("Invalid range specified")
    return mosek.fusion.RangeDomain(( Utils.Tools._arraycopy__3F (lb) ),( Utils.Tools._arraycopy__3F (ub) ),False)
  @staticmethod
  def _matchargs_inRange_FOmosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/domain.mbi(571:15-583:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange(float,mosek.fusion.Matrix)")
  def _inRange_FOmosek_fusion_Matrix_2(lb,ub):
    subi = ([ 0 for _autovar_563 in xrange(( ub._numNonzeros_() )) ])

    subj = ([ 0 for _autovar_564 in xrange(( ub._numNonzeros_() )) ])

    val = ([ 0.0 for _autovar_565 in xrange(( ub._numNonzeros_() )) ])

    ( ub._getDataAsTriplets__3I_3I_3F(subi,subj,val) )
    # src/fusion/domain.mbi(577:9-581:9)
    for i in xrange(0,int(len(val))):
      # { @ src/fusion/domain.mbi(578:9-581:9)
      if   (lb >= val[i]):
        raise mosek.fusion.DomainError("Invalid range specified")
      # } @ src/fusion/domain.mbi(578:9-581:9)
    return mosek.fusion.RangeDomain(lb,None,0.0,ub)
  @staticmethod
  def _matchargs_inRange_Omosek_fusion_Matrix_2F(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/domain.mbi(593:15-605:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange(mosek.fusion.Matrix,float)")
  def _inRange_Omosek_fusion_Matrix_2F(lb,ub):
    subi = ([ 0 for _autovar_566 in xrange(( lb._numNonzeros_() )) ])

    subj = ([ 0 for _autovar_567 in xrange(( lb._numNonzeros_() )) ])

    val = ([ 0.0 for _autovar_568 in xrange(( lb._numNonzeros_() )) ])

    ( lb._getDataAsTriplets__3I_3I_3F(subi,subj,val) )
    # src/fusion/domain.mbi(599:9-603:9)
    for i in xrange(0,int(len(val))):
      # { @ src/fusion/domain.mbi(600:9-603:9)
      if   (val[i] > ub):
        raise mosek.fusion.DomainError("Invalid range specified")
      # } @ src/fusion/domain.mbi(600:9-603:9)
    return mosek.fusion.RangeDomain(0.0,lb,ub,None)
  @staticmethod
  def _matchargs_inRange_Omosek_fusion_Matrix_2Omosek_fusion_Matrix_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Matrix): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    return True
  # origin: src/fusion/domain.mbi(615:15-622:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("inRange(mosek.fusion.Matrix,mosek.fusion.Matrix)")
  def _inRange_Omosek_fusion_Matrix_2Omosek_fusion_Matrix_2(lb,ub):
    if   ((lb._dimi != ub._dimi) or (lb._dimj != ub._dimj)):
      raise mosek.fusion.LengthError("Mismatching dimensions of upper and lower bounds.")
    return mosek.fusion.RangeDomain(0.0,lb,0.0,ub)
  @staticmethod
  def _matchargs_isInteger_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/domain.mbi(627:15-629:7)
  @staticmethod
  #@Utils.methodargs() 
  #@Utils.demanglefuncname("isInteger()")
  def _isInteger_():
    return mosek.fusion.IntegerDomain()
  @staticmethod
  def _matchargs_domainToString_LOmosek_fusion_Utils_StringBuffer_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],long): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Utils.StringBuffer): return False
    return True
  # origin: src/fusion/domain.mbi(632:18-671:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("domainToString(long,mosek.fusion.Utils.StringBuffer)")
  def _domainToString_LOmosek_fusion_Utils_StringBuffer_2(self,i,sb):
    if   (self._key == RelationKey.EqualsTo):
      ( ( sb._a_S(" = ") )._a_F(( self._get_1rhs_1item_L(i) )) )
    elif (self._key == RelationKey.LessThan):
      ( ( sb._a_S(" < ") )._a_F(( self._get_1rhs_1item_L(i) )) )
    elif (self._key == RelationKey.GreaterThan):
      ( ( sb._a_S(" > ") )._a_F(( self._get_1rhs_1item_L(i) )) )
    elif (self._key == RelationKey.IsFree):
      ( ( sb._a_S(" : unbounded") )._a_F(( self._get_1rhs_1item_L(i) )) )
    elif (self._key == RelationKey.InQCone):
      if   (self._shape != None):
        k = ( self._shape._idxtokey_L(i) )

        ( ( sb._a_S(" : element (") )._a_I(k[0]) )
        # src/fusion/domain.mbi(647:13-54)
        for j in xrange(1,int(len(k))):
          ( ( sb._a_S(",") )._a_I(k[j]) )
        ( ( sb._a_S(") in a quadratic cone of size (") )._a_I(( self._shape._dim_I(0) )) )
        # src/fusion/domain.mbi(649:13-62)
        for j in xrange(1,int(len(k))):
          ( ( sb._a_S(",") )._a_I(( self._shape._dim_I(j) )) )
        ( sb._a_S(")") )
      else:
        ( sb._a_S(" : part of a quadratic cone") )
    elif (self._key == RelationKey.InRotatedQCone):
      if   (self._shape != None):
        k = ( self._shape._idxtokey_L(i) )

        ( ( sb._a_S(" : element (") )._a_I(k[0]) )
        # src/fusion/domain.mbi(661:13-54)
        for j in xrange(1,int(len(k))):
          ( ( sb._a_S(",") )._a_I(k[j]) )
        ( ( sb._a_S(") in a rotated quadratic cone of size (") )._a_I(( self._shape._dim_I(0) )) )
        # src/fusion/domain.mbi(663:13-62)
        for j in xrange(1,int(len(k))):
          ( ( sb._a_S(",") )._a_I(( self._shape._dim_I(j) )) )
        ( sb._a_S(")") )
      else:
        ( sb._a_S(" : part of a rotated quadratic cone") )
    return ( sb._toString_() )
  @staticmethod
  @_cliptrace
  def isLinPSD(*args):
    if   Domain._matchargs_isLinPSD_I(args):
      return Domain._isLinPSD_I(*args)
    elif Domain._matchargs_isLinPSD_(args):
      return Domain._isLinPSD_(*args)
    elif Domain._matchargs_isLinPSD_II(args):
      return Domain._isLinPSD_II(*args)
    else:
      argtypestr = "isLinPSD(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tisLinPSD(int)"),(0,"\tisLinPSD()"),(2,"\tisLinPSD(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def unbounded(*args):
    if   Domain._matchargs_unbounded_(args):
      return Domain._unbounded_(*args)
    else:
      argtypestr = "unbounded(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tunbounded()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def inRotatedQCone(*args):
    if   Domain._matchargs_inRotatedQCone_(args):
      return Domain._inRotatedQCone_(*args)
    elif Domain._matchargs_inRotatedQCone_I(args):
      return Domain._inRotatedQCone_I(*args)
    elif Domain._matchargs_inRotatedQCone_II(args):
      return Domain._inRotatedQCone_II(*args)
    else:
      argtypestr = "inRotatedQCone(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tinRotatedQCone()"),(1,"\tinRotatedQCone(int)"),(2,"\tinRotatedQCone(int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def isTrilPSD(*args):
    if   Domain._matchargs_isTrilPSD_(args):
      return Domain._isTrilPSD_(*args)
    elif Domain._matchargs_isTrilPSD_II(args):
      return Domain._isTrilPSD_II(*args)
    elif Domain._matchargs_isTrilPSD_I(args):
      return Domain._isTrilPSD_I(*args)
    else:
      argtypestr = "isTrilPSD(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tisTrilPSD()"),(2,"\tisTrilPSD(int,int)"),(1,"\tisTrilPSD(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def lessThan(*args):
    if   Domain._matchargs_lessThan_F(args):
      return Domain._lessThan_F(*args)
    elif Domain._matchargs_lessThan__3F(args):
      return Domain._lessThan__3F(*args)
    elif Domain._matchargs_lessThan_Omosek_fusion_Matrix_2(args):
      return Domain._lessThan_Omosek_fusion_Matrix_2(*args)
    else:
      argtypestr = "lessThan(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tlessThan(float)"),(1,"\tlessThan([float])"),(1,"\tlessThan(mosek.fusion.Matrix)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def inQCone(*args):
    if   Domain._matchargs_inQCone_I(args):
      return Domain._inQCone_I(*args)
    elif Domain._matchargs_inQCone_II(args):
      return Domain._inQCone_II(*args)
    elif Domain._matchargs_inQCone_(args):
      return Domain._inQCone_(*args)
    else:
      argtypestr = "inQCone(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tinQCone(int)"),(2,"\tinQCone(int,int)"),(0,"\tinQCone()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def equalsTo(*args):
    if   Domain._matchargs_equalsTo_Omosek_fusion_Matrix_2(args):
      return Domain._equalsTo_Omosek_fusion_Matrix_2(*args)
    elif Domain._matchargs_equalsTo__3F(args):
      return Domain._equalsTo__3F(*args)
    elif Domain._matchargs_equalsTo_F(args):
      return Domain._equalsTo_F(*args)
    else:
      argtypestr = "equalsTo(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tequalsTo(mosek.fusion.Matrix)"),(1,"\tequalsTo([float])"),(1,"\tequalsTo(float)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def greaterThan(*args):
    if   Domain._matchargs_greaterThan_Omosek_fusion_Matrix_2(args):
      return Domain._greaterThan_Omosek_fusion_Matrix_2(*args)
    elif Domain._matchargs_greaterThan_F(args):
      return Domain._greaterThan_F(*args)
    elif Domain._matchargs_greaterThan__3F(args):
      return Domain._greaterThan__3F(*args)
    else:
      argtypestr = "greaterThan(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgreaterThan(mosek.fusion.Matrix)"),(1,"\tgreaterThan(float)"),(1,"\tgreaterThan([float])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def inRange(*args):
    if   Domain._matchargs_inRange__3FF(args):
      return Domain._inRange__3FF(*args)
    elif Domain._matchargs_inRange_FF(args):
      return Domain._inRange_FF(*args)
    elif Domain._matchargs_inRange_F_3F(args):
      return Domain._inRange_F_3F(*args)
    elif Domain._matchargs_inRange_Omosek_fusion_Matrix_2Omosek_fusion_Matrix_2(args):
      return Domain._inRange_Omosek_fusion_Matrix_2Omosek_fusion_Matrix_2(*args)
    elif Domain._matchargs_inRange__3F_3F(args):
      return Domain._inRange__3F_3F(*args)
    elif Domain._matchargs_inRange_Omosek_fusion_Matrix_2F(args):
      return Domain._inRange_Omosek_fusion_Matrix_2F(*args)
    elif Domain._matchargs_inRange_FOmosek_fusion_Matrix_2(args):
      return Domain._inRange_FOmosek_fusion_Matrix_2(*args)
    else:
      argtypestr = "inRange(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tinRange([float],float)"),(2,"\tinRange(float,float)"),(2,"\tinRange(float,[float])"),(2,"\tinRange(mosek.fusion.Matrix,mosek.fusion.Matrix)"),(2,"\tinRange([float],[float])"),(2,"\tinRange(mosek.fusion.Matrix,float)"),(2,"\tinRange(float,mosek.fusion.Matrix)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def inPSDCone(*args):
    if   Domain._matchargs_inPSDCone_(args):
      return Domain._inPSDCone_(*args)
    elif Domain._matchargs_inPSDCone_II(args):
      return Domain._inPSDCone_II(*args)
    elif Domain._matchargs_inPSDCone_I(args):
      return Domain._inPSDCone_I(*args)
    else:
      argtypestr = "inPSDCone(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tinPSDCone()"),(2,"\tinPSDCone(int,int)"),(1,"\tinPSDCone(int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def isInteger(*args):
    if   Domain._matchargs_isInteger_(args):
      return Domain._isInteger_(*args)
    else:
      argtypestr = "isInteger(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tisInteger()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Sort.mbi(6:5-320:5)
class Sort:
  def __init__(self,*args):
    pass
  @staticmethod
  def _matchargs_compareArg__3I_3ILL(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],long): return False
    return True
  # origin: src/fusion/Sort.mbi(9:15-20:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("compareArg([int],[int],long,long)")
  def _compareArg__3I_3ILL(val1,val2,lhsidx,rhsidx):
    if   (val1[lhsidx] < val1[rhsidx]):
      return (- 1)
    elif (val1[lhsidx] > val1[rhsidx]):
      return 1
    elif (val2[lhsidx] < val2[rhsidx]):
      return (- 1)
    elif (val2[lhsidx] > val2[rhsidx]):
      return 1
    else:
      return 0
  @staticmethod
  def _matchargs_argmerge__3LLLLL_3LL_3I_3I(args):
    if len(args) != 9:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],long): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[6],long): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Sort.mbi(43:16-76:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argmerge([long],long,long,long,long,[long],long,[int],[int])")
  def __argmerge__3LLLLL_3LL_3I_3I(perm_src,src_base1,num1,src_base2,num2,perm_tgt,tgt_base,val1,val2):
    it = tgt_base

    is1 = 0l

    is2 = 0l

    # src/fusion/Sort.mbi(55:9-66:9)
    while ((is1 < num1) and (is2 < num2)):
      if   (( Sort._compareArg__3I_3ILL (val1,val2,perm_src[(is1 + src_base1)],perm_src[(is2 + src_base2)]) ) <= 0):
        perm_tgt[it] = perm_src[(is1 + src_base1)]
        is1 += 1
      else:
        perm_tgt[it] = perm_src[(is2 + src_base2)]
        is2 += 1
      it += 1
    # src/fusion/Sort.mbi(68:9-71:9)
    while (is1 < num1):
      perm_tgt[it] = perm_src[(is1 + src_base1)]
      is1 += 1
      it += 1
    # src/fusion/Sort.mbi(72:9-75:9)
    while (is2 < num2):
      perm_tgt[it] = perm_src[(is2 + src_base2)]
      is2 += 1
      it += 1
  @staticmethod
  def _matchargs_argmerge__3LLLLL_3LL_3I(args):
    if len(args) != 8:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],long): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[6],long): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Sort.mbi(79:16-111:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argmerge([long],long,long,long,long,[long],long,[int])")
  def __argmerge__3LLLLL_3LL_3I(perm_src,src_base1,num1,src_base2,num2,perm_tgt,tgt_base,val):
    it = tgt_base

    is1 = 0l

    is2 = 0l

    # src/fusion/Sort.mbi(90:9-101:9)
    while ((is1 < num1) and (is2 < num2)):
      if   (val[perm_src[(src_base1 + is1)]] <= val[perm_src[(src_base2 + is2)]]):
        perm_tgt[it] = perm_src[(is1 + src_base1)]
        is1 += 1
      else:
        perm_tgt[it] = perm_src[(is2 + src_base2)]
        is2 += 1
      it += 1
    # src/fusion/Sort.mbi(103:9-106:9)
    while (is1 < num1):
      perm_tgt[it] = perm_src[(is1 + src_base1)]
      is1 += 1
      it += 1
    # src/fusion/Sort.mbi(107:9-110:9)
    while (is2 < num2):
      perm_tgt[it] = perm_src[(is2 + src_base2)]
      is2 += 1
      it += 1
  @staticmethod
  def _matchargs_argsort_1merge__3L_3I_3ILL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/Sort.mbi(114:15-184:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argsort_merge([long],[int],[int],long,long)")
  def _argsort_1merge__3L_3I_3ILL(perm,val1,val2,first,last):
    rangelen = (last - first)

    perm0 = perm

    base0 = first

    perm1 = ([ 0l for _autovar_569 in xrange((last - first)) ])

    base1 = 0l

    alt = True

    ilen = 1l

    # src/fusion/Sort.mbi(125:9-178:9)
    while (ilen < rangelen):
      if   alt:
        i = 0l

        # src/fusion/Sort.mbi(130:13-137:13)
        while (i < (rangelen - (ilen * 2))):
          ( Sort.__argmerge__3LLLLL_3LL_3I_3I (perm0,(base0 + i),ilen,((base0 + i) + ilen),ilen,perm1,(base1 + i),val1,val2) )
          i = (i + (ilen * 2))
        if   (i < (rangelen - ilen)):
          ( Sort.__argmerge__3LLLLL_3LL_3I_3I (perm0,(base0 + i),ilen,((base0 + i) + ilen),((rangelen - i) - ilen),perm1,(base1 + i),val1,val2) )
        elif (i < rangelen):
          ( Utils.Tools._arraycopy__3LL_3LLL (perm0,(base0 + i),perm1,(base1 + i),(rangelen - i)) )
      else:
        i = 0l

        # src/fusion/Sort.mbi(154:13-161:13)
        while (i < (rangelen - (ilen * 2))):
          ( Sort.__argmerge__3LLLLL_3LL_3I_3I (perm1,(base1 + i),ilen,((base1 + i) + ilen),ilen,perm0,(base0 + i),val1,val2) )
          i = (i + (ilen * 2))
        if   (i < (rangelen - ilen)):
          ( Sort.__argmerge__3LLLLL_3LL_3I_3I (perm1,(base1 + i),ilen,((base1 + i) + ilen),((rangelen - i) - ilen),perm0,(base0 + i),val1,val2) )
        elif (i < rangelen):
          ( Utils.Tools._arraycopy__3LL_3LLL (perm1,(base1 + i),perm0,(base0 + i),(rangelen - i)) )
      alt = (not alt)
      ilen = (ilen * 2)
    if   (not alt):
      ( Utils.Tools._arraycopy__3LL_3LLL (perm1,0l,perm0,first,rangelen) )
  @staticmethod
  def _matchargs_argsort_1merge__3L_3ILL(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],long): return False
    return True
  # origin: src/fusion/Sort.mbi(189:15-258:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argsort_merge([long],[int],long,long)")
  def _argsort_1merge__3L_3ILL(perm,val,first,last):
    rangelen = (last - first)

    perm0 = perm

    base0 = first

    perm1 = ([ 0l for _autovar_570 in xrange((last - first)) ])

    base1 = 0l

    alt = True

    ilen = 1l

    # src/fusion/Sort.mbi(199:9-252:9)
    while (ilen < rangelen):
      if   alt:
        i = 0l

        # src/fusion/Sort.mbi(204:13-211:13)
        while (i < (rangelen - (ilen * 2))):
          ( Sort.__argmerge__3LLLLL_3LL_3I (perm0,(base0 + i),ilen,((base0 + i) + ilen),ilen,perm1,(base1 + i),val) )
          i = (i + (ilen * 2))
        if   (i < (rangelen - ilen)):
          ( Sort.__argmerge__3LLLLL_3LL_3I (perm0,(base0 + i),ilen,((base0 + i) + ilen),((rangelen - i) - ilen),perm1,(base1 + i),val) )
        elif (i < rangelen):
          ( Utils.Tools._arraycopy__3LL_3LLL (perm0,(base0 + i),perm1,(base1 + i),(rangelen - i)) )
      else:
        i = 0l

        # src/fusion/Sort.mbi(228:13-235:13)
        while (i < (rangelen - (ilen * 2))):
          ( Sort.__argmerge__3LLLLL_3LL_3I (perm1,(base1 + i),ilen,((base1 + i) + ilen),ilen,perm0,(base0 + i),val) )
          i = (i + (ilen * 2))
        if   (i < (rangelen - ilen)):
          ( Sort.__argmerge__3LLLLL_3LL_3I (perm1,(base1 + i),ilen,((base1 + i) + ilen),((rangelen - i) - ilen),perm0,(base0 + i),val) )
        elif (i < rangelen):
          ( Utils.Tools._arraycopy__3LL_3LLL (perm1,(base1 + i),perm0,(base0 + i),(rangelen - i)) )
      alt = (not alt)
      ilen = (ilen * 2)
    if   (not alt):
      ( Utils.Tools._arraycopy__3LL_3LLL (perm1,0l,perm0,first,rangelen) )
  @staticmethod
  def _matchargs_argsort__3L_3I_3ILL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/Sort.mbi(261:15-263:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argsort([long],[int],[int],long,long)")
  def _argsort__3L_3I_3ILL(perm,val1,val2,first,last):
    ( Sort._argsort_1merge__3L_3I_3ILL (perm,val1,val2,first,last) )
  @staticmethod
  def _matchargs_argsort__3L_3I_3I(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Sort.mbi(266:15-268:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argsort([long],[int],[int])")
  def _argsort__3L_3I_3I(perm,val1,val2):
    ( Sort._argsort_1merge__3L_3I_3ILL (perm,val1,val2,0l,long(len(perm))) )
  @staticmethod
  def _matchargs_argsort__3L_3ILL(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],long): return False
    return True
  # origin: src/fusion/Sort.mbi(273:15-275:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argsort([long],[int],long,long)")
  def _argsort__3L_3ILL(perm,val,first,last):
    ( Sort._argsort_1merge__3L_3ILL (perm,val,first,last) )
  @staticmethod
  def _matchargs_argsort__3L_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/Sort.mbi(278:15-280:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argsort([long],[int])")
  def _argsort__3L_3I(perm,val):
    ( Sort._argsort_1merge__3L_3ILL (perm,val,0l,long(len(perm))) )
  @staticmethod
  def _matchargs_argTransposeSort__3L_3LIII_3L(args):
    if len(args) != 6:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  # origin: src/fusion/Sort.mbi(309:15-319:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argTransposeSort([long],[long],int,int,int,[long])")
  def _argTransposeSort__3L_3LIII_3L(perm,ptrb,m,n,p,val):
    # src/fusion/Sort.mbi(310:9-91)
    for q in xrange(0,int(len(val))):
      ptrb[((((val[perm[q]] / (n * p)) * p) + (val[perm[q]] % p)) + 1)] += 1
    # src/fusion/Sort.mbi(311:9-61)
    for i in xrange(0,(m * p)):
      ptrb[(i + 1)] = (ptrb[(i + 1)] + ptrb[i])
    per2 = ( Utils.Tools._arraycopy__3L (perm) )

    # src/fusion/Sort.mbi(313:9-318:9)
    for q in xrange(0l,long(len(val))):
      # { @ src/fusion/Sort.mbi(314:9-318:9)
      k = (((val[per2[q]] / (n * p)) * p) + (val[per2[q]] % p))

      perm[ptrb[k]] = q
      ptrb[k] += 1
      # } @ src/fusion/Sort.mbi(314:9-318:9)
  @staticmethod
  @_cliptrace
  def argsort_merge(*args):
    if   Sort._matchargs_argsort_1merge__3L_3ILL(args):
      return Sort._argsort_1merge__3L_3ILL(*args)
    elif Sort._matchargs_argsort_1merge__3L_3I_3ILL(args):
      return Sort._argsort_1merge__3L_3I_3ILL(*args)
    else:
      argtypestr = "argsort_merge(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\targsort_merge([long],[int],long,long)"),(5,"\targsort_merge([long],[int],[int],long,long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def argTransposeSort(*args):
    if   Sort._matchargs_argTransposeSort__3L_3LIII_3L(args):
      return Sort._argTransposeSort__3L_3LIII_3L(*args)
    else:
      argtypestr = "argTransposeSort(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(6,"\targTransposeSort([long],[long],int,int,int,[long])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def compareArg(*args):
    if   Sort._matchargs_compareArg__3I_3ILL(args):
      return Sort._compareArg__3I_3ILL(*args)
    else:
      argtypestr = "compareArg(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\tcompareArg([int],[int],long,long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def argsort(*args):
    if   Sort._matchargs_argsort__3L_3ILL(args):
      return Sort._argsort__3L_3ILL(*args)
    elif Sort._matchargs_argsort__3L_3I_3ILL(args):
      return Sort._argsort__3L_3I_3ILL(*args)
    elif Sort._matchargs_argsort__3L_3I(args):
      return Sort._argsort__3L_3I(*args)
    elif Sort._matchargs_argsort__3L_3I_3I(args):
      return Sort._argsort__3L_3I_3I(*args)
    else:
      argtypestr = "argsort(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\targsort([long],[int],long,long)"),(5,"\targsort([long],[int],[int],long,long)"),(2,"\targsort([long],[int])"),(3,"\targsort([long],[int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/CommonUtil.mbi(6:5-596:5)
class CommonTools:
  def __init__(self,*args):
    pass
  @staticmethod
  def _matchargs_qsortCmp_IIII(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],int): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(12:16-18:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("qsortCmp(int,int,int,int)")
  def __qsortCmp_IIII(v1_0,v1_1,v2_0,v2_1):
    if   (v1_0 < v2_0):
      return (- 1)
    if   (v1_0 > v2_0):
      return 1
    if   (v1_1 < v2_1):
      return (- 1)
    if   (v1_1 > v2_1):
      return 1
    return 0
  @staticmethod
  def _matchargs_qsortCmp_LLLL(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],long): return False
    if not isinstance(args[1],long): return False
    if not isinstance(args[2],long): return False
    if not isinstance(args[3],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(21:16-27:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("qsortCmp(long,long,long,long)")
  def __qsortCmp_LLLL(v1_0,v1_1,v2_0,v2_1):
    if   (v1_0 < v2_0):
      return (- 1)
    if   (v1_0 > v2_0):
      return 1
    if   (v1_1 < v2_1):
      return (- 1)
    if   (v1_1 > v2_1):
      return 1
    return 0
  @staticmethod
  def _matchargs_qsortSwap__3LLL(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[1],long): return False
    if not isinstance(args[2],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(30:16-35:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("qsortSwap([long],long,long)")
  def __qsortSwap__3LLL(idx,i,j):

    tmp = idx[i]
    idx[i] = idx[j]
    idx[j] = tmp
  @staticmethod
  def _matchargs_qsortPartition__3L_3I_3ILLL(args):
    if len(args) != 6:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    if not isinstance(args[5],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(38:16-80:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("qsortPartition([long],[int],[int],long,long,long)")
  def __qsortPartition__3L_3I_3ILLL(idx,vals1,vals2,first,last,pivotIndex):
    pivotVal1 = vals1[idx[pivotIndex]]

    storeIndex = first

    if   (vals2 != None):
      pivotVal2 = vals2[idx[pivotIndex]]

      ( CommonTools.__qsortSwap__3LLL (idx,pivotIndex,(last - 1l)) )
      # src/fusion/CommonUtil.mbi(54:11-61:11)
      for i in xrange(first,(last - 1l)):
        # { @ src/fusion/CommonUtil.mbi(55:11-61:11)
        if   (( CommonTools.__qsortCmp_IIII (vals1[idx[i]],vals2[idx[i]],pivotVal1,pivotVal2) ) < 0):
          ( CommonTools.__qsortSwap__3LLL (idx,i,storeIndex) )
          storeIndex += 1
        # } @ src/fusion/CommonUtil.mbi(55:11-61:11)
    else:
      ( CommonTools.__qsortSwap__3LLL (idx,pivotIndex,(last - 1l)) )
      # src/fusion/CommonUtil.mbi(66:11-73:11)
      for i in xrange(first,(last - 1l)):
        # { @ src/fusion/CommonUtil.mbi(67:11-73:11)
        if   (vals1[idx[i]] < pivotVal1):
          ( CommonTools.__qsortSwap__3LLL (idx,i,storeIndex) )
          storeIndex += 1
        # } @ src/fusion/CommonUtil.mbi(67:11-73:11)
    ( CommonTools.__qsortSwap__3LLL (idx,storeIndex,(last - 1l)) )
    return storeIndex
  @staticmethod
  def _matchargs_qsortPartition__3L_3L_3LLLL(args):
    if len(args) != 6:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    if not isinstance(args[5],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(84:16-126:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("qsortPartition([long],[long],[long],long,long,long)")
  def __qsortPartition__3L_3L_3LLLL(idx,vals1,vals2,first,last,pivotIndex):
    pivotVal1 = vals1[idx[pivotIndex]]

    storeIndex = first

    if   (vals2 != None):
      pivotVal2 = vals2[idx[pivotIndex]]

      ( CommonTools.__qsortSwap__3LLL (idx,pivotIndex,(last - 1l)) )
      # src/fusion/CommonUtil.mbi(100:11-107:11)
      for i in xrange(first,(last - 1l)):
        # { @ src/fusion/CommonUtil.mbi(101:11-107:11)
        if   (( CommonTools.__qsortCmp_LLLL (vals1[idx[i]],vals2[idx[i]],pivotVal1,pivotVal2) ) < 0):
          ( CommonTools.__qsortSwap__3LLL (idx,i,storeIndex) )
          storeIndex += 1
        # } @ src/fusion/CommonUtil.mbi(101:11-107:11)
    else:
      ( CommonTools.__qsortSwap__3LLL (idx,pivotIndex,(last - 1l)) )
      # src/fusion/CommonUtil.mbi(112:11-119:11)
      for i in xrange(first,(last - 1l)):
        # { @ src/fusion/CommonUtil.mbi(113:11-119:11)
        if   (vals1[idx[i]] < pivotVal1):
          ( CommonTools.__qsortSwap__3LLL (idx,i,storeIndex) )
          storeIndex += 1
        # } @ src/fusion/CommonUtil.mbi(113:11-119:11)
    ( CommonTools.__qsortSwap__3LLL (idx,storeIndex,(last - 1l)) )
    return storeIndex
  @staticmethod
  def _matchargs_argQsortNR__3L_3I_3ILL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(131:18-165:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argQsortNR([long],[int],[int],long,long)")
  def _argQsortNR__3L_3I_3ILL(idx,vals1,vals2,first,last):
    stack = ([ 0l for _autovar_571 in xrange((2 * int(len(idx)))) ])

    stackBase = 0

    if   (int(len(idx)) > 0):
      stack[stackBase] = first
      stackBase += 1
      stack[stackBase] = last
      stackBase += 1
    # src/fusion/CommonUtil.mbi(142:9-164:9)
    while (stackBase > 0):
      stackBase = (stackBase - 1)
      f = stack[stackBase]

      stackBase = (stackBase - 1)
      l = stack[stackBase]

      if   (l > f):
        pivotIndex = (f + ((l - f) / 2))

        pivotNewIndex = ( CommonTools.__qsortPartition__3L_3I_3ILLL (idx,vals1,vals2,f,l,pivotIndex) )

        stack[stackBase] = f
        stackBase += 1
        stack[stackBase] = (pivotNewIndex - 1)
        stackBase += 1
        stack[stackBase] = (pivotNewIndex + 1)
        stackBase += 1
        stack[stackBase] = l
        stackBase += 1
  @staticmethod
  def _matchargs_argQsort_1prv__3L_3I_3ILL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(170:16-178:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argQsort_prv([long],[int],[int],long,long)")
  def __argQsort_1prv__3L_3I_3ILL(idx,vals1,vals2,first,last):
    if   (first < last):
      pivotIndex = (first + ((last - first) / 2))

      pivotNewIndex = ( CommonTools.__qsortPartition__3L_3I_3ILLL (idx,vals1,vals2,first,last,pivotIndex) )

      ( CommonTools.__argQsort_1prv__3L_3I_3ILL (idx,vals1,vals2,first,pivotNewIndex) )
      ( CommonTools.__argQsort_1prv__3L_3I_3ILL (idx,vals1,vals2,(pivotNewIndex + 1),last) )
  @staticmethod
  def _matchargs_argQsort_1prv__3L_3L_3LLL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(182:16-190:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argQsort_prv([long],[long],[long],long,long)")
  def __argQsort_1prv__3L_3L_3LLL(idx,vals1,vals2,first,last):
    if   (first < last):
      pivotIndex = (first + ((last - first) / 2))

      pivotNewIndex = ( CommonTools.__qsortPartition__3L_3L_3LLLL (idx,vals1,vals2,first,last,pivotIndex) )

      ( CommonTools.__argQsort_1prv__3L_3L_3LLL (idx,vals1,vals2,first,pivotNewIndex) )
      ( CommonTools.__argQsort_1prv__3L_3L_3LLL (idx,vals1,vals2,(pivotNewIndex + 1),last) )
  @staticmethod
  def _matchargs_argQsort__3L_3I_3ILL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(194:15-214:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argQsort([long],[int],[int],long,long)")
  def _argQsort__3L_3I_3ILL(idx,vals1,vals2,first,last):
    sorted = True

    if   ((first + 1) < last):
      if   (vals2 != None):
        # src/fusion/CommonUtil.mbi(200:11-205:12)
        i = (first + 1)

        while ((i < last) and sorted):
          if   (( CommonTools.__qsortCmp_IIII (vals1[idx[i]],vals2[idx[i]],vals1[idx[(i - 1)]],vals2[idx[(i - 1)]]) ) > 0):
            sorted = False
          i += 1
      else:
        # src/fusion/CommonUtil.mbi(207:11-211:12)
        i = (first + 1)

        while ((i < last) and sorted):
          if   (vals1[idx[i]] > vals1[idx[(i - 1)]]):
            sorted = False
          i += 1
    if   (not sorted):
      ( CommonTools.__argQsort_1prv__3L_3I_3ILL (idx,vals1,vals2,first,last) )
  @staticmethod
  def _matchargs_argQsort__3L_3L_3LLL(args):
    if len(args) != 5:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if not isinstance(args[3],long): return False
    if not isinstance(args[4],long): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(217:15-237:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argQsort([long],[long],[long],long,long)")
  def _argQsort__3L_3L_3LLL(idx,vals1,vals2,first,last):
    sorted = True

    if   ((first + 1) < last):
      if   (vals2 != None):
        # src/fusion/CommonUtil.mbi(223:11-228:12)
        i = (first + 1)

        while ((i < last) and sorted):
          if   (( CommonTools.__qsortCmp_LLLL (vals1[idx[i]],vals2[idx[i]],vals1[idx[(i - 1)]],vals2[idx[(i - 1)]]) ) > 0):
            sorted = False
          i += 1
      else:
        # src/fusion/CommonUtil.mbi(230:11-234:12)
        i = (first + 1)

        while ((i < last) and sorted):
          if   (vals1[idx[i]] > vals1[idx[(i - 1)]]):
            sorted = False
          i += 1
    if   (not sorted):
      ( CommonTools.__argQsort_1prv__3L_3L_3LLL (idx,vals1,vals2,first,last) )
  @staticmethod
  def _matchargs_mergeInto__3I_3I_3IIII(args):
    if len(args) != 6:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    if not isinstance(args[3],int): return False
    if not isinstance(args[4],int): return False
    if not isinstance(args[5],int): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(259:16-285:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("mergeInto([int],[int],[int],int,int,int)")
  def __mergeInto__3I_3I_3IIII(src,tgt,vals,si0,si1,si2):
    if   (si2 > int(len(src))):
      si2 = int(len(src))
    if   (si1 > si2):
      si1 = si2
    if   (si1 == si2):
      ( Utils.Tools._arraycopy__3II_3III (src,si0,tgt,si0,(si1 - si0)) )
    else:
      i0 = si0

      i1 = si1


      # src/fusion/CommonUtil.mbi(277:11-281:11)
      i = si0
      while ((i0 < si1) and (i1 < si2)):
        if   (vals[src[i0]] < vals[src[i1]]):
          tgt[i] = src[i0]
          i0 += 1
        else:
          tgt[i] = src[i1]
          i1 += 1
        i += 1
      # src/fusion/CommonUtil.mbi(282:11-59)
      while (i0 < si1):
        tgt[i] = src[i0]
        i0 += 1
        i += 1
      # src/fusion/CommonUtil.mbi(283:11-59)
      while (i1 < si2):
        tgt[i] = src[i1]
        i1 += 1
        i += 1
  @staticmethod
  def _matchargs_argMSort__3I_3I(args):
    if len(args) != 2:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(299:15-323:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("argMSort([int],[int])")
  def _argMSort__3I_3I(idx,vals):
    temp = ([ 0 for _autovar_572 in xrange(int(len(idx))) ])

    alt = False

    # src/fusion/CommonUtil.mbi(303:9-318:9)
    intvlen = 1

    while (intvlen < int(len(idx))):
      alt = (not alt)
      # src/fusion/CommonUtil.mbi(306:11-317:11)
      i = 0

      while (i < int(len(idx))):
        if   alt:
          ( CommonTools.__mergeInto__3I_3I_3IIII (idx,temp,vals,i,(i + intvlen),(i + (2 * intvlen))) )
        else:
          ( CommonTools.__mergeInto__3I_3I_3IIII (temp,idx,vals,i,(i + intvlen),(i + (2 * intvlen))) )
        i = (i + (intvlen * 2))
      intvlen = (intvlen * 2)
    if   alt:
      ( Utils.Tools._arraycopy__3II_3III (temp,0,idx,0,int(len(idx))) )
  @staticmethod
  def _matchargs_tripletSort__3I_3I_3F_3_3I_3_3I_3_3FLII(args):
    if len(args) != 9:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    if not isinstance(args[6],long): return False
    if not isinstance(args[7],int): return False
    if not isinstance(args[8],int): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(354:15-459:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("tripletSort([int],[int],[float],[[int]],[[int]],[[float]],long,int,int)")
  def _tripletSort__3I_3I_3F_3_3I_3_3I_3_3FLII(subi,subj,val,tsubi_,tsubj_,tval_,nelm,dimi,dimj):
    cols = ([ 0 for _autovar_573 in xrange(nelm) ])

    cptrb = ([ 0l for _autovar_574 in xrange((dimj + 2)) ])

    # src/fusion/CommonUtil.mbi(377:9-75)
    for i in xrange(0l,nelm):
      # { @ src/fusion/CommonUtil.mbi(377:32-75)
      cptrb[(subj[i] + 2)] = (cptrb[(subj[i] + 2)] + 1)
      # } @ src/fusion/CommonUtil.mbi(377:32-75)
    # src/fusion/CommonUtil.mbi(378:9-69)
    for i in xrange(1,dimj):
      # { @ src/fusion/CommonUtil.mbi(378:31-69)
      cptrb[(i + 1)] = (cptrb[(i + 1)] + cptrb[i])
      # } @ src/fusion/CommonUtil.mbi(378:31-69)
    # src/fusion/CommonUtil.mbi(379:9-384:9)
    for i in xrange(0,int(nelm)):
      # { @ src/fusion/CommonUtil.mbi(380:9-384:9)
      cidx = subj[i]

      cols[cptrb[(cidx + 1)]] = i
      cptrb[(cidx + 1)] = (cptrb[(cidx + 1)] + 1)
      # } @ src/fusion/CommonUtil.mbi(380:9-384:9)
    rptrb = ([ 0l for _autovar_575 in xrange((dimi + 2)) ])

    rows = ([ 0 for _autovar_576 in xrange(nelm) ])

    # src/fusion/CommonUtil.mbi(390:9-82)
    i = 0

    while (i < nelm):
      rptrb[(subi[i] + 2)] = (rptrb[(subi[i] + 2)] + 1)
      i += 1
    # src/fusion/CommonUtil.mbi(391:9-78)
    i = 1

    while (i < dimi):
      rptrb[(i + 1)] = (rptrb[(i + 1)] + rptrb[i])
      i += 1
    # src/fusion/CommonUtil.mbi(392:9-400:9)
    j = 0

    while (j < dimj):
      # src/fusion/CommonUtil.mbi(394:11-399:11)
      i = cptrb[j]

      while (i < cptrb[(j + 1)]):
        ridx = subi[cols[i]]

        rows[rptrb[(ridx + 1)]] = cols[i]
        rptrb[(ridx + 1)] = (rptrb[(ridx + 1)] + 1)
        i += 1
      j += 1
    nunique = 1

    # { @ src/fusion/CommonUtil.mbi(406:9-422:9)
    si = subi[rows[0]]

    sj = subj[rows[0]]

    # src/fusion/CommonUtil.mbi(410:11-421:11)
    i = 1

    while (i < nelm):
      idx = rows[i]

      if   ((si != subi[idx]) or (sj != subj[idx])):
        si = subi[idx]
        sj = subj[idx]
        nunique += 1
      i += 1
    # } @ src/fusion/CommonUtil.mbi(406:9-422:9)
    tsubi = ([ 0 for _autovar_577 in xrange(nunique) ])

    tsubj = ([ 0 for _autovar_578 in xrange(nunique) ])

    tval = ([ 0.0 for _autovar_579 in xrange(nunique) ])

    # { @ src/fusion/CommonUtil.mbi(429:9-434:9)
    idx = rows[0]

    tsubi[0] = subi[idx]
    tsubj[0] = subj[idx]
    tval[0] = val[idx]
    # } @ src/fusion/CommonUtil.mbi(429:9-434:9)
    di = 1

    # src/fusion/CommonUtil.mbi(437:9-454:9)
    i = 1

    while (i < nelm):
      idx = rows[i]

      if   ((tsubi[(di - 1)] == subi[idx]) and (tsubj[(di - 1)] == subj[idx])):
        tval[(di - 1)] = (tval[(di - 1)] + val[idx])
      else:
        tsubi[di] = subi[idx]
        tsubj[di] = subj[idx]
        tval[di] = val[idx]
        di += 1
      i += 1
    tsubi_[0] = tsubi
    tsubj_[0] = tsubj
    tval_[0] = tval
  @staticmethod
  def _matchargs_transposeTriplets__3I_3I_3F_3_3I_3_3I_3_3FLII(args):
    if len(args) != 9:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_int(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    if not isinstance(args[6],long): return False
    if not isinstance(args[7],int): return False
    if not isinstance(args[8],int): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(492:15-536:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("transposeTriplets([int],[int],[float],[[int]],[[int]],[[float]],long,int,int)")
  def _transposeTriplets__3I_3I_3F_3_3I_3_3I_3_3FLII(subi,subj,val,tsubi_,tsubj_,tval_,nelm,dimi,dimj):
    rptrb = ([ 0l for _autovar_580 in xrange((dimi + 2)) ])

    cptrb = ([ 0l for _autovar_581 in xrange((dimj + 2)) ])

    # src/fusion/CommonUtil.mbi(506:9-510:9)
    i = 0l

    while (i < nelm):
      cptrb[(subj[i] + 2)] = (cptrb[(subj[i] + 2)] + 1)
      rptrb[(subi[i] + 2)] = (rptrb[(subi[i] + 2)] + 1)
      i += 1
    # src/fusion/CommonUtil.mbi(512:9-78)
    i = 1

    while (i < dimi):
      rptrb[(i + 1)] = (rptrb[(i + 1)] + rptrb[i])
      i += 1
    # src/fusion/CommonUtil.mbi(513:9-78)
    i = 1

    while (i < dimj):
      cptrb[(i + 1)] = (cptrb[(i + 1)] + cptrb[i])
      i += 1
    tsubi = ([ 0 for _autovar_582 in xrange(nelm) ])

    tsubj = ([ 0 for _autovar_583 in xrange(nelm) ])

    tval = ([ 0.0 for _autovar_584 in xrange(nelm) ])

    # src/fusion/CommonUtil.mbi(519:9-531:9)
    i = 0

    while (i < dimi):
      # src/fusion/CommonUtil.mbi(521:11-530:11)
      k = rptrb[i]

      while (k < rptrb[(i + 1)]):
        j = subj[k]

        cidx = cptrb[j]

        tsubi[cidx] = i
        tsubj[cidx] = j
        tval[cidx] = val[k]
        cptrb[j] = (cidx + 1)
        k += 1
      i += 1
    tsubi_[0] = tsubj
    tsubj_[0] = tsubi
    tval_[0] = tval
  @staticmethod
  def _matchargs_transposeTriplets__3I_3I_3F_3_3L_3_3L_3_3FLII(args):
    if len(args) != 9:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_long(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_long(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not mosek.fusion.Utils.isArray(a): return False
      elif a is not None and len(a) > 0:
        a = a[0]
        if not Utils.is_float(a): return False
    if not isinstance(args[6],long): return False
    if not isinstance(args[7],int): return False
    if not isinstance(args[8],int): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(540:15-584:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("transposeTriplets([int],[int],[float],[[long]],[[long]],[[float]],long,int,int)")
  def _transposeTriplets__3I_3I_3F_3_3L_3_3L_3_3FLII(subi,subj,val,tsubi_,tsubj_,tval_,nelm,dimi,dimj):
    rptrb = ([ 0l for _autovar_585 in xrange((dimi + 2)) ])

    cptrb = ([ 0l for _autovar_586 in xrange((dimj + 2)) ])

    # src/fusion/CommonUtil.mbi(554:9-558:9)
    i = 0l

    while (i < nelm):
      cptrb[(subj[i] + 2)] = (cptrb[(subj[i] + 2)] + 1)
      rptrb[(subi[i] + 2)] = (rptrb[(subi[i] + 2)] + 1)
      i += 1
    # src/fusion/CommonUtil.mbi(560:9-78)
    i = 1

    while (i < dimi):
      rptrb[(i + 1)] = (rptrb[(i + 1)] + rptrb[i])
      i += 1
    # src/fusion/CommonUtil.mbi(561:9-78)
    i = 1

    while (i < dimj):
      cptrb[(i + 1)] = (cptrb[(i + 1)] + cptrb[i])
      i += 1
    tsubi = ([ 0l for _autovar_587 in xrange(nelm) ])

    tsubj = ([ 0l for _autovar_588 in xrange(nelm) ])

    tval = ([ 0.0 for _autovar_589 in xrange(nelm) ])

    # src/fusion/CommonUtil.mbi(567:9-579:9)
    i = 0

    while (i < dimi):
      # src/fusion/CommonUtil.mbi(569:11-578:11)
      k = rptrb[i]

      while (k < rptrb[(i + 1)]):
        j = subj[k]

        cidx = cptrb[j]

        tsubi[cidx] = long(i)
        tsubj[cidx] = long(j)
        tval[cidx] = val[k]
        cptrb[j] = (cidx + 1)
        k += 1
      i += 1
    tsubi_[0] = tsubj
    tsubj_[0] = tsubi
    tval_[0] = tval
  @staticmethod
  def _matchargs_ndIncr__3I_3I_3I(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    return True
  # origin: src/fusion/CommonUtil.mbi(587:15-595:7)
  @staticmethod
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("ndIncr([int],[int],[int])")
  def _ndIncr__3I_3I_3I(ndidx,first,last):
    i = (int(len(ndidx)) - 1)

    ndidx[i] += 1
    # src/fusion/CommonUtil.mbi(590:9-594:9)
    while ((i > 0) and (ndidx[i] >= last[i])):
      ndidx[i] = first[i]
      ndidx[(i - 1)] += 1
  @staticmethod
  @_cliptrace
  def argMSort(*args):
    if   CommonTools._matchargs_argMSort__3I_3I(args):
      return CommonTools._argMSort__3I_3I(*args)
    else:
      argtypestr = "argMSort(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\targMSort([int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def tripletSort(*args):
    if   CommonTools._matchargs_tripletSort__3I_3I_3F_3_3I_3_3I_3_3FLII(args):
      return CommonTools._tripletSort__3I_3I_3F_3_3I_3_3I_3_3FLII(*args)
    else:
      argtypestr = "tripletSort(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(9,"\ttripletSort([int],[int],[float],[[int]],[[int]],[[float]],long,int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def argQsort(*args):
    if   CommonTools._matchargs_argQsort__3L_3I_3ILL(args):
      return CommonTools._argQsort__3L_3I_3ILL(*args)
    elif CommonTools._matchargs_argQsort__3L_3L_3LLL(args):
      return CommonTools._argQsort__3L_3L_3LLL(*args)
    else:
      argtypestr = "argQsort(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(5,"\targQsort([long],[int],[int],long,long)"),(5,"\targQsort([long],[long],[long],long,long)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def ndIncr(*args):
    if   CommonTools._matchargs_ndIncr__3I_3I_3I(args):
      return CommonTools._ndIncr__3I_3I_3I(*args)
    else:
      argtypestr = "ndIncr(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tndIncr([int],[int],[int])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @staticmethod
  @_cliptrace
  def transposeTriplets(*args):
    if   CommonTools._matchargs_transposeTriplets__3I_3I_3F_3_3I_3_3I_3_3FLII(args):
      return CommonTools._transposeTriplets__3I_3I_3F_3_3I_3_3I_3_3FLII(*args)
    elif CommonTools._matchargs_transposeTriplets__3I_3I_3F_3_3L_3_3L_3_3FLII(args):
      return CommonTools._transposeTriplets__3I_3I_3F_3_3L_3_3L_3_3FLII(*args)
    else:
      argtypestr = "transposeTriplets(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(9,"\ttransposeTriplets([int],[int],[float],[[int]],[[int]],[[float]],long,int,int)"),(9,"\ttransposeTriplets([int],[int],[float],[[long]],[[long]],[[float]],long,int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Model.mbi(2437:5-2756:5)
class SolutionStruct:
  @staticmethod
  def _matchargs_constructor_IIII(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],int): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(int,int,int,int) @ src/fusion/Model.mbi(2706:15-2755:7)")
  def __constructor_IIII(self,numvar,numcon,numcone,numbarvar):
    self.pobj = 0.0
    self.dobj = 0.0
    self.pstatus = SolutionStatus.Unknown
    self.dstatus = SolutionStatus.Unknown
    self.sol_numvar = numvar
    self.sol_numcon = numcon
    self.sol_numcone = numcone
    self.sol_numbarvar = numbarvar
    self.slx = None
    self.sux = None
    self.xx = None
    self.slc = None
    self.suc = None
    self.y = None
    self.xc = None
    self.snx = None
    self.barx = None
    self.bars = None
    if   (numvar > 0):
      self.slx = ([ 0.0 for _autovar_590 in xrange(numvar) ])
      self.sux = ([ 0.0 for _autovar_591 in xrange(numvar) ])
      self.xx = ([ 0.0 for _autovar_592 in xrange(numvar) ])
    if   (numbarvar > 0):
      self.barx = ([ 0.0 for _autovar_593 in xrange(numbarvar) ])
      self.bars = ([ 0.0 for _autovar_594 in xrange(numbarvar) ])
    if   (numcon > 0):
      self.slc = ([ 0.0 for _autovar_595 in xrange(numcon) ])
      self.suc = ([ 0.0 for _autovar_596 in xrange(numcon) ])
      self.y = ([ 0.0 for _autovar_597 in xrange(numcon) ])
      self.xc = ([ 0.0 for _autovar_598 in xrange(numcon) ])
    if   (numcone > 0):
      self.snx = ([ 0.0 for _autovar_599 in xrange(numvar) ])
  def __init__(self,*args):
    #self.sol_numcon = None

    #self.sol_numvar = None

    #self.sol_numcone = None

    #self.sol_numbarvar = None

    #self.pstatus = None

    #self.dstatus = None

    #self.pobj = None

    #self.dobj = None

    #self.xc = None

    #self.xx = None

    #self.slc = None

    #self.suc = None

    #self.y = None

    #self.barx = None

    #self.bars = None

    #self.slx = None

    #self.sux = None

    #self.snx = None

    self.__constructor_IIII(*args)
  @staticmethod
  def _matchargs_isAcceptable_Omosek_fusion_SolutionStatus_2Omosek_fusion_AccSolutionStatus_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionStatus): return False
    if not isinstance(args[1],mosek.fusion.AccSolutionStatus): return False
    return True
  # origin: src/fusion/Model.mbi(2464:16-2494:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("isAcceptable(mosek.fusion.SolutionStatus,mosek.fusion.AccSolutionStatus)")
  def __isAcceptable_Omosek_fusion_SolutionStatus_2Omosek_fusion_AccSolutionStatus_2(self,stat,accstat):
    if   (accstat == AccSolutionStatus.Anything):
      return True
    elif (accstat == AccSolutionStatus.Optimal):
      return (stat == SolutionStatus.Optimal)
    elif (accstat == AccSolutionStatus.NearOptimal):
      return ((stat == SolutionStatus.Optimal) or (stat == SolutionStatus.NearOptimal))
    elif (accstat == AccSolutionStatus.Feasible):
      return (((stat == SolutionStatus.Optimal) or (stat == SolutionStatus.NearOptimal)) or (stat == SolutionStatus.Feasible))
    elif (accstat == AccSolutionStatus.Certificate):
      return (stat == SolutionStatus.Certificate)
    return False
  @staticmethod
  def _matchargs_isPrimalAcceptable_Omosek_fusion_AccSolutionStatus_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.AccSolutionStatus): return False
    return True
  # origin: src/fusion/Model.mbi(2497:15-2499:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("isPrimalAcceptable(mosek.fusion.AccSolutionStatus)")
  def _isPrimalAcceptable_Omosek_fusion_AccSolutionStatus_2(self,acceptable_sol):
    return ( self.__isAcceptable_Omosek_fusion_SolutionStatus_2Omosek_fusion_AccSolutionStatus_2(self.pstatus,acceptable_sol) )
  @staticmethod
  def _matchargs_isDualAcceptable_Omosek_fusion_AccSolutionStatus_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.AccSolutionStatus): return False
    return True
  # origin: src/fusion/Model.mbi(2502:15-2504:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("isDualAcceptable(mosek.fusion.AccSolutionStatus)")
  def _isDualAcceptable_Omosek_fusion_AccSolutionStatus_2(self,acceptable_sol):
    return ( self.__isAcceptable_Omosek_fusion_SolutionStatus_2Omosek_fusion_AccSolutionStatus_2(self.dstatus,acceptable_sol) )
  @staticmethod
  def _matchargs_resize_IIII(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    if not isinstance(args[3],int): return False
    return True
  # origin: src/fusion/Model.mbi(2507:15-2700:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("resize(int,int,int,int)")
  def _resize_IIII(self,numvar,numcon,numcone,numbarvar):
    if   (numbarvar < 0):
      pass
    elif (numbarvar <= self.sol_numbarvar):
      self.sol_numbarvar = numbarvar
    elif (numvar <= int(len(self.barx))):
      # src/fusion/Model.mbi(2522:13-2526:13)
      for i in xrange(self.sol_numvar,numvar):
        # { @ src/fusion/Model.mbi(2523:13-2526:13)
        self.barx[i] = None
        self.bars[i] = None
        # } @ src/fusion/Model.mbi(2523:13-2526:13)
    else:

      if   ((self.sol_numbarvar * 2) > (numbarvar + 100)):
        newsize = (self.sol_numbarvar * 2)
      else:
        newsize = (numbarvar + 100)
      newbarx = ([ 0.0 for _autovar_600 in xrange(newsize) ])

      # src/fusion/Model.mbi(2536:15-62)
      for i in xrange(0,int(len(self.barx))):
        newbarx[i] = self.barx[i]
      self.barx = newbarx
      newbars = ([ 0.0 for _autovar_601 in xrange(newsize) ])

      # src/fusion/Model.mbi(2540:15-62)
      for i in xrange(0,int(len(self.bars))):
        newbars[i] = self.bars[i]
      self.bars = newbars
      self.sol_numbarvar = numbarvar
    if   (numvar < 0):
      pass
    elif (numvar <= self.sol_numvar):
      self.sol_numvar = numvar
    elif (numvar <= int(len(self.xx))):
      # src/fusion/Model.mbi(2559:15-2564:15)
      i = self.sol_numvar

      while (i < numvar):
        self.slx[i] = 0.0
        self.sux[i] = 0.0
        self.xx[i] = 0.0
        i += 1
      self.sol_numvar = numvar
    else:

      if   ((self.sol_numvar * 2) > (numvar + 100)):
        newsize = (self.sol_numvar * 2)
      else:
        newsize = (numvar + 100)
      newslx = ([ 0.0 for _autovar_602 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.slx,0,newslx,0,int(len(self.slx))) )
      self.slx = newslx
      newsux = ([ 0.0 for _autovar_603 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.sux,0,newsux,0,int(len(self.sux))) )
      self.sux = newsux
      newxx = ([ 0.0 for _autovar_604 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.xx,0,newxx,0,int(len(self.xx))) )
      self.xx = newxx
      # src/fusion/Model.mbi(2586:15-2592:15)
      i = self.sol_numvar

      while (i < numvar):
        self.slx[i] = 0.0
        self.sux[i] = 0.0
        self.xx[i] = 0.0
        i += 1
      self.sol_numvar = numvar
    if   (numcon < 0):
      pass
    elif (numcon <= self.sol_numcon):
      self.sol_numcon = numcon
    elif (numcon <= int(len(self.xx))):
      # src/fusion/Model.mbi(2609:15-2616:15)
      i = self.sol_numcon

      while (i < numcon):
        self.slc[i] = 0.0
        self.suc[i] = 0.0
        self.xc[i] = 0.0
        self.y[i] = 0.0
        i += 1
      self.sol_numcon = numcon
    else:

      if   ((self.sol_numcon * 2) > (numcon + 100)):
        newsize = (self.sol_numcon * 2)
      else:
        newsize = (numcon + 100)
      newslc = ([ 0.0 for _autovar_605 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.slc,0,newslc,0,int(len(self.slc))) )
      self.slc = newslc
      newsuc = ([ 0.0 for _autovar_606 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.suc,0,newsuc,0,int(len(self.suc))) )
      self.suc = newsuc
      newxc = ([ 0.0 for _autovar_607 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.xc,0,newxc,0,int(len(self.xc))) )
      self.xc = newxc
      newy = ([ 0.0 for _autovar_608 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.y,0,newy,0,int(len(self.y))) )
      self.y = newy
      # src/fusion/Model.mbi(2645:15-2652:15)
      i = self.sol_numcon

      while (i < numcon):
        self.slc[i] = 0.0
        self.suc[i] = 0.0
        self.xc[i] = 0.0
        self.y[i] = 0.0
        i += 1
      self.sol_numcon = numcon
    if   (numcone < 0):
      pass
    elif (numcone <= self.sol_numcone):
      self.sol_numcone = numcone
    elif (numcone <= int(len(self.xx))):
      # src/fusion/Model.mbi(2670:13-2674:13)
      i = self.sol_numcone

      while (i < numcone):
        self.snx[i] = 0.0
        i += 1
      self.sol_numcone = numcone
    else:

      if   ((self.sol_numcone * 2) > (numcone + 100)):
        newsize = (self.sol_numcone * 2)
      else:
        newsize = (numcone + 100)
      newsnx = ([ 0.0 for _autovar_609 in xrange(newsize) ])

      ( Utils.Tools._arraycopy__3FI_3FII (self.snx,0,newsnx,0,int(len(self.snx))) )
      self.snx = newsnx
      # src/fusion/Model.mbi(2692:15-2696:15)
      i = self.sol_numcone

      while (i < numcone):
        self.snx[i] = 0.0
        i += 1
      self.sol_numcone = numcone
  @_cliptrace
  def isPrimalAcceptable(self,*args):
    if   SolutionStruct._matchargs_isPrimalAcceptable_Omosek_fusion_AccSolutionStatus_2(args):
      return SolutionStruct._isPrimalAcceptable_Omosek_fusion_AccSolutionStatus_2(self,*args)
    else:
      argtypestr = "isPrimalAcceptable(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tisPrimalAcceptable(mosek.fusion.AccSolutionStatus)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def isDualAcceptable(self,*args):
    if   SolutionStruct._matchargs_isDualAcceptable_Omosek_fusion_AccSolutionStatus_2(args):
      return SolutionStruct._isDualAcceptable_Omosek_fusion_AccSolutionStatus_2(self,*args)
    else:
      argtypestr = "isDualAcceptable(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tisDualAcceptable(mosek.fusion.AccSolutionStatus)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def resize(self,*args):
    if   SolutionStruct._matchargs_resize_IIII(args):
      return SolutionStruct._resize_IIII(self,*args)
    else:
      argtypestr = "resize(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\tresize(int,int,int,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(198:5-209:5)
class UnexpectedError(Exception):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(202:17-204:9)")
  def __constructor_S(self,msg):
    Exception.__init__(self,msg)
    pass
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_Utils_FusionException_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Utils.FusionException): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.Utils.FusionException) @ src/fusion/Errors.mbi(206:17-208:9)")
  def __constructor_Omosek_fusion_Utils_FusionException_2(self,e):
    Exception.__init__(self,( e._toString_() ))
    pass
  def __init__(self,*args):
    if   self._matchargs_constructor_S(args):
      self.__constructor_S(*args)
    elif self._matchargs_constructor_Omosek_fusion_Utils_FusionException_2(args):
      self.__constructor_Omosek_fusion_Utils_FusionException_2(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  def __str__(self): return self.toString()
 
## origin: src/fusion/ConstraintCache.mbi(19:5-369:5)
class ConstraintCache:
  @staticmethod
  def _matchargs_constructor__3L_3F_3I_3F(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([long],[float],[int],[float]) @ src/fusion/ConstraintCache.mbi(53:15-77:7)")
  def __constructor__3L_3F_3I_3F(self,ptrb_,cof_,subj_,bfix_):
    self.nrows = (int(len(ptrb_)) - 1)
    self.nnz = ptrb_[(int(len(ptrb_)) - 1)]
    self.subj = ([ 0 for _autovar_610 in xrange(self.nnz) ])
    self.subi = ([ 0 for _autovar_611 in xrange(self.nnz) ])
    self.cof = ([ 0.0 for _autovar_612 in xrange(self.nnz) ])
    if   (bfix_ != None):
      self.bfix = bfix_
    else:
      self.bfix = ([ 0.0 for _autovar_613 in xrange(self.nrows) ])
    ( Utils.Tools._arraycopy__3IL_3ILL (subj_,0l,self.subj,0l,self.nnz) )
    ( Utils.Tools._arraycopy__3FL_3FLL (cof_,0l,self.cof,0l,self.nnz) )
    # src/fusion/ConstraintCache.mbi(69:9-71:24)
    for i in xrange(0,self.nrows):
      # src/fusion/ConstraintCache.mbi(70:11-71:24)
      for j in xrange(ptrb_[i],ptrb_[(i + 1)]):
        self.subi[j] = i
    self.buffer_cof = None
    self.buffer_subj = None
    self.buffer_subi = None
    self.nunordered = 0l
  def __init__(self,*args):
    #self.nrows = None

    #self.nnz = None

    #self.subj = None

    #self.subi = None

    #self.cof = None

    #self.bfix = None

    #self.buffer_cof = None

    #self.buffer_subj = None

    #self.buffer_subi = None

    #self.nunordered = None

    self.__constructor__3L_3F_3I_3F(*args)
  @staticmethod
  def _matchargs_numUnsorted_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/ConstraintCache.mbi(83:15-85:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("numUnsorted()")
  def _numUnsorted_(self):
    return self.nunordered
  @staticmethod
  def _matchargs_flush__3I_3I_3F_3F(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConstraintCache.mbi(102:15-277:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("flush([int],[int],[float],[float])")
  def _flush__3I_3I_3F_3F(self,ressubi,ressubj,rescof,resbfix):
    perm = None

    if   ((self.bfix != None) and (resbfix != None)):
      # src/fusion/ConstraintCache.mbi(111:11-112:33)
      for i in xrange(0,self.nrows):
        resbfix[i] = self.bfix[i]
    if   (self.nunordered == 0l):
      return 0l
    is_ordered = False

    # { @ src/fusion/ConstraintCache.mbi(121:9-125:9)
    i = 1

    # src/fusion/ConstraintCache.mbi(123:11-156)
    while ((i < self.nunordered) and ((self.buffer_subi[(i - 1)] < self.buffer_subi[i]) or ((self.buffer_subi[(i - 1)] == self.buffer_subi[i]) and (self.buffer_subj[(i - 1)] <= self.buffer_subj[i])))):
      i += 1
    is_ordered = (i == self.nunordered)
    # } @ src/fusion/ConstraintCache.mbi(121:9-125:9)
    if   (not is_ordered):
      perm = ([ 0l for _autovar_614 in xrange(self.nunordered) ])
      # src/fusion/ConstraintCache.mbi(129:35-75)
      for i in xrange(0l,self.nunordered):
        perm[i] = i
      ( CommonTools._argQsort__3L_3I_3ILL (perm,self.buffer_subi,self.buffer_subj,0l,self.nunordered) )
    nordered = int(len(self.subi))

    r_subi = ([ 0 for _autovar_615 in xrange((self.nunordered + nordered)) ])

    r_subj = ([ 0 for _autovar_616 in xrange((self.nunordered + nordered)) ])

    r_cof = ([ 0.0 for _autovar_617 in xrange((self.nunordered + nordered)) ])

    p = 0l

    if   is_ordered:
      i0 = 0

      i1 = 0

      e0 = nordered

      e1 = self.nunordered

      j = 0

      row = 0l

      # src/fusion/ConstraintCache.mbi(150:11-196:11)
      while ((i0 < e0) and (i1 < e1)):
        if   ((self.subi[i0] < self.buffer_subi[i1]) or ((self.subi[i0] == self.buffer_subi[i1]) and (self.subj[i0] < self.buffer_subj[i1]))):
          r_subi[j] = self.subi[i0]
          r_subj[j] = self.subj[i0]
          r_cof[j] = self.cof[i0]
          i0 += 1
          j += 1
        elif ((self.subi[i0] > self.buffer_subi[i1]) or ((self.subi[i0] == self.buffer_subi[i1]) and (self.subj[i0] > self.buffer_subj[i1]))):
          r_subi[j] = self.buffer_subi[i1]
          r_subj[j] = self.buffer_subj[i1]
          r_cof[j] = self.buffer_cof[i1]
          ressubi[p] = r_subi[j]
          ressubj[p] = r_subj[j]
          rescof[p] = r_cof[j]
          p += 1
          i1 += 1
          j += 1
        else:
          r_subi[j] = self.subi[i0]
          r_subj[j] = self.subj[i0]
          r_cof[j] = self.cof[i0]
          # src/fusion/ConstraintCache.mbi(182:15-188:15)
          while ((((i0 < int(len(self.subi))) and (i1 < int(len(self.buffer_subi)))) and (self.subi[i0] == self.buffer_subi[i1])) and (self.subj[i0] == self.buffer_subj[i1])):
            r_cof[j] = (r_cof[j] + self.buffer_cof[i1])
            i1 += 1
          ressubi[p] = r_subi[j]
          ressubj[p] = r_subj[j]
          rescof[p] = r_cof[j]
          p += 1
          i0 += 1
          j += 1
      # src/fusion/ConstraintCache.mbi(197:11-203:11)
      while (i0 < e0):
        r_subi[j] = self.subi[i0]
        r_subj[j] = self.subj[i0]
        r_cof[j] = self.cof[i0]
        i0 += 1
        j += 1
      # src/fusion/ConstraintCache.mbi(204:11-215:11)
      while (i1 < e1):
        r_subi[j] = self.buffer_subi[i1]
        r_subj[j] = self.buffer_subj[i1]
        r_cof[j] = self.buffer_cof[i1]
        ressubi[p] = r_subi[j]
        ressubj[p] = r_subj[j]
        rescof[p] = r_cof[j]
        p += 1
        i1 += 1
        j += 1
    else:
      i0 = 0

      i1 = 0

      e0 = nordered

      e1 = self.nunordered

      j = 0

      row = 0l

      # src/fusion/ConstraintCache.mbi(225:11-268:11)
      while ((i0 < e0) and (i1 < e1)):
        if   ((self.subi[i0] < self.buffer_subi[perm[i1]]) or ((self.subi[i0] == self.buffer_subi[perm[i1]]) and (self.subj[i0] < self.buffer_subj[perm[i1]]))):
          r_subi[j] = self.subi[i0]
          r_subj[j] = self.subj[i0]
          r_cof[j] = self.cof[i0]
          i0 += 1
          j += 1
        elif ((self.subi[i0] > self.buffer_subi[perm[i1]]) or ((self.subi[i0] == self.buffer_subi[perm[i1]]) and (self.subj[i0] > self.buffer_subj[perm[i1]]))):
          r_subi[j] = self.buffer_subi[perm[i1]]
          r_subj[j] = self.buffer_subj[perm[i1]]
          r_cof[j] = self.buffer_cof[perm[i1]]
          ressubi[p] = r_subi[j]
          ressubj[p] = r_subj[j]
          rescof[p] = r_cof[j]
          p += 1
          i1 += 1
          j += 1
        else:
          r_subi[j] = self.subi[i0]
          r_subj[j] = self.subj[i0]
          r_cof[j] = self.cof[i0]
          # src/fusion/ConstraintCache.mbi(254:15-259:15)
          while ((self.subi[i0] == self.buffer_subi[perm[i1]]) and (self.subj[i0] == self.buffer_subj[perm[i1]])):
            r_cof[j] = (r_cof[j] + self.buffer_cof[perm[i1]])
            i1 += 1
          ressubi[p] = r_subi[j]
          ressubj[p] = r_subj[j]
          rescof[p] = r_cof[j]
          p += 1
          i0 += 1
          j += 1
    self.subi = r_subi
    self.subj = r_subj
    self.cof = r_cof
    self.nunordered = 0l
    return p
  @staticmethod
  def _matchargs_add__3L_3I_3F_3F(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConstraintCache.mbi(290:15-300:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("add([long],[int],[float],[float])")
  def _add__3L_3I_3F_3F(self,ptrb_,subj_,cof_,bfix_):
    if   ((int(len(ptrb_)) != (self.nrows + 1)) or ((bfix_ != None) and (int(len(bfix_)) != self.nrows))):
      raise mosek.fusion.LengthError("Mismatching expression lengths")
    ( self._unchecked_1add_1l__3L_3I_3F_3F(ptrb_,subj_,cof_,bfix_) )
  @staticmethod
  def _matchargs_unchecked_1add_1l__3L_3I_3F_3F(args):
    if len(args) != 4:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_int(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConstraintCache.mbi(312:18-361:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("unchecked_add_l([long],[int],[float],[float])")
  def _unchecked_1add_1l__3L_3I_3F_3F(self,ptrb_,subj_,cof_,bfix_):
    newnum = (self.nunordered + ptrb_[self.nrows])

    addnum = ptrb_[self.nrows]




    if   ((self.buffer_cof == None) or (int(len(self.buffer_cof)) < newnum)):
      tmp_subi = ([ 0 for _autovar_618 in xrange(newnum) ])
      tmp_subj = ([ 0 for _autovar_619 in xrange(newnum) ])
      tmp_cof = ([ 0.0 for _autovar_620 in xrange(newnum) ])
      if   (self.buffer_cof != None):
        ( Utils.Tools._arraycopy__3IL_3ILL (self.buffer_subi,0l,tmp_subi,0l,self.nunordered) )
        ( Utils.Tools._arraycopy__3IL_3ILL (self.buffer_subj,0l,tmp_subj,0l,self.nunordered) )
        ( Utils.Tools._arraycopy__3FL_3FLL (self.buffer_cof,0l,tmp_cof,0l,self.nunordered) )
    else:
      tmp_subi = self.buffer_subi
      tmp_subj = self.buffer_subj
      tmp_cof = self.buffer_cof
    # src/fusion/ConstraintCache.mbi(345:9-347:39)
    for i in xrange(0,self.nrows):
      # src/fusion/ConstraintCache.mbi(346:11-347:39)
      for j in xrange(ptrb_[i],ptrb_[(i + 1)]):
        tmp_subi[(self.nunordered + j)] = i
    ( Utils.Tools._arraycopy__3IL_3ILL (subj_,0l,tmp_subj,self.nunordered,addnum) )
    ( Utils.Tools._arraycopy__3FL_3FLL (cof_,0l,tmp_cof,self.nunordered,addnum) )
    self.buffer_subi = tmp_subi
    self.buffer_subj = tmp_subj
    self.buffer_cof = tmp_cof
    if   (bfix_ != None):
      # src/fusion/ConstraintCache.mbi(356:11-357:41)
      for i in xrange(0,self.nrows):
        self.bfix[i] = (self.bfix[i] + bfix_[i])
    self.nunordered = newnum
    self.nnz = (self.nnz + addnum)
  @staticmethod
  def _matchargs_unchecked_1add_1fx__3F(args):
    if len(args) != 1:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    return True
  # origin: src/fusion/ConstraintCache.mbi(364:18-368:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("unchecked_add_fx([float])")
  def _unchecked_1add_1fx__3F(self,bfix_):
    # src/fusion/ConstraintCache.mbi(366:9-367:39)
    for i in xrange(0,self.nrows):
      self.bfix[i] = (self.bfix[i] + bfix_[i])
  @_cliptrace
  def add(self,*args):
    if   ConstraintCache._matchargs_add__3L_3I_3F_3F(args):
      return ConstraintCache._add__3L_3I_3F_3F(self,*args)
    else:
      argtypestr = "add(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\tadd([long],[int],[float],[float])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def numUnsorted(self,*args):
    if   ConstraintCache._matchargs_numUnsorted_(args):
      return ConstraintCache._numUnsorted_(self,*args)
    else:
      argtypestr = "numUnsorted(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tnumUnsorted()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def flush(self,*args):
    if   ConstraintCache._matchargs_flush__3I_3I_3F_3F(args):
      return ConstraintCache._flush__3I_3I_3F_3F(self,*args)
    else:
      argtypestr = "flush(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\tflush([int],[int],[float],[float])")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/FlatExpr.mbi(13:5-155:5)
class FlatExpr:
  @staticmethod
  def _matchargs_constructor__3F_3L_3LOmosek_fusion_Variable_2_3FOmosek_fusion_Set_2_3L(args):
    if len(args) != 7:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[2]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Variable): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[5] is not None and not isinstance(args[5],mosek.fusion.Set): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([float],[long],[long],mosek.fusion.Variable,[float],mosek.fusion.Set,[long]) @ src/fusion/FlatExpr.mbi(56:15-104:7)")
  def __constructor__3F_3L_3LOmosek_fusion_Variable_2_3FOmosek_fusion_Set_2_3L(self,bfix_,ptrb_,subj_,x_,cof_,shape_,inst_):
    if   ((bfix_ != None) and (int(len(bfix_)) != (int(len(ptrb_)) - 1))):
      raise mosek.fusion.SparseFormatError("Mismatching lengths of bfix and ptrb")
    if   (((cof_ == None) or (subj_ == None)) or (int(len(subj_)) != int(len(cof_)))):
      raise mosek.fusion.SparseFormatError("Mismatching lengths of x and cof")
    if   (shape_ != None):
      if   (inst_ != None):
        if   (int(len(inst_)) != (int(len(ptrb_)) - 1)):
          raise mosek.fusion.SparseFormatError("Mismatching lengths of inst and ptrb")
      elif (shape_._size != (long(len(ptrb_)) - 1)):
        raise mosek.fusion.SparseFormatError("Mismatching shape and ptrb")
    self.bfix = bfix_
    self.ptrb = ptrb_
    self.subj = subj_
    self.x = x_
    self.cof = cof_
    self.nnz = self.ptrb[(int(len(self.ptrb)) - 1)]
    self.shape = shape_
    self.inst = inst_
  @staticmethod
  def _matchargs_constructor_Omosek_fusion_FlatExpr_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.FlatExpr): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(mosek.fusion.FlatExpr) @ src/fusion/FlatExpr.mbi(110:15-126:7)")
  def __constructor_Omosek_fusion_FlatExpr_2(self,e):
    if   (e.bfix != None):
      self.bfix = ( Utils.Tools._arraycopy__3F (e.bfix) )
    else:
      self.bfix = None
    self.ptrb = ( Utils.Tools._arraycopy__3L (e.ptrb) )
    self.subj = ( Utils.Tools._arraycopy__3L (e.subj) )
    self.x = e.x
    self.cof = ( Utils.Tools._arraycopy__3F (e.cof) )
    self.nnz = e.nnz
    self.shape = e.shape
    self.inst = e.inst
  def __init__(self,*args):
    #self.bfix = None

    #self.ptrb = None

    #self.subj = None

    #self.x = None

    #self.cof = None

    #self.nnz = None

    #self.shape = None

    #self.inst = None

    if   self._matchargs_constructor__3F_3L_3LOmosek_fusion_Variable_2_3FOmosek_fusion_Set_2_3L(args):
      self.__constructor__3F_3L_3LOmosek_fusion_Variable_2_3FOmosek_fusion_Set_2_3L(*args)
    elif self._matchargs_constructor_Omosek_fusion_FlatExpr_2(args):
      self.__constructor_Omosek_fusion_FlatExpr_2(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_size_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/FlatExpr.mbi(132:15-134:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("size()")
  def _size_(self):
    return (int(len(self.ptrb)) - 1)
  @staticmethod
  def _matchargs_toString_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/FlatExpr.mbi(138:15-154:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("toString()")
  def _toString_(self):
    sb = mosek.fusion.Utils.StringBuffer()

    ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( sb._a_S("FlatExpr:") )._lf_() )._a_S("+-----------------") )._lf_() )._a_S("| ptrb[") )._a_I(int(len(self.ptrb))) )._a_S("] = ") )._a__3L(self.ptrb) )._lf_() )._a_S("| subj[") )._a_I(int(len(self.subj))) )._a_S("] = ") )._a__3L(self.subj) )._lf_() )._a_S("| cof [") )._a_I(int(len(self.cof))) )._a_S("] = ") )._a__3F(self.cof) )._lf_() )._a_S("| bfix[") )
    if   (self.bfix != None):
      ( sb._a_I(int(len(self.bfix))) )
    ( ( ( ( sb._a_S("] = ") )._a__3F(self.bfix) )._lf_() )._a_S("| inst[") )
    if   (self.inst != None):
      ( sb._a_I(int(len(self.inst))) )
    ( ( ( ( sb._a_S("] = ") )._a__3L(self.inst) )._lf_() )._a_S("+-----------------") )
    return ( sb._toString_() )
  @_cliptrace
  def toString(self,*args):
    if   FlatExpr._matchargs_toString_(args):
      return FlatExpr._toString_(self,*args)
    else:
      argtypestr = "toString(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\ttoString()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def size(self,*args):
    if   FlatExpr._matchargs_size_(args):
      return FlatExpr._size_(self,*args)
    else:
      argtypestr = "size(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsize()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/Model.mbi(149:5-2423:5)
class Model(BaseModel):
  @staticmethod
  def _matchargs_constructor_SS(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring,basestring) @ src/fusion/Model.mbi(190:15-197:6)")
  def __constructor_SS(self,name,licfile):
    mosek.fusion.BaseModel.__init__(self,name,licfile)
    self.__acceptable_sol = AccSolutionStatus.NearOptimal
    self.__solutionptr = SolutionType.Default
    self.__natvarmap_Var = ([ None for _autovar_621 in xrange(1024) ])
    self.__natvarmap_idx = ([ 0l for _autovar_622 in xrange(1024) ])
    self.__natvarmap_num = 0
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Model.mbi(205:15-213:6)")
  def __constructor_S(self,name):
    mosek.fusion.BaseModel.__init__(self,name,None)
    self.__acceptable_sol = AccSolutionStatus.NearOptimal
    self.__solutionptr = SolutionType.Default
    self.__natvarmap_Var = ([ None for _autovar_623 in xrange(1024) ])
    self.__natvarmap_idx = ([ 0l for _autovar_624 in xrange(1024) ])
    self.__natvarmap_num = 0
  @staticmethod
  def _matchargs_constructor_(args):
    if len(args) != 0:
      return False
    return True
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("__init__() @ src/fusion/Model.mbi(220:15-228:7)")
  def __constructor_(self):
    mosek.fusion.BaseModel.__init__(self,None,None)
    self.__acceptable_sol = AccSolutionStatus.Optimal
    self.__solutionptr = SolutionType.Default
    self.__natvarmap_Var = ([ None for _autovar_625 in xrange(1024) ])
    self.__natvarmap_idx = ([ 0l for _autovar_626 in xrange(1024) ])
    self.__natvarmap_num = 0
  def __init__(self,*args):
    #self.__acceptable_sol = None

    #self.__solutionptr = None

    #self.__natvarmap_Var = None

    #self.__natvarmap_idx = None

    #self.__natvarmap_num = None

    if   self._matchargs_constructor_SS(args):
      self.__constructor_SS(*args)
    elif self._matchargs_constructor_S(args):
      self.__constructor_S(*args)
    elif self._matchargs_constructor_(args):
      self.__constructor_(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_natvarmap_1ensure_I(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],int): return False
    return True
  # origin: src/fusion/Model.mbi(168:16-181:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("natvarmap_ensure(int)")
  def __natvarmap_1ensure_I(self,num):
    if   ((self.__natvarmap_num + num) > int(len(self.__natvarmap_idx))):
      newnum = (2 * int(len(self.__natvarmap_idx)))

      if   (newnum < (self.__natvarmap_num + num)):
        newnum = (self.__natvarmap_num + num)
      new_map_idx = ([ 0l for _autovar_627 in xrange(newnum) ])

      ( Utils.Tools._arraycopy__3LI_3LII (self.__natvarmap_idx,0,new_map_idx,0,self.__natvarmap_num) )
      new_map_var = ([ None for _autovar_628 in xrange(newnum) ])

      # src/fusion/Model.mbi(176:59-123)
      for i in xrange(0,self.__natvarmap_num):
        new_map_var[i] = self.__natvarmap_Var[i]
      self.__natvarmap_idx = new_map_idx
      self.__natvarmap_Var = new_map_var
  @staticmethod
  def _matchargs_getVariable_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: src/fusion/Model.mbi(235:16-89)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getVariable(basestring)")
  def _getVariable_S(self,name):
    return ( self._get_1variable_S(name) )
  @staticmethod
  def _matchargs_getConstraint_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: src/fusion/Model.mbi(242:15-241:91)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getConstraint(basestring)")
  def _getConstraint_S(self,name):
    return ( self._get_1constraint_S(name) )
  @staticmethod
  def _matchargs_sdptrilcon_SII_3L_3L_3L_3L_3F_3FOmosek_fusion_Variable_2(args):
    if len(args) != 10:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    a = args[3]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[4]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[5]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[6]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_long(a): return False
    a = args[7]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[8]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if args[9] is not None and not isinstance(args[9],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Model.mbi(270:16-516:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sdptrilcon(basestring,int,int,[long],[long],[long],[long],[float],[float],mosek.fusion.Variable)")
  def __sdptrilcon_SII_3L_3L_3L_3L_3F_3FOmosek_fusion_Variable_2(self,name,n,m,ptrb,inst,perm,vsubj,vcof,bfix,v):
    res = None

    enumnz = 0l

    # src/fusion/Model.mbi(283:32-110)
    for i in xrange(0,int(len(perm))):
      enumnz = (enumnz + (ptrb[(perm[i] + 1)] - ptrb[perm[i]]))
    tmpsubj = ([ 0 for _autovar_629 in xrange(enumnz) ])

    tmpbarsubi = ([ 0 for _autovar_630 in xrange(enumnz) ])

    tmpbarsubj = ([ 0 for _autovar_631 in xrange(enumnz) ])

    tmpptrb = ([ 0l for _autovar_632 in xrange((int(len(perm)) + 1)) ])

    # { @ src/fusion/Model.mbi(289:9-303:9)
    dstptr = 0l

    # src/fusion/Model.mbi(291:11-302:11)
    for i in xrange(0,int(len(perm))):
      # { @ src/fusion/Model.mbi(292:11-302:11)
      ( v._inst__3LIILL_3I_3I_3I(vsubj,int(ptrb[perm[i]]),int(ptrb[(perm[i] + 1)]),0l,dstptr,tmpsubj,tmpbarsubi,tmpbarsubj) )
      dstptr = ((dstptr + ptrb[(perm[i] + 1)]) - ptrb[perm[i]])
      tmpptrb[(i + 1)] = dstptr
      # } @ src/fusion/Model.mbi(292:11-302:11)
    # } @ src/fusion/Model.mbi(289:9-303:9)
    numcon = (m * ((n * (n + 1)) / 2))

    nlinvar = 0l

    nsdpvar = 0l

    # src/fusion/Model.mbi(311:9-313:18)
    for i in xrange(0l,enumnz):
      if   (tmpsubj[i] < 0):
        nsdpvar += 1
    nlinvar = (enumnz - nsdpvar)
    permj = ( Utils.Tools._range_L (enumnz) )

    # src/fusion/Model.mbi(316:9-317:75)
    for i in xrange(0,int(len(perm))):
      ( CommonTools._argQsort__3L_3I_3ILL (permj,tmpsubj,None,tmpptrb[i],tmpptrb[(i + 1)]) )
    nlinnz = 0l

    # src/fusion/Model.mbi(322:9-331:9)
    for i in xrange(0,int(len(perm))):
      # { @ src/fusion/Model.mbi(323:9-331:9)
      k = tmpptrb[i]

      # src/fusion/Model.mbi(324:31-85)
      while ((k < tmpptrb[(i + 1)]) and (tmpsubj[permj[k]] < 0)):
        k += 1
      if   (k < tmpptrb[(i + 1)]):
        nlinnz += 1
        k += 1
      # src/fusion/Model.mbi(326:11-330:11)
      while (k < tmpptrb[(i + 1)]):
        if   (tmpsubj[permj[(k - 1)]] < tmpsubj[permj[k]]):
          nlinnz += 1
        k += 1
      # } @ src/fusion/Model.mbi(323:9-331:9)
    pinst = ([ 0l for _autovar_633 in xrange(int(len(perm))) ])

    # src/fusion/Model.mbi(337:9-343:9)
    for i in xrange(0,int(len(perm))):
      # { @ src/fusion/Model.mbi(338:9-343:9)
      midx = (inst[perm[i]] / (n * n))

      iidx = ((inst[perm[i]] % (n * n)) / n)

      jidx = (inst[perm[i]] % n)

      pinst[i] = (((midx * ((n * (n + 1)) / 2)) + ((iidx * (iidx + 1)) / 2)) + jidx)
      # } @ src/fusion/Model.mbi(338:9-343:9)
    initial_numvar = ( self._task_1numvar_() )

    initial_numcon = ( self._task_1numcon_() )

    initial_numcone = ( self._task_1numcone_() )

    initial_numbarvar = ( self._task_1numbarvar_() )

    try:
      first_con = ( self._task_1append_1con_I(numcon) )

      last_con = (first_con + numcon)

      first_slack = ( self._task_1append_1var_I(numcon) )

      last_slack = (first_slack + numcon)

      ptr = ([ 0l for _autovar_634 in xrange((numcon + 1)) ])

      subj = ([ 0 for _autovar_635 in xrange(nlinnz) ])

      cof = ([ 0.0 for _autovar_636 in xrange(nlinnz) ])

      if   (nlinvar > 0):
        q = 0l

        # src/fusion/Model.mbi(365:13-395:13)
        for p in xrange(0,numcon):
          # { @ src/fusion/Model.mbi(366:13-395:13)
          cptr = ptr[p]

          if   (p == pinst[q]):
            ptre = tmpptrb[(q + 1)]

            k = tmpptrb[q]

            # src/fusion/Model.mbi(371:37-83)
            while ((k < ptre) and (tmpsubj[permj[k]] < 0)):
              k += 1
            if   (k < ptre):
              subj[cptr] = tmpsubj[permj[k]]
              cof[cptr] = vcof[permj[k]]
              k += 1
              # src/fusion/Model.mbi(378:19-389:19)
              while (k < ptre):
                if   (tmpsubj[permj[k]] == subj[cptr]):
                  cof[cptr] = (cof[cptr] + vcof[permj[k]])
                else:
                  cptr += 1
                  subj[cptr] = tmpsubj[permj[k]]
                  cof[cptr] = vcof[permj[k]]
                k += 1
              cptr += 1
            q += 1
          ptr[(p + 1)] = cptr
          # } @ src/fusion/Model.mbi(366:13-395:13)
        ( self._task_1putarowslice_II_3L_3I_3F(first_con,last_con,ptr,subj,cof) )
      b = ([ 0.0 for _autovar_637 in xrange(numcon) ])

      if   (bfix != None):
        # src/fusion/Model.mbi(403:13-68)
        for i in xrange(0,int(len(perm))):
          b[pinst[i]] = (- bfix[perm[i]])
      ( self._task_1con_1putboundslice_1fx_II_3F(first_con,last_con,b) )
      if   (nsdpvar > 0):
        # src/fusion/Model.mbi(409:13-457:13)
        for p in xrange(0,int(len(perm))):
          # { @ src/fusion/Model.mbi(410:13-457:13)
          p0 = ptrb[perm[p]]

          p1 = ptrb[(perm[p] + 1)]

          pe = p0

          # src/fusion/Model.mbi(413:28-75)
          while ((pe < p1) and (tmpsubj[permj[pe]] < 0)):
            pe += 1
          if   (p0 < pe):
            barvaridx_ = tmpsubj[permj[p0]]

            # src/fusion/Model.mbi(418:17-455:17)
            while (p0 < pe):
              pb = p0

              # src/fusion/Model.mbi(421:19-76)
              while ((p0 < pe) and (tmpsubj[permj[p0]] == barvaridx_)):
                p0 += 1
              barvaridx = (- (barvaridx_ + 1))

              ( CommonTools._argQsort__3L_3I_3ILL (permj,tmpbarsubi,tmpbarsubj,pb,p0) )
              nunique_nz = 1

              # src/fusion/Model.mbi(427:19-432:24)
              for i in xrange((pb + 1),p0):
                if   ((tmpbarsubi[permj[i]] != tmpbarsubi[permj[(i - 1)]]) or (tmpbarsubj[permj[i]] != tmpbarsubj[permj[(i - 1)]])):
                  nunique_nz += 1
              barmxsubi = ([ 0 for _autovar_638 in xrange(nunique_nz) ])

              barmxsubj = ([ 0 for _autovar_639 in xrange(nunique_nz) ])

              barmxval = ([ 0.0 for _autovar_640 in xrange(nunique_nz) ])

              # { @ src/fusion/Model.mbi(434:19-449:19)
              q = (- 1)

              prvi = (- 1)

              prvj = 0

              # src/fusion/Model.mbi(436:21-448:23)
              for i in xrange(pb,p0):
                if   ((tmpbarsubi[permj[i]] == prvi) and (tmpbarsubj[permj[i]] == prvj)):
                  barmxval[q] = (barmxval[q] + vcof[permj[i]])
                else:
                  q += 1
                  barmxsubi[q] = tmpbarsubi[permj[i]]
                  barmxsubj[q] = tmpbarsubj[permj[i]]
                  barmxval[q] = vcof[permj[i]]
                  prvi = tmpbarsubi[permj[i]]
                  prvj = tmpbarsubj[permj[i]]
              # } @ src/fusion/Model.mbi(434:19-449:19)
              barvardim = ( self._task_1barvardim_I(barvaridx) )

              baraijidx = ( self._task_1append_1barmatrix_I_3I_3I_3F(barvardim,barmxsubi,barmxsubj,barmxval) )

              ( self._task_1putbaraij_III(int((pinst[p] + first_con)),barvaridx,baraijidx) )
          # } @ src/fusion/Model.mbi(410:13-457:13)
      first_cone = ( self._task_1append_1barvar_II(n,m) )

      # { @ src/fusion/Model.mbi(462:11-478:11)
      barmsubi = ([ 0 for _autovar_641 in xrange(1) ])

      barmsubj = ([ 0 for _autovar_642 in xrange(1) ])

      barmval = ([ 0.0 for _autovar_643 in xrange(1) ])

      # src/fusion/Model.mbi(467:13-477:15)
      for i in xrange(0,n):
        # src/fusion/Model.mbi(468:15-477:15)
        for j in xrange(0,(i + 1)):
          # { @ src/fusion/Model.mbi(469:15-477:15)
          barmsubi[0] = i
          barmsubj[0] = j
          barmval[0] = (- 1.0)
          barmidx = ( self._task_1append_1barmatrix_I_3I_3I_3F(n,barmsubi,barmsubj,barmval) )

          # src/fusion/Model.mbi(472:17-476:17)
          for k in xrange(0,m):
            # { @ src/fusion/Model.mbi(473:17-476:17)
            p = (((((k * n) * (n + 1)) / 2) + ((i * (i + 1)) / 2)) + j)

            ( self._task_1putbaraij_III((first_con + p),(first_cone + k),barmidx) )
            # } @ src/fusion/Model.mbi(473:17-476:17)
          # } @ src/fusion/Model.mbi(469:15-477:15)
      # } @ src/fusion/Model.mbi(462:11-478:11)
      if   (name != None):
        sb = mosek.fusion.Utils.StringBuffer()

        p = 0

        # src/fusion/Model.mbi(485:13-492:17)
        for k in xrange(0,m):
          # src/fusion/Model.mbi(486:15-492:17)
          for i in xrange(0,n):
            # src/fusion/Model.mbi(487:17-492:17)
            for j in xrange(0,(i + 1)):
              # { @ src/fusion/Model.mbi(488:17-492:17)
              ( ( ( ( ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_I(k) )._a_S(",") )._a_I(i) )._a_S(",") )._a_I(j) )._a_S("]") )
              ( self._task_1con_1name_IS((p + first_con),( sb._toString_() )) )
              p += 1
              # } @ src/fusion/Model.mbi(488:17-492:17)
        # src/fusion/Model.mbi(494:13-495:105)
        for j in xrange(0,m):
          ( self._task_1barvar_1name_IS((first_cone + j),( ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_I(j) )._a_S("].coneslack") )._toString_() )) )
      shape = None

      if   (m == 1):
        shape = mosek.fusion.NDSet(n,n)
      else:
        shape = mosek.fusion.NDSet(n,n,m)
      res = mosek.fusion.PSDConstraint(self,name,shape,( Utils.Tools._range_II (first_con,last_con) ),n,first_cone,m,ptr,subj,cof,b,None,None,None)
      ( self._addConstraint_SOmosek_fusion_Constraint_2(name,res) )
      return res
    finally:
      if   (res == None):
        ( self._task_1cleanup_IIII(initial_numvar,initial_numcon,initial_numcone,initial_numbarvar) )
  @staticmethod
  def _matchargs_nonsym_1sdpconstraint_SOmosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(520:16-710:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("nonsym_sdpconstraint(basestring,mosek.fusion.Expression,mosek.fusion.PSDDomain)")
  def __nonsym_1sdpconstraint_SOmosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(self,name,expr,dom):
    e = ( expr._eval_() )

    if   ((not ((e.shape.nd == 2) or (e.shape.nd == 3))) or (( e.shape._dim_I(0) ) != ( e.shape._dim_I(1) ))):
      raise mosek.fusion.DomainError("Invalid expression shape for semidefinite constraint")
    n = ( e.shape._dim_I(0) )

    m = 1

    if   (e.shape.nd > 2):
      m = ( e.shape._dim_I(2) )
    numcon = (((m * n) * (n + 1)) / 2)

    if   ((dom._shape != None) and ((( dom._shape._dim_I(0) ) != n) or (( dom._shape._dim_I(2) ) != m))):
      raise mosek.fusion.DomainError("Expression shape does not match domain")
    if   (e.inst == None):
      inst = ([ 0l for _autovar_644 in xrange((((n * (n + 1)) / 2) * m)) ])

      ptrb = ([ 0l for _autovar_645 in xrange(((((n * (n + 1)) / 2) * m) + 1)) ])

      cof = ([ 0.0 for _autovar_646 in xrange(int(len(e.subj))) ])

      subj = ([ 0l for _autovar_647 in xrange(int(len(e.subj))) ])

      perm = ( Utils.Tools._range_L (long(len(inst))) )

      bfix = None

      # { @ src/fusion/Model.mbi(546:11-563:11)
      p = 0

      # src/fusion/Model.mbi(548:13-561:17)
      for k in xrange(0,m):
        # src/fusion/Model.mbi(549:15-561:17)
        for i in xrange(0,n):
          # src/fusion/Model.mbi(550:17-561:17)
          for j in xrange(0,(i + 1)):
            # { @ src/fusion/Model.mbi(551:17-561:17)
            idx = long(((((k * n) * n) + (i * n)) + j))

            idx2 = long(((((k * n) * n) + (j * n)) + i))

            if   (i == j):
              ptrb[(p + 1)] = (e.ptrb[(idx + 1)] - e.ptrb[idx])
            else:
              ptrb[(p + 1)] = (((e.ptrb[(idx + 1)] - e.ptrb[idx]) + e.ptrb[(idx2 + 1)]) - e.ptrb[idx2])
            inst[p] = idx
            p += 1
            # } @ src/fusion/Model.mbi(551:17-561:17)
      # src/fusion/Model.mbi(562:13-68)
      for i in xrange(0,numcon):
        ptrb[(i + 1)] = (ptrb[(i + 1)] + ptrb[i])
      # } @ src/fusion/Model.mbi(546:11-563:11)
      if   (e.bfix != None):
        p = 0

        bfix = ([ 0.0 for _autovar_648 in xrange(int(len(inst))) ])
        # src/fusion/Model.mbi(569:13-580:17)
        for k in xrange(0,m):
          # src/fusion/Model.mbi(570:15-580:17)
          for i in xrange(0,n):
            # src/fusion/Model.mbi(571:17-580:17)
            for j in xrange(0,(i + 1)):
              # { @ src/fusion/Model.mbi(572:17-580:17)
              idx = long(((((k * n) * n) + (i * n)) + j))

              idx2 = long(((((k * n) * n) + (j * n)) + i))

              if   (i == j):
                bfix[p] = e.bfix[idx]
              else:
                bfix[p] = (0.5 * (e.bfix[idx] + e.bfix[idx2]))
              p += 1
              # } @ src/fusion/Model.mbi(572:17-580:17)
      # { @ src/fusion/Model.mbi(583:11-608:11)
      p = 0

      # src/fusion/Model.mbi(585:13-607:17)
      for k in xrange(0,m):
        # src/fusion/Model.mbi(586:15-607:17)
        for i in xrange(0,n):
          # src/fusion/Model.mbi(587:17-607:17)
          for j in xrange(0,(i + 1)):
            # { @ src/fusion/Model.mbi(588:17-607:17)
            idx = ((((k * n) * n) + (i * n)) + j)

            idx2 = ((((k * n) * n) + (j * n)) + i)

            if   (i == j):
              ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[idx],subj,ptrb[p],(e.ptrb[(idx + 1)] - e.ptrb[idx])) )
              ( Utils.Tools._arraycopy__3FL_3FLL (e.cof,e.ptrb[idx],cof,ptrb[p],(e.ptrb[(idx + 1)] - e.ptrb[idx])) )
            else:
              nnz1 = (e.ptrb[(idx + 1)] - e.ptrb[idx])

              nnz2 = (e.ptrb[(idx2 + 1)] - e.ptrb[idx2])

              ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[idx],subj,ptrb[p],nnz1) )
              ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[idx],subj,(ptrb[p] + nnz1),nnz2) )
              # src/fusion/Model.mbi(603:21-93)
              for q in xrange(0l,nnz1):
                cof[(ptrb[p] + q)] = (0.5 * e.cof[(e.ptrb[idx] + q)])
              # src/fusion/Model.mbi(604:21-93)
              for q in xrange(0l,nnz2):
                cof[((ptrb[p] + nnz1) + q)] = (0.5 * e.cof[(e.ptrb[idx2] + q)])
            p += 1
            # } @ src/fusion/Model.mbi(588:17-607:17)
      # } @ src/fusion/Model.mbi(583:11-608:11)
      return ( self.__sdptrilcon_SII_3L_3L_3L_3L_3F_3FOmosek_fusion_Variable_2(name,n,m,ptrb,inst,perm,subj,cof,bfix,e.x) )
    else:
      ptrk = ([ 0l for _autovar_649 in xrange((m + 1)) ])

      # src/fusion/Model.mbi(615:11-69)
      for i in xrange(0,int(len(e.inst))):
        ptrk[((e.inst[i] / (n * n)) + 1)] += 1
      # src/fusion/Model.mbi(616:11-69)
      for i in xrange(0,int(len(ptrk))):
        ptrk[(i + 1)] = (ptrk[(i + 1)] + ptrk[i])
      trilinst = ( Utils.Tools._arraycopy__3L (e.inst) )

      # src/fusion/Model.mbi(619:11-626:11)
      for p in xrange(0,int(len(trilinst))):
        # { @ src/fusion/Model.mbi(620:11-626:11)
        k = (e.inst[p] / (n * n))

        i = ((e.inst[p] / n) % n)

        j = (e.inst[p] % n)

        if   (j > i):
          trilinst[p] = ((((k * n) * n) + (j * n)) + i)
        else:
          trilinst[p] = e.inst[p]
        # } @ src/fusion/Model.mbi(620:11-626:11)
      trilperm = ( Utils.Tools._range_L (long(len(trilinst))) )

      trilptrb = ([ 0l for _autovar_650 in xrange(((m * n) + 1)) ])

      ( Sort._argTransposeSort__3L_3LIII_3L (trilperm,trilptrb,m,n,n,trilinst) )
      ( Sort._argTransposeSort__3L_3LIII_3L (trilperm,trilptrb,(m * n),n,1,trilinst) )
      nunique = 0

      if   (int(len(trilperm)) > 0):
        # src/fusion/Model.mbi(640:13-644:14)
        for i in xrange(1,int(len(trilperm))):
          if   (trilinst[trilperm[i]] > trilinst[trilperm[(i - 1)]]):
            nunique += 1
      if   (int(len(trilinst)) == nunique):
        # src/fusion/Model.mbi(649:13-66)
        for i in xrange(0,int(len(e.cof))):
          e.cof[i] = (0.5 * e.cof[i])
        return ( self.__sdptrilcon_SII_3L_3L_3L_3L_3F_3FOmosek_fusion_Variable_2(name,n,m,e.ptrb,trilinst,trilperm,e.subj,e.cof,e.bfix,e.x) )
      else:
        ptrb = ([ 0l for _autovar_651 in xrange((nunique + 1)) ])

        inst = ([ 0l for _autovar_652 in xrange(nunique) ])

        subj = ([ 0l for _autovar_653 in xrange(int(len(e.subj))) ])

        cof = ([ 0.0 for _autovar_654 in xrange(int(len(e.subj))) ])

        bfix = ([ 0.0 for _autovar_655 in xrange(nunique) ])

        # { @ src/fusion/Model.mbi(662:13-670:13)
        p = 0

        ptrb[1] = (e.ptrb[(trilperm[0] + 1)] - e.ptrb[trilperm[0]])
        inst[0] = trilinst[trilperm[0]]
        # src/fusion/Model.mbi(664:15-669:15)
        for i in xrange(1,int(len(trilinst))):
          # { @ src/fusion/Model.mbi(665:15-669:15)
          if   (trilinst[trilperm[i]] != trilinst[trilperm[(i - 1)]]):
            p += 1
          ptrb[(p + 1)] = ((ptrb[(p + 1)] + e.ptrb[(trilperm[i] + 1)]) - e.ptrb[trilperm[i]])
          inst[p] = trilinst[trilperm[i]]
          # } @ src/fusion/Model.mbi(665:15-669:15)
        # } @ src/fusion/Model.mbi(662:13-670:13)
        # { @ src/fusion/Model.mbi(673:13-689:13)
        p = 0

        # src/fusion/Model.mbi(675:15-688:15)
        for i in xrange(0,int(len(trilperm))):
          # { @ src/fusion/Model.mbi(676:15-688:15)
          if   ((i > 0) and (trilinst[trilperm[i]] != trilinst[trilperm[(i - 1)]])):
            p += 1
          numnz = (e.ptrb[(trilperm[i] + 1)] - e.ptrb[trilperm[i]])

          ( Utils.Tools._arraycopy__3LL_3LLL (e.subj,e.ptrb[trilperm[i]],subj,ptrb[p],numnz) )
          idxi = ((e.inst[trilperm[i]] / n) % n)

          idxj = (e.inst[trilperm[i]] % n)

          if   (idxi == idxj):
            ( Utils.Tools._arraycopy__3FL_3FLL (e.cof,e.ptrb[trilperm[i]],cof,ptrb[p],long(numnz)) )
          else:
            # src/fusion/Model.mbi(685:19-686:72)
            for j in xrange(0l,numnz):
              cof[(ptrb[p] + j)] = (0.5 * e.cof[(e.ptrb[trilperm[i]] + j)])
          ptrb[p] = (ptrb[p] + numnz)
          # } @ src/fusion/Model.mbi(676:15-688:15)
        # } @ src/fusion/Model.mbi(673:13-689:13)
        if   (e.bfix != None):
          bfix = ([ 0.0 for _autovar_656 in xrange(int(len(inst))) ])
          p = 0

          # src/fusion/Model.mbi(695:15-704:15)
          for i in xrange(0,int(len(trilperm))):
            # { @ src/fusion/Model.mbi(696:15-704:15)
            if   ((i > 0) and (trilinst[trilperm[i]] != trilinst[trilperm[(i - 1)]])):
              p += 1
            idxi = ((e.inst[trilperm[i]] / n) % n)

            idxj = (e.inst[trilperm[i]] % n)

            if   (idxi == idxj):
              bfix[p] = (bfix[p] + e.bfix[trilperm[i]])
            else:
              bfix[p] = (bfix[p] + (0.5 * e.bfix[trilperm[i]]))
            # } @ src/fusion/Model.mbi(696:15-704:15)
        return ( self.__sdptrilcon_SII_3L_3L_3L_3L_3F_3FOmosek_fusion_Variable_2(name,n,m,ptrb,inst,( Utils.Tools._range_L (long(len(inst))) ),subj,cof,bfix,e.x) )
  @staticmethod
  def _matchargs_constraint_1_SOmosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(714:16-758:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint_(basestring,mosek.fusion.Expression,mosek.fusion.PSDDomain)")
  def __constraint_1_SOmosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(self,name,expr,dom):

    if   (dom._key == PSDKey.IsSymPSD):
      return ( self.__nonsym_1sdpconstraint_SOmosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(name,expr,dom) )
    elif (dom._key == PSDKey.IsTrilPSD):
      e = ( expr._eval_() )

      if   ((not ((e.shape.nd == 2) or (e.shape.nd == 3))) or (( e.shape._dim_I(0) ) != ( e.shape._dim_I(1) ))):
        raise mosek.fusion.DomainError("Invalid expression shape for semidefinite constraint")
      n = ( e.shape._dim_I(0) )

      m = 1

      if   (e.shape.nd > 2):
        m = ( e.shape._dim_I(2) )
      ntrilnz = (((m * n) * (n + 1)) / 2)

      if   ((dom._shape != None) and ((( dom._shape._dim_I(0) ) != n) or (( dom._shape._dim_I(2) ) != m))):
        raise mosek.fusion.DomainError("Expression shape does not match domain")
      perm = ([ 0l for _autovar_657 in xrange(ntrilnz) ])

      # { @ src/fusion/Model.mbi(738:11-747:11)
      p = 0

      # src/fusion/Model.mbi(740:13-746:17)
      for k in xrange(0,m):
        # src/fusion/Model.mbi(741:15-746:17)
        for i in xrange(0,n):
          # src/fusion/Model.mbi(742:17-746:17)
          for j in xrange(0,(i + 1)):
            # { @ src/fusion/Model.mbi(743:17-746:17)
            perm[p] = long(((((k * n) * n) + (i * n)) + j))
            p += 1
            # } @ src/fusion/Model.mbi(743:17-746:17)
      # } @ src/fusion/Model.mbi(738:11-747:11)
      bfix = e.bfix

      if   (bfix == None):
        bfix = ([ 0.0 for _autovar_658 in xrange((int(len(e.ptrb)) - 1)) ])
      return ( self.__sdptrilcon_SII_3L_3L_3L_3L_3F_3FOmosek_fusion_Variable_2(name,n,m,e.ptrb,e.inst,perm,e.subj,e.cof,bfix,e.x) )
    elif (dom._key == PSDKey.IsLinPSD):
      return None
    else:
      raise mosek.fusion.UnexpectedError("Invalid domain")
  @staticmethod
  def _matchargs_constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(770:16-1161:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint_(basestring,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.Domain)")
  def __constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(self,name,shp,expr,dom):
    res = None


    if   ((name != None) and ( self._hasConstraint_S(name) )):
      raise mosek.fusion.NameError(( ( ( ( mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '") )._a_S(name) )._a_S("'") )._toString_() ))
    if   (shp != None):
      shape = shp
    elif (dom._shape != None):
      shape = dom._shape
    else:
      shape = expr._shape
    size = int(shape._size)

    if   (((dom._shape != None) and (not ( dom._match_1shape_Omosek_fusion_Set_2(shape) ))) or ((expr._shape != None) and (not ( shape._compare_Omosek_fusion_Set_2(expr._shape) )))):
      raise mosek.fusion.DimensionError("Mismatching shape and domain")
    e = ( expr._eval_() )

    einst = e.inst

    if   (einst == None):
      einst = ([ 0l for _autovar_659 in xrange(size) ])
      # src/fusion/Model.mbi(792:77-124)
      for i in xrange(0,int(len(einst))):
        einst[i] = long(i)
    varidxs = None

    ptrb = None

    cof = None

    numbarvar = 0

    numscalarvar = 0

    tmpvaridxs = None

    tmpbarvarsubi = None

    tmpbarvarsubj = None

    # { @ src/fusion/Model.mbi(808:9-856:9)
    num = int(len(e.subj))

    tmpvaridxs = ([ 0 for _autovar_660 in xrange(num) ])
    tmpbarvarsubi = ([ 0 for _autovar_661 in xrange(num) ])
    tmpbarvarsubj = ([ 0 for _autovar_662 in xrange(num) ])
    if   (num > 0):
      ( e.x._inst__3LIILL_3I_3I_3I(e.subj,0,num,0l,0l,tmpvaridxs,tmpbarvarsubi,tmpbarvarsubj) )
    numscalarvar = 0
    # src/fusion/Model.mbi(818:11-821:22)
    for i in xrange(0,num):
      if   (tmpvaridxs[i] >= 0):
        numscalarvar += 1
    numbarvar = (num - numscalarvar)
    if   (numscalarvar > 0):
      varidxs = ([ 0 for _autovar_663 in xrange(numscalarvar) ])
    if   ((numbarvar == 0) and (size == (int(len(e.ptrb)) - 1))):
      varidxs = tmpvaridxs
      ptrb = e.ptrb
      cof = e.cof
    else:
      vari = 0

      varidxs = ([ 0 for _autovar_664 in xrange(numscalarvar) ])
      cof = ([ 0.0 for _autovar_665 in xrange(numscalarvar) ])
      ptrb = ([ 0l for _autovar_666 in xrange((size + 1)) ])
      l = 0

      # src/fusion/Model.mbi(838:13-854:15)
      for i in xrange(0,(int(len(ptrb)) - 1)):
        if   ((l >= int(len(einst))) or (einst[l] > i)):
          ptrb[(i + 1)] = ptrb[i]
        else:
          # src/fusion/Model.mbi(843:17-851:17)
          for k in xrange(e.ptrb[l],e.ptrb[(l + 1)]):
            # { @ src/fusion/Model.mbi(844:17-851:17)
            if   (tmpvaridxs[k] >= 0):
              varidxs[vari] = tmpvaridxs[k]
              cof[vari] = e.cof[k]
              vari += 1
            # } @ src/fusion/Model.mbi(844:17-851:17)
          ptrb[(i + 1)] = long(vari)
          l += 1
    # } @ src/fusion/Model.mbi(808:9-856:9)
    lptrb = ( Utils.Tools._arraycopy__3L (ptrb) )

    initial_numvar = ( self._task_1numvar_() )

    initial_numcon = ( self._task_1numcon_() )

    initial_numcone = ( self._task_1numcone_() )

    initial_numbarvar = ( self._task_1numbarvar_() )

    try:
      numcon = size

      first = ( self._task_1append_1con_I(numcon) )

      last = (first + numcon)

      if   (name != None):
        sb = mosek.fusion.Utils.StringBuffer()

        # src/fusion/Model.mbi(874:13-878:13)
        for i in xrange(0,numcon):
          # { @ src/fusion/Model.mbi(875:13-878:13)
          ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_I(i) )._a_S("]") )
          ( self._task_1con_1name_IS((i + first),( sb._toString_() )) )
          # } @ src/fusion/Model.mbi(875:13-878:13)
      if   (numscalarvar > 0):
        ( self._task_1putarowslice_II_3L_3I_3F(first,last,ptrb,varidxs,cof) )
      barsubi = None

      barsubj = None

      barmatidx = None

      numuniquebaraij = 0

      if   (numbarvar > 0):
        barsubi_ = ([ 0 for _autovar_667 in xrange((int(len(e.ptrb)) - 1)) ])

        barsubj_ = ([ 0 for _autovar_668 in xrange((int(len(e.ptrb)) - 1)) ])

        barmatidx_ = ([ 0 for _autovar_669 in xrange((int(len(e.ptrb)) - 1)) ])

        # src/fusion/Model.mbi(904:13-1018:13)
        for i in xrange(0,(int(len(e.ptrb)) - 1)):
          # { @ src/fusion/Model.mbi(905:13-1018:13)
          numbarinz = 0l

          # src/fusion/Model.mbi(911:15-915:19)
          for k in xrange(e.ptrb[i],e.ptrb[(i + 1)]):
            if   (tmpvaridxs[k] < 0):
              numbarinz += 1
          if   (numbarinz == 0):
            barsubi_[i] = ([ 0 for _autovar_670 in xrange(0) ])
            barsubj_[i] = ([ 0 for _autovar_671 in xrange(0) ])
            barmatidx_[i] = ([ 0 for _autovar_672 in xrange(0) ])
          else:
            bariperm = ([ 0l for _autovar_673 in xrange(numbarinz) ])

            # { @ src/fusion/Model.mbi(924:17-932:17)
            barvari = 0

            # src/fusion/Model.mbi(926:19-933:20)
            for k in xrange(e.ptrb[i],e.ptrb[(i + 1)]):
              if   (tmpvaridxs[k] < 0):
                bariperm[barvari] = long(k)
                barvari += 1
            # } @ src/fusion/Model.mbi(924:17-932:17)
            ( CommonTools._argQsort__3L_3I_3ILL (bariperm,tmpvaridxs,None,0l,long(numbarinz)) )
            numUniqueBarvarCon_i = 1

            # src/fusion/Model.mbi(938:17-943:27)
            for p in xrange(1l,numbarinz):
              if   (tmpvaridxs[bariperm[p]] != tmpvaridxs[bariperm[(p - 1)]]):
                numUniqueBarvarCon_i += 1
            barsubi_[i] = ([ 0 for _autovar_674 in xrange(numUniqueBarvarCon_i) ])
            barsubj_[i] = ([ 0 for _autovar_675 in xrange(numUniqueBarvarCon_i) ])
            barmatidx_[i] = ([ 0 for _autovar_676 in xrange(numUniqueBarvarCon_i) ])
            # { @ src/fusion/Model.mbi(946:17-1016:17)
            conivarnum = 0

            barvari = 0

            # src/fusion/Model.mbi(949:19-1015:19)
            while (barvari < numbarinz):
              barptrb = barvari

              barvari += 1
              # src/fusion/Model.mbi(953:21-127)
              while ((barvari < numbarinz) and (tmpvaridxs[bariperm[barvari]] == tmpvaridxs[bariperm[(barvari - 1)]])):
                barvari += 1
              numbarvarijnz = (barvari - barptrb)

              ( CommonTools._argQsort__3L_3I_3ILL (bariperm,tmpbarvarsubi,tmpbarvarsubj,long(barptrb),long(barvari)) )
              numuniquenz = 1

              # src/fusion/Model.mbi(963:21-970:21)
              for k in xrange((barptrb + 1),barvari):
                # { @ src/fusion/Model.mbi(964:21-970:21)
                idx = bariperm[k]

                pidx = bariperm[(k - 1)]

                if   ((tmpbarvarsubi[idx] != tmpbarvarsubi[pidx]) or (tmpbarvarsubj[idx] != tmpbarvarsubj[pidx])):
                  numuniquenz += 1
                # } @ src/fusion/Model.mbi(964:21-970:21)
              l = 0

              barvarijsubi = ([ 0 for _autovar_677 in xrange(numuniquenz) ])

              barvarijsubj = ([ 0 for _autovar_678 in xrange(numuniquenz) ])

              barvarijcof = ([ 0.0 for _autovar_679 in xrange(numuniquenz) ])

              barvarijsubi[0] = tmpbarvarsubi[bariperm[barptrb]]
              barvarijsubj[0] = tmpbarvarsubj[bariperm[barptrb]]
              if   (barvarijsubi[0] == barvarijsubj[0]):
                barvarijcof[0] = e.cof[bariperm[barptrb]]
              else:
                barvarijcof[0] = (0.5 * e.cof[bariperm[barptrb]])
              # src/fusion/Model.mbi(987:21-1002:21)
              for k in xrange((barptrb + 1),barvari):
                # { @ src/fusion/Model.mbi(988:21-1002:21)
                idx = bariperm[k]

                pidx = bariperm[(k - 1)]

                if   ((tmpbarvarsubi[idx] != tmpbarvarsubi[pidx]) or (tmpbarvarsubj[idx] != tmpbarvarsubj[pidx])):
                  l += 1
                  barvarijsubi[l] = tmpbarvarsubi[idx]
                  barvarijsubj[l] = tmpbarvarsubj[idx]
                if   (barvarijsubi[l] == barvarijsubj[l]):
                  barvarijcof[l] = (barvarijcof[l] + e.cof[idx])
                else:
                  barvarijcof[l] = (barvarijcof[l] + (0.5 * e.cof[idx]))
                # } @ src/fusion/Model.mbi(988:21-1002:21)
              baraj = (- (tmpvaridxs[bariperm[barptrb]] + 1))

              baraijdim = ( self._task_1barvardim_I(baraj) )

              baraijidx = ( self._task_1append_1barmatrix_I_3I_3I_3F(baraijdim,barvarijsubi,barvarijsubj,barvarijcof) )

              ( self._task_1putbaraij_III((int(einst[i]) + first),baraj,baraijidx) )
              barsubi_[i][conivarnum] = (int(einst[i]) + first)
              barsubj_[i][conivarnum] = baraj
              barmatidx_[i][conivarnum] = baraijidx
              conivarnum += 1
              numuniquebaraij += 1
            # } @ src/fusion/Model.mbi(946:17-1016:17)
          # } @ src/fusion/Model.mbi(905:13-1018:13)
        barsubi = ([ 0 for _autovar_680 in xrange(numuniquebaraij) ])
        barsubj = ([ 0 for _autovar_681 in xrange(numuniquebaraij) ])
        barmatidx = ([ 0 for _autovar_682 in xrange(numuniquebaraij) ])
        # { @ src/fusion/Model.mbi(1025:13-1039:13)
        k = 0

        # src/fusion/Model.mbi(1027:15-1040:16)
        for i in xrange(0,(int(len(e.ptrb)) - 1)):
          if   (barsubi_[i] != None):
            num = int(len(barsubi_[i]))

            ( Utils.Tools._arraycopy__3II_3III (barsubi_[i],0,barsubi,k,num) )
            ( Utils.Tools._arraycopy__3II_3III (barsubj_[i],0,barsubj,k,num) )
            # src/fusion/Model.mbi(1034:19-1035:65)
            for l in xrange(0,int(len(barmatidx_[i]))):
              barmatidx[(k + l)] = ([ barmatidx_[i][l]])
            k = (k + num)
        # } @ src/fusion/Model.mbi(1025:13-1039:13)
      nativeindexes = ( Utils.Tools._range_II (first,last) )

      rhs = ([ 0.0 for _autovar_683 in xrange(int(len(nativeindexes))) ])

      # src/fusion/Model.mbi(1047:11-1048:41)
      for i in xrange(0,int(len(rhs))):
        rhs[i] = ( dom._get_1rhs_1item_I(i) )
      if   ((e.bfix != None) and (rhs != None)):
        # src/fusion/Model.mbi(1051:13-1052:56)
        for i in xrange(0,int(len(e.bfix))):
          rhs[einst[i]] = (rhs[einst[i]] - e.bfix[i])
      key = dom._key

      if   ((((key == RelationKey.IsFree) or (key == RelationKey.LessThan)) or (key == RelationKey.GreaterThan)) or (key == RelationKey.EqualsTo)):
        if   (key == RelationKey.IsFree):
          ( self._task_1con_1putboundslice_1fr_II(first,last) )
        elif (key == RelationKey.LessThan):
          ( self._task_1con_1putboundslice_1up_II_3F(first,last,rhs) )
        elif (key == RelationKey.GreaterThan):
          ( self._task_1con_1putboundslice_1lo_II_3F(first,last,rhs) )
        else:
          ( self._task_1con_1putboundslice_1fx_II_3F(first,last,rhs) )
        res = mosek.fusion.LinearConstraint(self,name,dom,shape,nativeindexes,lptrb,varidxs,cof,e.bfix,barsubi,barsubj,barmatidx)
      elif ((key == RelationKey.InQCone) or (key == RelationKey.InRotatedQCone)):


        if   (shape.nd == 2):
          numcone = ( shape._dim_I(0) )
          conesize = ( shape._dim_I(1) )
        else:
          numcone = 1
          conesize = int(shape._size)
        numslack = (conesize * numcone)

        b = ([ 0.0 for _autovar_684 in xrange(numslack) ])

        if   (e.bfix != None):
          # src/fusion/Model.mbi(1093:15-1094:42)
          for i in xrange(0,int(len(e.bfix))):
            b[einst[i]] = (- e.bfix[i])
        ( self._task_1con_1putboundslice_1fx_II_3F(first,last,b) )
        firstslack = ( self._task_1append_1var_I(numslack) )

        ( self.__natvarmap_1ensure_I(numslack) )
        self.__natvarmap_num = (self.__natvarmap_num + numslack)
        if   (name != None):
          sb = mosek.fusion.Utils.StringBuffer()

          # src/fusion/Model.mbi(1105:15-1109:15)
          for i in xrange(0,numslack):
            # { @ src/fusion/Model.mbi(1106:15-1109:15)
            ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_S(( shape._indexToString_L(long(i)) )) )._a_S("].coneslack") )
            ( self._task_1var_1name_IS((i + firstslack),( sb._toString_() )) )
            # } @ src/fusion/Model.mbi(1106:15-1109:15)
        lastslack = (firstslack + numslack)

        ( self._task_1putaijlist__3I_3I_3FL(( Utils.Tools._range_II (first,last) ),( Utils.Tools._range_II (firstslack,lastslack) ),( Utils.Tools._makevector_FI ((- 1.0),numslack) ),long(numslack)) )
        ( self._task_1var_1putboundslice_1fr_II(firstslack,lastslack) )

        if   (dom._key == RelationKey.InQCone):
          firstcone = ( self._task_1append_1quadcone_III(conesize,firstslack,numcone) )
        else:
          firstcone = ( self._task_1append_1rquadcone_III(conesize,firstslack,numcone) )
        if   (name != None):
          sb = mosek.fusion.Utils.StringBuffer()

          # src/fusion/Model.mbi(1130:15-1134:15)
          for i in xrange(0,numcone):
            # { @ src/fusion/Model.mbi(1131:15-1134:15)
            ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_I(i) )._a_S("]") )
            ( self._task_1cone_1name_IS((firstcone + i),( sb._toString_() )) )
            # } @ src/fusion/Model.mbi(1131:15-1134:15)
        res = mosek.fusion.ConicConstraint(self,name,dom,shape,( Utils.Tools._range_II (first,last) ),firstslack,lastslack,conesize,firstcone,numcone,lptrb,varidxs,e.cof,e.bfix,barsubi,barsubj,barmatidx)
      else:
        raise mosek.fusion.UnexpectedError("Invalid relation type detected")
      ( self._addConstraint_SOmosek_fusion_Constraint_2(name,res) )
      return res
    finally:
      if   (res == None):
        ( self._task_1cleanup_IIII(initial_numvar,initial_numcon,initial_numcone,initial_numbarvar) )
  @staticmethod
  def _matchargs_constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1181:16-1456:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint_(basestring,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain)")
  def __constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,name,shp,expr,dom):
    res = None

    size = int(( expr._size_() ))


    if   ( self._hasConstraint_S(name) ):
      raise mosek.fusion.NameError(( ( ( ( mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '") )._a_S(name) )._a_S("'") )._toString_() ))
    if   (shp != None):
      if   (not ( dom._match_1shape_Omosek_fusion_Set_2(shp) )):
        raise mosek.fusion.DimensionError("Mismatching shape and domain")
      shape = shp
    else:
      shape = dom._shape
      if   (shape == None):
        shape = mosek.fusion.IntSet(1)
    e = ( expr._eval_() )


    if   (e.inst != None):
      inst = e.inst
    else:
      inst = ( Utils.Tools._range_LL (0l,long(size)) )
    varidxs = None

    ptrb = None

    cof = None

    numbarvar = 0

    numscalarvar = 0

    tmpvaridxs = None

    tmpbarvarsubi = None

    tmpbarvarsubj = None

    # { @ src/fusion/Model.mbi(1225:9-1273:9)
    num = int(len(e.subj))

    tmpvaridxs = ([ 0 for _autovar_685 in xrange(num) ])
    tmpbarvarsubi = ([ 0 for _autovar_686 in xrange(num) ])
    tmpbarvarsubj = ([ 0 for _autovar_687 in xrange(num) ])
    # src/fusion/Model.mbi(1231:11-1232:82)
    i = 0

    while (i < num):
      ( e.x._inst_LL_3I_3I_3I(e.subj[i],long(i),tmpvaridxs,tmpbarvarsubi,tmpbarvarsubj) )
      i += 1
    numscalarvar = 0
    # src/fusion/Model.mbi(1235:11-1238:22)
    i = 0

    while (i < num):
      if   (tmpvaridxs[i] >= 0):
        numscalarvar += 1
      i += 1
    numbarvar = (num - numscalarvar)
    if   (numscalarvar > 0):
      varidxs = ([ 0 for _autovar_688 in xrange(numscalarvar) ])
    if   ((numbarvar == 0) and (e.inst == None)):
      varidxs = tmpvaridxs
      ptrb = e.ptrb
      cof = e.cof
    else:
      vari = 0

      varidxs = ([ 0 for _autovar_689 in xrange(numscalarvar) ])
      cof = ([ 0.0 for _autovar_690 in xrange(numscalarvar) ])
      ptrb = ([ 0l for _autovar_691 in xrange((size + 1)) ])
      # src/fusion/Model.mbi(1257:13-1271:13)
      for j in xrange(0,(int(len(e.ptrb)) - 1)):
        # { @ src/fusion/Model.mbi(1258:13-1271:13)
        i = inst[j]

        ptrb[i] = long(vari)
        # src/fusion/Model.mbi(1261:15-1269:15)
        for k in xrange(e.ptrb[j],e.ptrb[(j + 1)]):
          # { @ src/fusion/Model.mbi(1262:15-1269:15)
          if   (tmpvaridxs[k] >= 0):
            varidxs[vari] = tmpvaridxs[k]
            cof[vari] = e.cof[k]
            vari += 1
          # } @ src/fusion/Model.mbi(1262:15-1269:15)
        ptrb[(int(len(ptrb)) - 1)] = long(vari)
        # } @ src/fusion/Model.mbi(1258:13-1271:13)
    # } @ src/fusion/Model.mbi(1225:9-1273:9)
    lptrb = ([ 0l for _autovar_692 in xrange(int(len(ptrb))) ])

    # src/fusion/Model.mbi(1276:9-1277:36)
    i = 0

    while (i < int(len(ptrb))):
      lptrb[i] = long(ptrb[i])
      i += 1
    initial_numvar = ( self._task_1numvar_() )

    initial_numcone = ( self._task_1numcone_() )

    initial_numcon = ( self._task_1numcon_() )

    initial_numbarvar = ( self._task_1numbarvar_() )

    try:
      numcon = size

      first = ( self._task_1append_1con_I(numcon) )

      last = (first + numcon)

      if   (name != None):
        sb = mosek.fusion.Utils.StringBuffer()

        # src/fusion/Model.mbi(1296:13-1300:13)
        i = 0

        while (i < numcon):
          ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_I(i) )._a_S("]") )
          ( self._task_1con_1name_IS((i + first),( sb._toString_() )) )
          i += 1
      if   (numscalarvar > 0):
        ( self._task_1putarowslice_II_3L_3I_3F(first,last,ptrb,varidxs,cof) )
      barsubi = None

      barsubj = None

      barmatidx = None

      numuniquebaraij = 0

      if   (numbarvar > 0):
        barsubi_ = ([ 0 for _autovar_693 in xrange((int(len(e.ptrb)) - 1)) ])

        barsubj_ = ([ 0 for _autovar_694 in xrange((int(len(e.ptrb)) - 1)) ])

        barmatidx_ = ([ 0 for _autovar_695 in xrange((int(len(e.ptrb)) - 1)) ])

        # src/fusion/Model.mbi(1324:13-1408:13)
        i = 0

        while (i < (int(len(e.ptrb)) - 1)):
          numbarinz = 0l

          # src/fusion/Model.mbi(1327:15-1330:19)
          k = e.ptrb[i]

          while (k < e.ptrb[(i + 1)]):
            if   (tmpvaridxs[k] < 0):
              numbarinz += 1
            k += 1
          if   (numbarinz > 0):
            bariperm = ([ 0l for _autovar_696 in xrange(numbarinz) ])

            # { @ src/fusion/Model.mbi(1333:17-1341:17)
            barvari = 0

            # src/fusion/Model.mbi(1335:19-1342:20)
            k = e.ptrb[i]

            while (k < e.ptrb[(i + 1)]):
              if   (tmpvaridxs[k] < 0):
                bariperm[barvari] = long(k)
                barvari += 1
              k += 1
            # } @ src/fusion/Model.mbi(1333:17-1341:17)
            ( CommonTools._argQsort__3L_3I_3ILL (bariperm,tmpvaridxs,None,0l,numbarinz) )
            # { @ src/fusion/Model.mbi(1345:17-1406:17)
            barvari = 0

            # src/fusion/Model.mbi(1347:19-1405:19)
            while (barvari < numbarinz):
              barptrb = barvari

              barvari += 1
              # src/fusion/Model.mbi(1351:21-127)
              while ((barvari < numbarinz) and (tmpvaridxs[bariperm[barvari]] == tmpvaridxs[bariperm[(barvari - 1)]])):
                barvari += 1
              numbarvarijnz = (barvari - barptrb)

              ( CommonTools._argQsort__3L_3I_3ILL (bariperm,tmpbarvarsubi,tmpbarvarsubj,long(barptrb),long(barvari)) )
              numuniquenz = 1

              # src/fusion/Model.mbi(1360:21-1367:21)
              for k in xrange((barptrb + 1),barvari):
                # { @ src/fusion/Model.mbi(1361:21-1367:21)
                idx = bariperm[k]

                pidx = bariperm[(k - 1)]

                if   ((tmpbarvarsubi[idx] != tmpbarvarsubi[pidx]) or (tmpbarvarsubj[idx] != tmpbarvarsubj[pidx])):
                  numuniquenz += 1
                # } @ src/fusion/Model.mbi(1361:21-1367:21)
              l = 0

              barvarijsubi = ([ 0 for _autovar_697 in xrange(numuniquenz) ])

              barvarijsubj = ([ 0 for _autovar_698 in xrange(numuniquenz) ])

              barvarijcof = ([ 0.0 for _autovar_699 in xrange(numuniquenz) ])

              barvarijsubi[0] = tmpbarvarsubi[bariperm[barptrb]]
              barvarijsubj[0] = tmpbarvarsubj[bariperm[barptrb]]
              if   (barvarijsubi[0] == barvarijsubj[0]):
                barvarijcof[0] = e.cof[bariperm[barptrb]]
              else:
                barvarijcof[0] = (0.5 * e.cof[bariperm[barptrb]])
              # src/fusion/Model.mbi(1382:21-1397:21)
              for k in xrange((barptrb + 1),barvari):
                # { @ src/fusion/Model.mbi(1383:21-1397:21)
                idx = bariperm[k]

                pidx = bariperm[(k - 1)]

                if   ((tmpbarvarsubi[idx] != tmpbarvarsubi[pidx]) or (tmpbarvarsubj[idx] != tmpbarvarsubj[pidx])):
                  l += 1
                  barvarijsubi[l] = tmpbarvarsubi[idx]
                  barvarijsubj[l] = tmpbarvarsubj[idx]
                if   (barvarijsubi[l] == barvarijsubj[l]):
                  barvarijcof[l] = (barvarijcof[l] + e.cof[idx])
                else:
                  barvarijcof[l] = (barvarijcof[l] + (0.5 * e.cof[idx]))
                # } @ src/fusion/Model.mbi(1383:21-1397:21)
              baraj = (- (tmpvaridxs[bariperm[barptrb]] + 1))

              baraijdim = ( self._task_1barvardim_I(baraj) )

              baraijidx = ( self._task_1append_1barmatrix_I_3I_3I_3F(baraijdim,barvarijsubi,barvarijsubj,barvarijcof) )

              ( self._task_1putbaraij_III((i + first),baraj,baraijidx) )
            # } @ src/fusion/Model.mbi(1345:17-1406:17)
          i += 1
      bl = ([ 0.0 for _autovar_700 in xrange((int(len(ptrb)) - 1)) ])

      bu = ([ 0.0 for _autovar_701 in xrange((int(len(ptrb)) - 1)) ])

      if   (e.bfix != None):
        # src/fusion/Model.mbi(1422:15-1428:15)
        for j in xrange(0,(int(len(e.ptrb)) - 1)):
          # { @ src/fusion/Model.mbi(1423:15-1428:15)
          i = inst[j]

          bl[i] = (( dom._get_1lb_1item_L(long(i)) ) - e.bfix[i])
          bu[i] = (( dom._get_1ub_1item_L(long(i)) ) - e.bfix[i])
          # } @ src/fusion/Model.mbi(1423:15-1428:15)
      else:
        # src/fusion/Model.mbi(1432:13-1437:13)
        for j in xrange(0,(int(len(e.ptrb)) - 1)):
          # { @ src/fusion/Model.mbi(1433:13-1437:13)
          i = inst[j]

          bl[i] = ( dom._get_1lb_1item_L(long(i)) )
          bu[i] = ( dom._get_1ub_1item_L(long(i)) )
          # } @ src/fusion/Model.mbi(1433:13-1437:13)
      nativeindexes = ( Utils.Tools._range_II (first,last) )

      ( self._task_1con_1putboundslice_1ra_II_3F_3F(first,last,bl,bu) )
      res = mosek.fusion.RangedConstraint(self,name,shape,dom,nativeindexes,lptrb,varidxs,cof,e.bfix)
    finally:
      if   (res == None):
        ( self._task_1cleanup_IIII(initial_numvar,initial_numcon,initial_numcone,initial_numbarvar) )
    ( self._addConstraint_SOmosek_fusion_Constraint_2(name,res) )
    return res
  @staticmethod
  def _matchargs_variable_1_SOmosek_fusion_Set_2Omosek_fusion_PSDDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1460:16-1497:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable_(basestring,mosek.fusion.Set,mosek.fusion.PSDDomain)")
  def __variable_1_SOmosek_fusion_Set_2Omosek_fusion_PSDDomain_2(self,name,shp,dom):


    if   (shp != None):
      if   ((shp.nd != 2) and (shp.nd != 3)):
        raise mosek.fusion.DimensionError("Invalid shape for semidefinite variables")
      elif (( shp._dim_I(0) ) != ( shp._dim_I(1) )):
        raise mosek.fusion.DimensionError("Invalid shape for semidefinite variables")
      n = ( shp._dim_I(0) )
      if   (shp.nd > 2):
        m = ( shp._dim_I(2) )
      else:
        m = 1
      if   ((dom._shape != None) and ((( dom._shape._dim_I(0) ) != n) or ((dom._shape.nd == 3) and (( dom._shape._dim_I(2) ) != m)))):
        raise mosek.fusion.DomainError("Domain and shape do not match")
    else:
      if   (dom._shape == None):
        raise mosek.fusion.DomainError("Either domain size of shape must be defined")
      else:
        n = ( dom._shape._dim_I(0) )
        m = ( dom._shape._dim_I(2) )
    first_cone = ( self._task_1append_1barvar_II(n,m) )

    res = mosek.fusion.PSDVariable(self,name,n,first_cone,m,( self._numVariables_() ))

    ( self._addVariable_SOmosek_fusion_Variable_2(name,res) )
    return res
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    if not isinstance(args[4],bool): return False
    return True
  # origin: src/fusion/Model.mbi(1502:16-1683:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain,bool)")
  def __variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(self,name,shp,dom,idom,sparse):
    res = None

    mvar = None


    if   ( self._hasVariable_S(name) ):
      raise mosek.fusion.NameError(( ( ( ( mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '") )._a_S(name) )._a_S("'") )._toString_() ))
    if   (shp != None):
      if   (not ( dom._match_1shape_Omosek_fusion_Set_2(shp) )):
        raise mosek.fusion.DimensionError("Mismatching shape and domain")
      shape = shp
    else:
      shape = dom._shape
      if   (shape == None):
        shape = mosek.fusion.IntSet(1)
    initial_numvar = ( self._task_1numvar_() )

    initial_numcon = ( self._task_1numcon_() )

    initial_numcone = ( self._task_1numcone_() )

    initial_numbarvar = ( self._task_1numbarvar_() )

    try:
      nativeindexes = None

      key = dom._key

      if   ((((key == RelationKey.IsFree) or (key == RelationKey.LessThan)) or (key == RelationKey.GreaterThan)) or (key == RelationKey.EqualsTo)):
        numvar = int(shape._size)

        first = 0

        if   (not sparse):
          first = ( self._task_1append_1var_I(numvar) )
          ( self.__natvarmap_1ensure_I(numvar) )
          self.__natvarmap_num = (self.__natvarmap_num + numvar)
          if   (key == RelationKey.IsFree):
            ( self._task_1var_1putboundslice_1fr_II(first,(first + numvar)) )
          else:
            bnds = ([ 0.0 for _autovar_702 in xrange(numvar) ])

            # src/fusion/Model.mbi(1555:17-1556:55)
            for i in xrange(0,numvar):
              bnds[i] = ( dom._get_1rhs_1item_L(long(i)) )
            if   (key == RelationKey.LessThan):
              ( self._task_1var_1putboundslice_1up_II_3F(first,(first + numvar),bnds) )
            elif (key == RelationKey.GreaterThan):
              ( self._task_1var_1putboundslice_1lo_II_3F(first,(first + numvar),bnds) )
            elif (key == RelationKey.EqualsTo):
              ( self._task_1var_1putboundslice_1fx_II_3F(first,(first + numvar),bnds) )
          nativeindexes = ([ 0 for _autovar_703 in xrange(numvar) ])
          # src/fusion/Model.mbi(1566:15-65)
          for i in xrange(0,numvar):
            nativeindexes[i] = (first + i)
          # src/fusion/Model.mbi(1567:15-72)
          for i in xrange(0,numvar):
            self.__natvarmap_idx[(i + first)] = long(i)
          if   (name != None):
            sb = mosek.fusion.Utils.StringBuffer()

            cnt = mosek.fusion.IndexCounter(shape)

            # src/fusion/Model.mbi(1573:17-1580:17)
            for i in xrange(0l,shape._size):
              # { @ src/fusion/Model.mbi(1574:17-1580:17)
              ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_S(( shape._indexToString_L(i) )) )._a_S("]") )
              ( self._task_1var_1name_IS((int(i) + first),( sb._toString_() )) )
              ( sb._toString_() )
              ( cnt._inc_() )
              # } @ src/fusion/Model.mbi(1574:17-1580:17)
        if   (idom == None):
          mvar = mosek.fusion.LinearVariable(self,name,dom,shape,nativeindexes,( self._numVariables_() ))
        else:
          mvar = mosek.fusion.IntegerLinearVariable(self,name,dom,shape,nativeindexes,( self._numVariables_() ))
        res = mvar
        if   (not sparse):
          # src/fusion/Model.mbi(1589:15-68)
          for i in xrange(0,numvar):
            self.__natvarmap_Var[(i + first)] = mvar
      elif ((key == RelationKey.InQCone) or (key == RelationKey.InRotatedQCone)):


        if   (shape.nd == 2):
          numcone = ( shape._dim_I(0) )
          conesize = ( shape._dim_I(1) )
        else:
          numcone = 1
          conesize = int(shape._size)
        if   (((key == RelationKey.InQCone) and (conesize < 2)) or ((key == RelationKey.InRotatedQCone) and (conesize < 3))):
          raise mosek.fusion.DimensionError("Invalid size for cone")
        size = int(shape._size)

        first = ( self._task_1append_1var_I(size) )

        ( self.__natvarmap_1ensure_I(size) )
        self.__natvarmap_num = (self.__natvarmap_num + size)
        last = (first + size)

        if   ((name != None) and False):
          sb = mosek.fusion.Utils.StringBuffer()

          # src/fusion/Model.mbi(1621:15-1626:15)
          for i in xrange(0l,shape._size):
            # { @ src/fusion/Model.mbi(1622:15-1626:15)
            ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_S(( shape._indexToString_L(i) )) )._a_S("]") )
            ( self._task_1var_1name_IS(int((i + first)),( sb._toString_() )) )
            # } @ src/fusion/Model.mbi(1622:15-1626:15)
        nativeindexes = ( Utils.Tools._range_II (first,last) )
        # src/fusion/Model.mbi(1630:13-74)
        for i in xrange(0,(last - first)):
          self.__natvarmap_idx[(i + first)] = long(i)
        ( self._task_1var_1putboundslice_1fr_II(first,last) )
        if   (idom != None):
          ( self._task_1var_1putintlist__3I(( Utils.Tools._range_II (first,last) )) )

        if   (dom._key == RelationKey.InQCone):
          firstcone = ( self._task_1append_1quadcone_III(conesize,first,numcone) )
        else:
          firstcone = ( self._task_1append_1rquadcone_III(conesize,first,numcone) )
        if   (name != None):
          sb = mosek.fusion.Utils.StringBuffer()

          names = ([ None for _autovar_704 in xrange(numcone) ])

          # src/fusion/Model.mbi(1652:15-1655:15)
          for i in xrange(0,numcone):
            # { @ src/fusion/Model.mbi(1653:15-1655:15)
            names[i] = ( ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_I(i) )._a_S("]") )._toString_() )
            # } @ src/fusion/Model.mbi(1653:15-1655:15)
          if   True:
            # src/fusion/Model.mbi(1658:17-1659:58)
            for i in xrange(0,numcone):
              ( self._task_1cone_1name_IS((firstcone + i),names[i]) )
        if   (idom == None):
          mvar = mosek.fusion.ConicVariable(self,name,shape,nativeindexes,conesize,firstcone,numcone,( self._numVariables_() ))
        else:
          mvar = mosek.fusion.IntegerConicVariable(self,name,shape,nativeindexes,conesize,firstcone,numcone,( self._numVariables_() ))
        res = mvar
        # src/fusion/Model.mbi(1666:13-64)
        for i in xrange(0,size):
          self.__natvarmap_Var[(i + first)] = mvar
      else:
        raise mosek.fusion.UnexpectedError("Invalid relation type detected")
    finally:
      if   (res == None):
        ( self._task_1cleanup_IIII(initial_numvar,initial_numcon,initial_numcone,initial_numbarvar) )
    v = res

    ( self._addVariable_SOmosek_fusion_Variable_2(name,v) )
    return v
  @staticmethod
  def _matchargs_ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(args):
    if len(args) != 5:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    if not isinstance(args[4],bool): return False
    return True
  # origin: src/fusion/Model.mbi(1690:16-1778:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("ranged_variable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain,bool)")
  def __ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(self,name,shp,dom,idom,sparse):
    res = None


    if   ( self._hasVariable_S(name) ):
      raise mosek.fusion.NameError(( ( ( ( mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '") )._a_S(name) )._a_S("'") )._toString_() ))
    if   (shp != None):
      if   (not ( dom._match_1shape_Omosek_fusion_Set_2(shp) )):
        raise mosek.fusion.DimensionError("Mismatching shape and domain")
      shape = shp
    else:
      shape = dom._shape
      if   (shape == None):
        shape = mosek.fusion.IntSet(1)
    initial_numvar = ( self._task_1numvar_() )

    initial_numcon = ( self._task_1numcon_() )

    initial_numcone = ( self._task_1numcone_() )

    initial_numbarvar = ( self._task_1numbarvar_() )

    try:
      nativeindexes = None

      numvar = int(shape._size)

      first = 0

      if   sparse:
        first = ( self._task_1append_1var_I(numvar) )
        ( self.__natvarmap_1ensure_I(numvar) )
        self.__natvarmap_num = (self.__natvarmap_num + numvar)
        bl = ([ 0.0 for _autovar_705 in xrange(numvar) ])

        bu = ([ 0.0 for _autovar_706 in xrange(numvar) ])

        # src/fusion/Model.mbi(1739:13-1743:13)
        for i in xrange(0l,long(numvar)):
          # { @ src/fusion/Model.mbi(1740:13-1743:13)
          bl[i] = ( dom._get_1lb_1item_L(i) )
          bu[i] = ( dom._get_1lb_1item_L(i) )
          # } @ src/fusion/Model.mbi(1740:13-1743:13)
        ( self._task_1var_1putboundslice_1ra_II_3F_3F(first,(first + numvar),bl,bu) )
        nativeindexes = ([ 0 for _autovar_707 in xrange(numvar) ])
        # src/fusion/Model.mbi(1748:13-63)
        for i in xrange(0,numvar):
          nativeindexes[i] = (first + i)
        # src/fusion/Model.mbi(1749:13-70)
        for i in xrange(0,numvar):
          self.__natvarmap_idx[(i + first)] = long(i)
        if   (name != None):
          sb = mosek.fusion.Utils.StringBuffer()

          cnt = mosek.fusion.IndexCounter(shape)

          # src/fusion/Model.mbi(1755:15-1762:15)
          for i in xrange(0l,shape._size):
            # { @ src/fusion/Model.mbi(1756:15-1762:15)
            ( ( ( ( ( sb._clear_() )._a_S(name) )._a_S("[") )._a_S(( shape._indexToString_L(i) )) )._a_S("]") )
            ( self._task_1var_1name_IS((int(i) + first),( sb._toString_() )) )
            ( sb._toString_() )
            ( cnt._inc_() )
            # } @ src/fusion/Model.mbi(1756:15-1762:15)
      if   (idom == None):
        res = mosek.fusion.RangedVariable(self,name,shape,dom,nativeindexes,( self._numVariables_() ))
      else:
        res = mosek.fusion.IntegerRangedVariable(self,name,shape,dom,nativeindexes,( self._numVariables_() ))
    finally:
      if   (res == None):
        ( self._task_1cleanup_IIII(initial_numvar,initial_numcon,initial_numcone,initial_numbarvar) )
    ( self._addVariable_SOmosek_fusion_Variable_2(name,res) )
    return res
  @staticmethod
  def _matchargs_variable_1_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    if not isinstance(args[3],bool): return False
    return True
  # origin: src/fusion/Model.mbi(1781:16-1780:232)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable_(basestring,mosek.fusion.Domain,mosek.fusion.IntegerDomain,bool)")
  def __variable_1_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(self,name,dom,idom,sparse):
    if   (dom == None):
      return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,mosek.fusion.IntSet(1),dom,idom,sparse) )
    else:
      return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,dom._shape,dom,idom,sparse) )
  @staticmethod
  def _matchargs_variable_1_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    if not isinstance(args[3],bool): return False
    return True
  # origin: src/fusion/Model.mbi(1782:16-1781:246)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable_(basestring,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain,bool)")
  def __variable_1_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(self,name,dom,idom,sparse):
    if   (dom == None):
      return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,mosek.fusion.IntSet(1),dom,idom,sparse) )
    else:
      return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,dom._shape,dom,idom,sparse) )
  @staticmethod
  def _matchargs_variable_SIOmosek_fusion_Domain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1784:15-1783:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,int,mosek.fusion.Domain)")
  def _variable_SIOmosek_fusion_Domain_2(self,name,size,dom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,mosek.fusion.IntSet(size),dom,None,False) )
  @staticmethod
  def _matchargs_variable_SIOmosek_fusion_RangeDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1785:15-1784:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,int,mosek.fusion.RangeDomain)")
  def _variable_SIOmosek_fusion_RangeDomain_2(self,name,size,dom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,mosek.fusion.IntSet(size),dom,None,False) )
  @staticmethod
  def _matchargs_variable_SIOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1786:15-1785:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,int,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _variable_SIOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,name,size,dom,idom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,mosek.fusion.IntSet(size),dom,idom,False) )
  @staticmethod
  def _matchargs_variable_SIOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1787:15-1786:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,int,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _variable_SIOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,name,size,dom,idom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,mosek.fusion.IntSet(size),dom,idom,False) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1788:15-1787:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Set,mosek.fusion.Domain)")
  def _variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2(self,name,shp,dom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,shp,dom,None,False) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1789:15-1788:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain)")
  def _variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2(self,name,shp,dom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,shp,dom,None,False) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1790:15-1789:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,name,shp,dom,idom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,shp,dom,idom,False) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1791:15-1790:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,name,shp,dom,idom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,shp,dom,idom,False) )
  @staticmethod
  def _matchargs_variable_IOmosek_fusion_Domain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1792:15-1791:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(int,mosek.fusion.Domain)")
  def _variable_IOmosek_fusion_Domain_2(self,size,dom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(None,mosek.fusion.IntSet(size),dom,None,False) )
  @staticmethod
  def _matchargs_variable_IOmosek_fusion_RangeDomain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1793:15-1792:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(int,mosek.fusion.RangeDomain)")
  def _variable_IOmosek_fusion_RangeDomain_2(self,size,dom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(None,mosek.fusion.IntSet(size),dom,None,False) )
  @staticmethod
  def _matchargs_variable_IOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1794:15-1793:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(int,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _variable_IOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,size,dom,idom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(None,mosek.fusion.IntSet(size),dom,idom,False) )
  @staticmethod
  def _matchargs_variable_IOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1795:15-1794:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(int,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _variable_IOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,size,dom,idom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(None,mosek.fusion.IntSet(size),dom,idom,False) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1796:15-1795:174)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.Set,mosek.fusion.Domain)")
  def _variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2(self,shp,dom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(None,shp,dom,None,False) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1797:15-1796:174)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.Set,mosek.fusion.RangeDomain)")
  def _variable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2(self,shp,dom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(None,shp,dom,None,False) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1798:15-1797:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,shp,dom,idom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(None,shp,dom,idom,False) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1799:15-1798:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _variable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,shp,dom,idom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(None,shp,dom,idom,False) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Domain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1800:15-1799:157)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Domain)")
  def _variable_SOmosek_fusion_Domain_2(self,name,dom):
    return ( self.__variable_1_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,dom,None,False) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_RangeDomain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1801:15-1800:150)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.RangeDomain)")
  def _variable_SOmosek_fusion_RangeDomain_2(self,name,dom):
    return ( self.__variable_1_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,dom,None,False) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1802:15-1801:151)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _variable_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,name,dom,idom):
    return ( self.__variable_1_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,dom,idom,False) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1803:15-1802:151)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _variable_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,name,dom,idom):
    return ( self.__variable_1_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,dom,idom,False) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_Domain_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1804:15-1803:150)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.Domain)")
  def _variable_Omosek_fusion_Domain_2(self,dom):
    return ( self.__variable_1_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(None,dom,None,False) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_RangeDomain_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1805:15-1804:150)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.RangeDomain)")
  def _variable_Omosek_fusion_RangeDomain_2(self,dom):
    return ( self.__variable_1_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(None,dom,None,False) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Domain): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1806:15-1805:151)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _variable_Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,dom,idom):
    return ( self.__variable_1_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(None,dom,idom,False) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.RangeDomain): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1807:15-1806:151)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _variable_Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,dom,idom):
    return ( self.__variable_1_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(None,dom,idom,False) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_PSDDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1809:15-1808:142)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.Set,mosek.fusion.PSDDomain)")
  def _variable_SOmosek_fusion_Set_2Omosek_fusion_PSDDomain_2(self,name,shp,dom):
    return ( self.__variable_1_SOmosek_fusion_Set_2Omosek_fusion_PSDDomain_2(name,shp,dom) )
  @staticmethod
  def _matchargs_variable_SIOmosek_fusion_PSDDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1810:15-1809:153)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,int,mosek.fusion.PSDDomain)")
  def _variable_SIOmosek_fusion_PSDDomain_2(self,name,n,dom):
    return ( self.__variable_1_SOmosek_fusion_Set_2Omosek_fusion_PSDDomain_2(name,mosek.fusion.NDSet(n,n),dom) )
  @staticmethod
  def _matchargs_variable_SIIOmosek_fusion_PSDDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if not isinstance(args[2],int): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1811:15-1810:155)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,int,int,mosek.fusion.PSDDomain)")
  def _variable_SIIOmosek_fusion_PSDDomain_2(self,name,n,m,dom):
    return ( self.__variable_1_SOmosek_fusion_Set_2Omosek_fusion_PSDDomain_2(name,mosek.fusion.NDSet(n,n,m),dom) )
  @staticmethod
  def _matchargs_variable_SOmosek_fusion_PSDDomain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1812:15-1811:155)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(basestring,mosek.fusion.PSDDomain)")
  def _variable_SOmosek_fusion_PSDDomain_2(self,name,dom):
    return ( self.__variable_1_SOmosek_fusion_Set_2Omosek_fusion_PSDDomain_2(name,None,dom) )
  @staticmethod
  def _matchargs_variable_IOmosek_fusion_PSDDomain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1813:15-1812:153)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(int,mosek.fusion.PSDDomain)")
  def _variable_IOmosek_fusion_PSDDomain_2(self,n,dom):
    return ( self.__variable_1_SOmosek_fusion_Set_2Omosek_fusion_PSDDomain_2(None,mosek.fusion.NDSet(n,n),dom) )
  @staticmethod
  def _matchargs_variable_IIOmosek_fusion_PSDDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1814:15-1813:155)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(int,int,mosek.fusion.PSDDomain)")
  def _variable_IIOmosek_fusion_PSDDomain_2(self,n,m,dom):
    return ( self.__variable_1_SOmosek_fusion_Set_2Omosek_fusion_PSDDomain_2(None,mosek.fusion.NDSet(n,n,m),dom) )
  @staticmethod
  def _matchargs_variable_Omosek_fusion_PSDDomain_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1815:15-1814:155)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("variable(mosek.fusion.PSDDomain)")
  def _variable_Omosek_fusion_PSDDomain_2(self,dom):
    return ( self.__variable_1_SOmosek_fusion_Set_2Omosek_fusion_PSDDomain_2(None,None,dom) )
  @staticmethod
  def _matchargs_sparseVariable_SIOmosek_fusion_Domain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1817:15-1816:174)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,int,mosek.fusion.Domain)")
  def _sparseVariable_SIOmosek_fusion_Domain_2(self,name,size,dom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,mosek.fusion.IntSet(size),dom,None,False) )
  @staticmethod
  def _matchargs_sparseVariable_SIOmosek_fusion_RangeDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1818:15-1817:174)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,int,mosek.fusion.RangeDomain)")
  def _sparseVariable_SIOmosek_fusion_RangeDomain_2(self,name,size,dom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,mosek.fusion.IntSet(size),dom,None,False) )
  @staticmethod
  def _matchargs_sparseVariable_SIOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1819:15-1818:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,int,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_SIOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,name,size,dom,idom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,mosek.fusion.IntSet(size),dom,idom,False) )
  @staticmethod
  def _matchargs_sparseVariable_SIOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1820:15-1819:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,int,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_SIOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,name,size,dom,idom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,mosek.fusion.IntSet(size),dom,idom,False) )
  @staticmethod
  def _matchargs_sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1821:15-1820:174)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,mosek.fusion.Set,mosek.fusion.Domain)")
  def _sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2(self,name,shp,dom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,shp,dom,None,False) )
  @staticmethod
  def _matchargs_sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1822:15-1821:174)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain)")
  def _sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2(self,name,shp,dom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,shp,dom,None,False) )
  @staticmethod
  def _matchargs_sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1823:15-1822:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,name,shp,dom,idom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,shp,dom,idom,False) )
  @staticmethod
  def _matchargs_sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1824:15-1823:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,name,shp,dom,idom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,shp,dom,idom,False) )
  @staticmethod
  def _matchargs_sparseVariable_IOmosek_fusion_Domain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1825:15-1824:174)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(int,mosek.fusion.Domain)")
  def _sparseVariable_IOmosek_fusion_Domain_2(self,size,dom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(None,mosek.fusion.IntSet(size),dom,None,False) )
  @staticmethod
  def _matchargs_sparseVariable_IOmosek_fusion_RangeDomain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1826:15-1825:174)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(int,mosek.fusion.RangeDomain)")
  def _sparseVariable_IOmosek_fusion_RangeDomain_2(self,size,dom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(None,mosek.fusion.IntSet(size),dom,None,False) )
  @staticmethod
  def _matchargs_sparseVariable_IOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1827:15-1826:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(int,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_IOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,size,dom,idom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(None,mosek.fusion.IntSet(size),dom,idom,False) )
  @staticmethod
  def _matchargs_sparseVariable_IOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1828:15-1827:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(int,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_IOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,size,dom,idom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(None,mosek.fusion.IntSet(size),dom,idom,False) )
  @staticmethod
  def _matchargs_sparseVariable_Omosek_fusion_Set_2Omosek_fusion_Domain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1829:15-1828:174)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(mosek.fusion.Set,mosek.fusion.Domain)")
  def _sparseVariable_Omosek_fusion_Set_2Omosek_fusion_Domain_2(self,shp,dom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(None,shp,dom,None,False) )
  @staticmethod
  def _matchargs_sparseVariable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1830:15-1829:174)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(mosek.fusion.Set,mosek.fusion.RangeDomain)")
  def _sparseVariable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2(self,shp,dom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(None,shp,dom,None,False) )
  @staticmethod
  def _matchargs_sparseVariable_Omosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1831:15-1830:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_Omosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,shp,dom,idom):
    return ( self.__variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(None,shp,dom,idom,False) )
  @staticmethod
  def _matchargs_sparseVariable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1832:15-1831:175)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,shp,dom,idom):
    return ( self.__ranged_1variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(None,shp,dom,idom,False) )
  @staticmethod
  def _matchargs_sparseVariable_SOmosek_fusion_Domain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1833:15-1832:150)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,mosek.fusion.Domain)")
  def _sparseVariable_SOmosek_fusion_Domain_2(self,name,dom):
    return ( self.__variable_1_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,dom,None,False) )
  @staticmethod
  def _matchargs_sparseVariable_SOmosek_fusion_RangeDomain_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1834:15-1833:150)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,mosek.fusion.RangeDomain)")
  def _sparseVariable_SOmosek_fusion_RangeDomain_2(self,name,dom):
    return ( self.__variable_1_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,dom,None,False) )
  @staticmethod
  def _matchargs_sparseVariable_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1835:15-1834:151)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,name,dom,idom):
    return ( self.__variable_1_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(name,dom,idom,False) )
  @staticmethod
  def _matchargs_sparseVariable_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1836:15-1835:151)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(basestring,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,name,dom,idom):
    return ( self.__variable_1_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(name,dom,idom,False) )
  @staticmethod
  def _matchargs_sparseVariable_Omosek_fusion_Domain_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1837:15-1836:150)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(mosek.fusion.Domain)")
  def _sparseVariable_Omosek_fusion_Domain_2(self,dom):
    return ( self.__variable_1_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(None,dom,None,False) )
  @staticmethod
  def _matchargs_sparseVariable_Omosek_fusion_RangeDomain_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1838:15-1837:150)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(mosek.fusion.RangeDomain)")
  def _sparseVariable_Omosek_fusion_RangeDomain_2(self,dom):
    return ( self.__variable_1_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(None,dom,None,False) )
  @staticmethod
  def _matchargs_sparseVariable_Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Domain): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1839:15-1838:151)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(mosek.fusion.Domain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,dom,idom):
    return ( self.__variable_1_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2B(None,dom,idom,False) )
  @staticmethod
  def _matchargs_sparseVariable_Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.RangeDomain): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.IntegerDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1840:15-1839:151)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("sparseVariable(mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)")
  def _sparseVariable_Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,dom,idom):
    return ( self.__variable_1_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2B(None,dom,idom,False) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1842:15-1841:140)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Expression,mosek.fusion.PSDDomain)")
  def _constraint_SOmosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(self,name,expr,dom):
    return ( self.__constraint_1_SOmosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(name,expr,dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1843:15-1842:140)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Expression,mosek.fusion.PSDDomain)")
  def _constraint_Omosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(self,expr,dom):
    return ( self.__constraint_1_SOmosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(None,expr,dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1845:15-1844:146)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.Domain)")
  def _constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(self,name,shape,expr,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(name,shape,expr,dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1846:15-1845:146)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.Domain)")
  def _constraint_Omosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(self,shape,expr,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(None,shape,expr,dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1847:15-1846:145)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Expression,mosek.fusion.Domain)")
  def _constraint_SOmosek_fusion_Expression_2Omosek_fusion_Domain_2(self,name,expr,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(name,None,expr,dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1848:15-1847:145)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Expression,mosek.fusion.Domain)")
  def _constraint_Omosek_fusion_Expression_2Omosek_fusion_Domain_2(self,expr,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(None,None,expr,dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1850:15-1849:146)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain)")
  def _constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,name,shape,expr,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(name,shape,expr,dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1851:15-1850:146)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain)")
  def _constraint_Omosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,shape,expr,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(None,shape,expr,dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1852:15-1851:145)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Expression,mosek.fusion.RangeDomain)")
  def _constraint_SOmosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,name,expr,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(name,None,expr,dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Expression): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1853:15-1852:145)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Expression,mosek.fusion.RangeDomain)")
  def _constraint_Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,expr,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(None,None,expr,dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Variable_2Omosek_fusion_PSDDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1855:15-1854:146)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Variable,mosek.fusion.PSDDomain)")
  def _constraint_SOmosek_fusion_Variable_2Omosek_fusion_PSDDomain_2(self,name,v,dom):
    return ( self.__constraint_1_SOmosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(name,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Variable_2Omosek_fusion_PSDDomain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.PSDDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1856:15-1855:146)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Variable,mosek.fusion.PSDDomain)")
  def _constraint_Omosek_fusion_Variable_2Omosek_fusion_PSDDomain_2(self,v,dom):
    return ( self.__constraint_1_SOmosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(None,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1858:15-1857:152)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.Domain)")
  def _constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(self,name,shape,v,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(name,shape,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1859:15-1858:152)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.Domain)")
  def _constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(self,shape,v,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(None,shape,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1860:15-1859:151)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Variable,mosek.fusion.Domain)")
  def _constraint_SOmosek_fusion_Variable_2Omosek_fusion_Domain_2(self,name,v,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(name,None,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Domain): return False
    return True
  # origin: src/fusion/Model.mbi(1861:15-1860:151)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Variable,mosek.fusion.Domain)")
  def _constraint_Omosek_fusion_Variable_2Omosek_fusion_Domain_2(self,v,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(None,None,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Set): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1863:15-1862:152)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain)")
  def _constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,name,shape,v,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(name,shape,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 3:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1864:15-1863:152)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain)")
  def _constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,shape,v,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(None,shape,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_SOmosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1865:15-1864:151)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(basestring,mosek.fusion.Variable,mosek.fusion.RangeDomain)")
  def _constraint_SOmosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,name,v,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(name,None,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_constraint_Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
    if len(args) != 2:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Variable): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.RangeDomain): return False
    return True
  # origin: src/fusion/Model.mbi(1866:15-1865:151)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("constraint(mosek.fusion.Variable,mosek.fusion.RangeDomain)")
  def _constraint_Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,v,dom):
    return ( self.__constraint_1_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(None,None,( v._asExpr_() ),dom) )
  @staticmethod
  def _matchargs_objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],mosek.fusion.ObjectiveSense): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Model.mbi(1870:15-1869:127)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("objective(basestring,mosek.fusion.ObjectiveSense,mosek.fusion.Expression)")
  def _objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(self,name,sense,expr):
    ( self.__objective_1_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(name,sense,expr) )
  @staticmethod
  def _matchargs_objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],mosek.fusion.ObjectiveSense): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Model.mbi(1871:15-1870:133)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("objective(basestring,mosek.fusion.ObjectiveSense,mosek.fusion.Variable)")
  def _objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(self,name,sense,v):
    ( self.__objective_1_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(name,sense,( v._asExpr_() )) )
  @staticmethod
  def _matchargs_objective_SOmosek_fusion_ObjectiveSense_2F(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],mosek.fusion.ObjectiveSense): return False
    if not isinstance(args[2],float): return False
    return True
  # origin: src/fusion/Model.mbi(1872:15-1871:140)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("objective(basestring,mosek.fusion.ObjectiveSense,float)")
  def _objective_SOmosek_fusion_ObjectiveSense_2F(self,name,sense,c):
    ( self.__objective_1_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(name,sense,( Expr._constTerm_F (c) )) )
  @staticmethod
  def _matchargs_objective_SF(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Model.mbi(1873:15-1872:158)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("objective(basestring,float)")
  def _objective_SF(self,name,c):
    ( self.__objective_1_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(name,ObjectiveSense.Minimize,( Expr._constTerm_F (c) )) )
  @staticmethod
  def _matchargs_objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.ObjectiveSense): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Model.mbi(1874:15-1873:127)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("objective(mosek.fusion.ObjectiveSense,mosek.fusion.Expression)")
  def _objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(self,sense,expr):
    ( self.__objective_1_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(None,sense,expr) )
  @staticmethod
  def _matchargs_objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.ObjectiveSense): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Variable): return False
    return True
  # origin: src/fusion/Model.mbi(1875:15-1874:134)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("objective(mosek.fusion.ObjectiveSense,mosek.fusion.Variable)")
  def _objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(self,sense,v):
    ( self.__objective_1_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(None,sense,( v._asExpr_() )) )
  @staticmethod
  def _matchargs_objective_Omosek_fusion_ObjectiveSense_2F(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.ObjectiveSense): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Model.mbi(1876:15-1875:140)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("objective(mosek.fusion.ObjectiveSense,float)")
  def _objective_Omosek_fusion_ObjectiveSense_2F(self,sense,c):
    ( self.__objective_1_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(None,sense,( Expr._constTerm_F (c) )) )
  @staticmethod
  def _matchargs_objective_F(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],float): return False
    return True
  # origin: src/fusion/Model.mbi(1877:15-1876:158)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("objective(float)")
  def _objective_F(self,c):
    ( self.__objective_1_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(None,ObjectiveSense.Minimize,( Expr._constTerm_F (c) )) )
  @staticmethod
  def _matchargs_objective_1_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(args):
    if len(args) != 3:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],mosek.fusion.ObjectiveSense): return False
    if args[2] is not None and not isinstance(args[2],mosek.fusion.Expression): return False
    return True
  # origin: src/fusion/Model.mbi(1879:16-2049:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("objective_(basestring,mosek.fusion.ObjectiveSense,mosek.fusion.Expression)")
  def __objective_1_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(self,name,sense,expr):
    ( self._task_1putobjectivename_S(name) )
    if   (( expr._size_() ) != 1l):
      raise mosek.fusion.LengthError("Objective expression must be of size 1.")
    if   ((sense != ObjectiveSense.Minimize) and (sense != ObjectiveSense.Maximize)):
      raise mosek.fusion.LengthError("Objective sense required.")
    e = ( expr._eval_() )

    varidxs = None

    cof = None

    numbarvar = 0

    numscalarvar = 0

    tmpvaridxs = None

    tmpbarvarsubi = None

    tmpbarvarsubj = None

    # { @ src/fusion/Model.mbi(1905:9-1942:9)
    num = int(len(e.subj))

    tmpvaridxs = ([ 0 for _autovar_708 in xrange(num) ])
    tmpbarvarsubi = ([ 0 for _autovar_709 in xrange(num) ])
    tmpbarvarsubj = ([ 0 for _autovar_710 in xrange(num) ])
    # src/fusion/Model.mbi(1911:11-1912:82)
    i = 0

    while (i < num):
      ( e.x._inst_LL_3I_3I_3I(e.subj[i],long(i),tmpvaridxs,tmpbarvarsubi,tmpbarvarsubj) )
      i += 1
    numscalarvar = 0
    # src/fusion/Model.mbi(1915:11-1918:22)
    i = 0

    while (i < num):
      if   (tmpvaridxs[i] >= 0):
        numscalarvar += 1
      i += 1
    numbarvar = (num - numscalarvar)
    if   (numscalarvar > 0):
      varidxs = ([ 0 for _autovar_711 in xrange(numscalarvar) ])
    if   (numbarvar == 0):
      varidxs = tmpvaridxs
      cof = e.cof
    else:
      vari = 0

      cof = ([ 0.0 for _autovar_712 in xrange(numscalarvar) ])
      varidxs = ([ 0 for _autovar_713 in xrange(numscalarvar) ])
      # src/fusion/Model.mbi(1932:13-1940:13)
      k = e.ptrb[0]

      while (k < e.ptrb[1]):
        if   (tmpvaridxs[k] >= 0):
          varidxs[vari] = tmpvaridxs[k]
          cof[vari] = e.cof[k]
          vari += 1
        k += 1
    # } @ src/fusion/Model.mbi(1905:9-1942:9)
    bfix = 0.0

    if   (e.bfix != None):
      bfix = e.bfix[0]
    ( self._task_1putobjective_B_3I_3FF((sense == ObjectiveSense.Maximize),varidxs,cof,bfix) )
    if   (numbarvar > 0):
      numbarinz = 0l

      # src/fusion/Model.mbi(1961:11-1964:15)
      k = e.ptrb[0]

      while (k < e.ptrb[1]):
        if   (tmpvaridxs[k] < 0):
          numbarinz += 1
        k += 1
      if   (numbarinz > 0):
        bariperm = ([ 0l for _autovar_714 in xrange(numbarinz) ])

        # { @ src/fusion/Model.mbi(1966:13-1974:13)
        barvari = 0

        # src/fusion/Model.mbi(1968:15-1975:16)
        k = e.ptrb[0]

        while (k < e.ptrb[1]):
          if   (tmpvaridxs[k] < 0):
            bariperm[barvari] = long(k)
            barvari += 1
          k += 1
        # } @ src/fusion/Model.mbi(1966:13-1974:13)
        ( CommonTools._argQsort__3L_3I_3ILL (bariperm,tmpvaridxs,None,0l,numbarinz) )
        # { @ src/fusion/Model.mbi(1978:13-2040:14)
        barvari = 0

        # src/fusion/Model.mbi(1980:15-2039:16)
        while (barvari < numbarinz):
          barptrb = barvari

          barvari += 1
          # src/fusion/Model.mbi(1984:17-123)
          while ((barvari < numbarinz) and (tmpvaridxs[bariperm[barvari]] == tmpvaridxs[bariperm[(barvari - 1)]])):
            barvari += 1
          numbarvarijnz = (barvari - barptrb)

          ( CommonTools._argQsort__3L_3I_3ILL (bariperm,tmpbarvarsubi,tmpbarvarsubj,long(barptrb),long(barvari)) )
          numuniquenz = 1

          # src/fusion/Model.mbi(1993:17-2000:17)
          for k in xrange((barptrb + 1),barvari):
            # { @ src/fusion/Model.mbi(1994:17-2000:17)
            idx = bariperm[k]

            pidx = bariperm[(k - 1)]

            if   ((tmpbarvarsubi[idx] != tmpbarvarsubi[pidx]) or (tmpbarvarsubj[idx] != tmpbarvarsubj[pidx])):
              numuniquenz += 1
            # } @ src/fusion/Model.mbi(1994:17-2000:17)
          l = 0

          barvarijsubi = ([ 0 for _autovar_715 in xrange(numuniquenz) ])

          barvarijsubj = ([ 0 for _autovar_716 in xrange(numuniquenz) ])

          barvarijcof = ([ 0.0 for _autovar_717 in xrange(numuniquenz) ])

          barvarijsubi[0] = tmpbarvarsubi[bariperm[barptrb]]
          barvarijsubj[0] = tmpbarvarsubj[bariperm[barptrb]]
          if   (barvarijsubi[0] == barvarijsubj[0]):
            barvarijcof[0] = e.cof[bariperm[barptrb]]
          else:
            barvarijcof[0] = (0.5 * e.cof[bariperm[barptrb]])
          # src/fusion/Model.mbi(2017:17-2032:17)
          for k in xrange((barptrb + 1),barvari):
            # { @ src/fusion/Model.mbi(2018:17-2032:17)
            idx = bariperm[k]

            pidx = bariperm[(k - 1)]

            if   ((tmpbarvarsubi[idx] != tmpbarvarsubi[pidx]) or (tmpbarvarsubj[idx] != tmpbarvarsubj[pidx])):
              l += 1
              barvarijsubi[l] = tmpbarvarsubi[idx]
              barvarijsubj[l] = tmpbarvarsubj[idx]
            if   (barvarijsubi[l] == barvarijsubj[l]):
              barvarijcof[l] = (barvarijcof[l] + e.cof[idx])
            else:
              barvarijcof[l] = (barvarijcof[l] + (0.5 * e.cof[idx]))
            # } @ src/fusion/Model.mbi(2018:17-2032:17)
          barcj = (- (tmpvaridxs[bariperm[barptrb]] + 1))

          barcjdim = ( self._task_1barvardim_I(barcj) )

          barcjidx = ( self._task_1append_1barmatrix_I_3I_3I_3F(barcjdim,barvarijsubi,barvarijsubj,barvarijcof) )

          ( self._task_1putbarcj_II(barcj,barcjidx) )
        # } @ src/fusion/Model.mbi(1978:13-2040:14)
  @staticmethod
  def _matchargs_getSolutionStatus_Omosek_fusion_SolutionType_2B(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    if not isinstance(args[1],bool): return False
    return True
  # origin: src/fusion/Model.mbi(2054:18-2071:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolutionStatus(mosek.fusion.SolutionType,bool)")
  def _getSolutionStatus_Omosek_fusion_SolutionType_2B(self,which,primal):
    try:
      sol = ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,primal) )

      if   primal:
        return sol.pstatus
      else:
        return sol.dstatus
    except mosek.fusion.SolutionError, e:
      return SolutionStatus.Undefined
  @staticmethod
  def _matchargs_acceptedSolutionStatus_Omosek_fusion_AccSolutionStatus_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.AccSolutionStatus): return False
    return True
  # origin: src/fusion/Model.mbi(2084:15-2086:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("acceptedSolutionStatus(mosek.fusion.AccSolutionStatus)")
  def _acceptedSolutionStatus_Omosek_fusion_AccSolutionStatus_2(self,what):
    self.__acceptable_sol = what
  @staticmethod
  def _matchargs_acceptedSolutionStatus_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Model.mbi(2090:15-2092:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("acceptedSolutionStatus()")
  def _acceptedSolutionStatus_(self):
    return self.__acceptable_sol
  @staticmethod
  def _matchargs_getSolution_1xx_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(2095:18-2098:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_xx(mosek.fusion.SolutionType)")
  def _getSolution_1xx_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,True) ).xx
  @staticmethod
  def _matchargs_getSolution_1slx_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(2101:18-2104:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_slx(mosek.fusion.SolutionType)")
  def _getSolution_1slx_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).slx
  @staticmethod
  def _matchargs_getSolution_1sux_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(2107:18-2110:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_sux(mosek.fusion.SolutionType)")
  def _getSolution_1sux_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).sux
  @staticmethod
  def _matchargs_getSolution_1slc_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(2113:18-2116:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_slc(mosek.fusion.SolutionType)")
  def _getSolution_1slc_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).slc
  @staticmethod
  def _matchargs_getSolution_1suc_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(2119:18-2122:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_suc(mosek.fusion.SolutionType)")
  def _getSolution_1suc_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).suc
  @staticmethod
  def _matchargs_getSolution_1snx_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(2125:18-2128:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_snx(mosek.fusion.SolutionType)")
  def _getSolution_1snx_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).snx
  @staticmethod
  def _matchargs_getSolution_1xc_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(2131:18-2134:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_xc(mosek.fusion.SolutionType)")
  def _getSolution_1xc_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,True) ).xc
  @staticmethod
  def _matchargs_getSolution_1y_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(2137:18-2140:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_y(mosek.fusion.SolutionType)")
  def _getSolution_1y_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).y
  @staticmethod
  def _matchargs_getSolution_1barx_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(2143:18-2146:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_barx(mosek.fusion.SolutionType)")
  def _getSolution_1barx_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).barx
  @staticmethod
  def _matchargs_getSolution_1bars_Omosek_fusion_SolutionType_2(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    return True
  # origin: src/fusion/Model.mbi(2149:18-2152:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolution_bars(mosek.fusion.SolutionType)")
  def _getSolution_1bars_Omosek_fusion_SolutionType_2(self,which):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(which,False) ).bars
  @staticmethod
  def _matchargs_get_1sol_1cache_Omosek_fusion_SolutionType_2B(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],mosek.fusion.SolutionType): return False
    if not isinstance(args[1],bool): return False
    return True
  # origin: src/fusion/Model.mbi(2156:18-2207:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get_sol_cache(mosek.fusion.SolutionType,bool)")
  def _get_1sol_1cache_Omosek_fusion_SolutionType_2B(self,which,primal):
    res = None

    if   (which == SolutionType.Default):
      if   (self._sol_itg != None):
        res = self._sol_itg
      elif (self._sol_bas != None):
        res = self._sol_bas
      else:
        res = self._sol_itr
    elif (which == SolutionType.Interior):
      res = self._sol_itr
    elif (which == SolutionType.Basic):
      res = self._sol_bas
    elif (which == SolutionType.Integer):
      res = self._sol_itg
    if   (res == None):
      raise mosek.fusion.SolutionError("Solution not available")
    else:
      if   ((primal and ( res._isPrimalAcceptable_Omosek_fusion_AccSolutionStatus_2(self.__acceptable_sol) )) or ((not primal) and ( res._isDualAcceptable_Omosek_fusion_AccSolutionStatus_2(self.__acceptable_sol) ))):
        return res
      else:
        sb = mosek.fusion.Utils.StringBuffer()

        solsta = res.pstatus

        if   (not primal):
          solsta = res.dstatus
        ( sb._a_S("Solution status is ") )
        if   (solsta == SolutionStatus.Undefined):
          ( sb._a_S("Undefined") )
        elif (solsta == SolutionStatus.Unknown):
          ( sb._a_S("Unknown") )
        elif (solsta == SolutionStatus.Optimal):
          ( sb._a_S("Optimal") )
        elif (solsta == SolutionStatus.NearOptimal):
          ( sb._a_S("NearOptimal") )
        elif (solsta == SolutionStatus.Feasible):
          ( sb._a_S("Feasible") )
        elif (solsta == SolutionStatus.NearFeasible):
          ( sb._a_S("NearFeasible") )
        elif (solsta == SolutionStatus.Certificate):
          ( sb._a_S("Certificate") )
        elif (solsta == SolutionStatus.NearCertificate):
          ( sb._a_S("NearCertificate") )
        ( sb._a_S(" but at least ") )
        if   (self.__acceptable_sol == AccSolutionStatus.Anything):
          ( sb._a_S("Anything") )
        elif (self.__acceptable_sol == AccSolutionStatus.Optimal):
          ( sb._a_S("Optimal") )
        elif (self.__acceptable_sol == AccSolutionStatus.NearOptimal):
          ( sb._a_S("NearOptimal") )
        elif (self.__acceptable_sol == AccSolutionStatus.Feasible):
          ( sb._a_S("Feasible") )
        elif (self.__acceptable_sol == AccSolutionStatus.Certificate):
          ( sb._a_S("Certificate") )
        ( sb._a_S(" is expected") )
        raise mosek.fusion.SolutionError(( sb._toString_() ))
  @staticmethod
  def _matchargs_primalObjValue_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Model.mbi(2211:15-2213:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("primalObjValue()")
  def _primalObjValue_(self):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(SolutionType.Default,True) ).pobj
  @staticmethod
  def _matchargs_dualObjValue_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Model.mbi(2218:15-2220:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("dualObjValue()")
  def _dualObjValue_(self):
    return ( self._get_1sol_1cache_Omosek_fusion_SolutionType_2B(SolutionType.Default,False) ).dobj
  @staticmethod
  def _matchargs_getPrimalSolutionStatus_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Model.mbi(2225:15-2241:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getPrimalSolutionStatus()")
  def _getPrimalSolutionStatus_(self):
    res = None

    if   (self.__solutionptr == SolutionType.Default):
      if   (self._sol_itg != None):
        res = self._sol_itg
      elif (self._sol_bas != None):
        res = self._sol_bas
      else:
        res = self._sol_itr
    elif (self.__solutionptr == SolutionType.Basic):
      res = self._sol_bas
    elif (self.__solutionptr == SolutionType.Integer):
      res = self._sol_itg
    else:
      res = self._sol_itr
    if   (res == None):
      return SolutionStatus.Undefined
    elif (not self._synched):
      return SolutionStatus.Unknown
    else:
      return res.pstatus
  @staticmethod
  def _matchargs_getDualSolutionStatus_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Model.mbi(2245:15-2270:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("getDualSolutionStatus()")
  def _getDualSolutionStatus_(self):
    res = None

    if   (self.__solutionptr == SolutionType.Default):
      if   (self._sol_itg != None):
        res = self._sol_itg
      elif (self._sol_bas != None):
        res = self._sol_bas
      else:
        res = self._sol_itr
    elif (self.__solutionptr == SolutionType.Interior):
      res = self._sol_itr
    elif (self.__solutionptr == SolutionType.Basic):
      res = self._sol_bas
    elif (self.__solutionptr == SolutionType.Integer):
      res = self._sol_itg
    if   (res == None):
      return SolutionStatus.Undefined
    elif (not self._synched):
      return SolutionStatus.Unknown
    else:
      return res.dstatus
  @staticmethod
  def _matchargs_solve_(args):
    if len(args) != 0:
      return False
    return True
  # origin: src/fusion/Model.mbi(2309:15-2312:7)
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("solve()")
  def _solve_(self):
    ( self._task_1solve_() )
  @staticmethod
  def _matchargs_setSolverParam_SS(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],basestring): return False
    return True
  # origin: src/fusion/Model.mbi(2326:15-2325:128)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setSolverParam(basestring,basestring)")
  def _setSolverParam_SS(self,name,strval):
    ( Parameters._setParameter_Omosek_fusion_Model_2SS (self,name,strval) )
  @staticmethod
  def _matchargs_setSolverParam_SI(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],int): return False
    return True
  # origin: src/fusion/Model.mbi(2338:15-2337:128)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setSolverParam(basestring,int)")
  def _setSolverParam_SI(self,name,intval):
    ( Parameters._setParameter_Omosek_fusion_Model_2SI (self,name,intval) )
  @staticmethod
  def _matchargs_setSolverParam_SF(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],basestring): return False
    if not isinstance(args[1],float): return False
    return True
  # origin: src/fusion/Model.mbi(2350:15-2349:132)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setSolverParam(basestring,float)")
  def _setSolverParam_SF(self,name,floatval):
    ( Parameters._setParameter_Omosek_fusion_Model_2SF (self,name,floatval) )
  @staticmethod
  def _matchargs_setLogHandler_OStreamWriter_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],file): return False
    return True
  # origin: src/fusion/Model.mbi(2358:15-2357:82)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("setLogHandler(file)")
  def _setLogHandler_OStreamWriter_2(self,h):
    ( self._task_1setLogHandler_OStreamWriter_2(h) )
  @staticmethod
  def _matchargs_getSolverDoubleInfo_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: src/fusion/Model.mbi(2368:15-2367:92)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolverDoubleInfo(basestring)")
  def _getSolverDoubleInfo_S(self,name):
    return ( self._task_1get_1dinf_S(name) )
  @staticmethod
  def _matchargs_getSolverIntInfo_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: src/fusion/Model.mbi(2378:15-2377:92)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolverIntInfo(basestring)")
  def _getSolverIntInfo_S(self,name):
    return ( self._task_1get_1iinf_S(name) )
  @staticmethod
  def _matchargs_getSolverLIntInfo_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: src/fusion/Model.mbi(2388:15-2387:93)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("getSolverLIntInfo(basestring)")
  def _getSolverLIntInfo_S(self,name):
    return ( self._task_1get_1liinf_S(name) )
  @staticmethod
  def _matchargs_writeTask_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  # origin: src/fusion/Model.mbi(2396:15-2395:78)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("writeTask(basestring)")
  def _writeTask_S(self,filename):
    ( self._task_1write_S(filename) )
  @staticmethod
  def _matchargs_append_1rangedvar_Omosek_fusion_ModelVariable_2LSFF(args):
    if len(args) != 5:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.ModelVariable): return False
    if not isinstance(args[1],long): return False
    if not isinstance(args[2],basestring): return False
    if not isinstance(args[3],float): return False
    if not isinstance(args[4],float): return False
    return True
  # origin: src/fusion/Model.mbi(2398:18-2405:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("append_rangedvar(mosek.fusion.ModelVariable,long,basestring,float,float)")
  def _append_1rangedvar_Omosek_fusion_ModelVariable_2LSFF(self,v,linearidx,name,lb,ub):
    idx = ( self._alloc_1rangedvar_SFF(name,lb,ub) )

    ( self.__natvarmap_1ensure_I(1) )
    self.__natvarmap_idx[idx] = linearidx
    self.__natvarmap_Var[idx] = v
    self.__natvarmap_num = (self.__natvarmap_num + 1)
    return idx
  @staticmethod
  def _matchargs_append_1linearvar_Omosek_fusion_ModelVariable_2LSOmosek_fusion_RelationKey_2F(args):
    if len(args) != 5:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.ModelVariable): return False
    if not isinstance(args[1],long): return False
    if not isinstance(args[2],basestring): return False
    if not isinstance(args[3],mosek.fusion.RelationKey): return False
    if not isinstance(args[4],float): return False
    return True
  # origin: src/fusion/Model.mbi(2408:18-2415:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("append_linearvar(mosek.fusion.ModelVariable,long,basestring,mosek.fusion.RelationKey,float)")
  def _append_1linearvar_Omosek_fusion_ModelVariable_2LSOmosek_fusion_RelationKey_2F(self,v,linearidx,name,relkey,bound):
    idx = ( self._alloc_1linearvar_SOmosek_fusion_RelationKey_2F(name,relkey,bound) )

    ( self.__natvarmap_1ensure_I(1) )
    self.__natvarmap_idx[idx] = linearidx
    self.__natvarmap_Var[idx] = v
    self.__natvarmap_num = (self.__natvarmap_num + 1)
    return idx
  @staticmethod
  def _matchargs_nativeVarToStr_IOmosek_fusion_Utils_StringBuffer_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],int): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Utils.StringBuffer): return False
    return True
  # origin: src/fusion/Model.mbi(2420:18-2422:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("nativeVarToStr(int,mosek.fusion.Utils.StringBuffer)")
  def _nativeVarToStr_IOmosek_fusion_Utils_StringBuffer_2(self,nidx,sb):
    ( self.__natvarmap_Var[nidx]._elementName_LOmosek_fusion_Utils_StringBuffer_2(self.__natvarmap_idx[nidx],sb) )
  @_cliptrace
  def acceptedSolutionStatus(self,*args):
    if   Model._matchargs_acceptedSolutionStatus_(args):
      return Model._acceptedSolutionStatus_(self,*args)
    elif Model._matchargs_acceptedSolutionStatus_Omosek_fusion_AccSolutionStatus_2(args):
      return Model._acceptedSolutionStatus_Omosek_fusion_AccSolutionStatus_2(self,*args)
    else:
      argtypestr = "acceptedSolutionStatus(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tacceptedSolutionStatus()"),(1,"\tacceptedSolutionStatus(mosek.fusion.AccSolutionStatus)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getPrimalSolutionStatus(self,*args):
    if   Model._matchargs_getPrimalSolutionStatus_(args):
      return Model._getPrimalSolutionStatus_(self,*args)
    else:
      argtypestr = "getPrimalSolutionStatus(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetPrimalSolutionStatus()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getConstraint(self,*args):
    if   Model._matchargs_getConstraint_S(args):
      return Model._getConstraint_S(self,*args)
    else:
      argtypestr = "getConstraint(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetConstraint(basestring)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getSolverLIntInfo(self,*args):
    if   Model._matchargs_getSolverLIntInfo_S(args):
      return Model._getSolverLIntInfo_S(self,*args)
    else:
      argtypestr = "getSolverLIntInfo(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetSolverLIntInfo(basestring)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getDualSolutionStatus(self,*args):
    if   Model._matchargs_getDualSolutionStatus_(args):
      return Model._getDualSolutionStatus_(self,*args)
    else:
      argtypestr = "getDualSolutionStatus(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tgetDualSolutionStatus()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def constraint(self,*args):
    if   Model._matchargs_constraint_Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
      return Model._constraint_Omosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(args):
      return Model._constraint_SOmosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
      return Model._constraint_SOmosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(args):
      return Model._constraint_Omosek_fusion_Expression_2Omosek_fusion_PSDDomain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
      return Model._constraint_Omosek_fusion_Set_2Omosek_fusion_Variable_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Variable_2Omosek_fusion_PSDDomain_2(args):
      return Model._constraint_Omosek_fusion_Variable_2Omosek_fusion_PSDDomain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
      return Model._constraint_Omosek_fusion_Variable_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Variable_2Omosek_fusion_Domain_2(args):
      return Model._constraint_SOmosek_fusion_Variable_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_Omosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Variable_2Omosek_fusion_PSDDomain_2(args):
      return Model._constraint_SOmosek_fusion_Variable_2Omosek_fusion_PSDDomain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_SOmosek_fusion_Expression_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_Omosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
      return Model._constraint_Omosek_fusion_Expression_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
      return Model._constraint_SOmosek_fusion_Expression_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(args):
      return Model._constraint_SOmosek_fusion_Variable_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(args):
      return Model._constraint_SOmosek_fusion_Set_2Omosek_fusion_Expression_2Omosek_fusion_Domain_2(self,*args)
    else:
      argtypestr = "constraint(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tconstraint(mosek.fusion.Variable,mosek.fusion.RangeDomain)"),(3,"\tconstraint(mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.Domain)"),(4,"\tconstraint(basestring,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain)"),(3,"\tconstraint(basestring,mosek.fusion.Expression,mosek.fusion.PSDDomain)"),(3,"\tconstraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain)"),(4,"\tconstraint(basestring,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.Domain)"),(2,"\tconstraint(mosek.fusion.Expression,mosek.fusion.PSDDomain)"),(3,"\tconstraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.Domain)"),(2,"\tconstraint(mosek.fusion.Variable,mosek.fusion.PSDDomain)"),(2,"\tconstraint(mosek.fusion.Variable,mosek.fusion.Domain)"),(3,"\tconstraint(basestring,mosek.fusion.Variable,mosek.fusion.Domain)"),(3,"\tconstraint(mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain)"),(3,"\tconstraint(basestring,mosek.fusion.Variable,mosek.fusion.PSDDomain)"),(2,"\tconstraint(mosek.fusion.Expression,mosek.fusion.RangeDomain)"),(4,"\tconstraint(basestring,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain)"),(3,"\tconstraint(basestring,mosek.fusion.Expression,mosek.fusion.RangeDomain)"),(2,"\tconstraint(mosek.fusion.Expression,mosek.fusion.Domain)"),(3,"\tconstraint(basestring,mosek.fusion.Expression,mosek.fusion.Domain)"),(3,"\tconstraint(basestring,mosek.fusion.Variable,mosek.fusion.RangeDomain)"),(4,"\tconstraint(basestring,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.Domain)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getSolverDoubleInfo(self,*args):
    if   Model._matchargs_getSolverDoubleInfo_S(args):
      return Model._getSolverDoubleInfo_S(self,*args)
    else:
      argtypestr = "getSolverDoubleInfo(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetSolverDoubleInfo(basestring)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def setSolverParam(self,*args):
    if   Model._matchargs_setSolverParam_SS(args):
      return Model._setSolverParam_SS(self,*args)
    elif Model._matchargs_setSolverParam_SF(args):
      return Model._setSolverParam_SF(self,*args)
    elif Model._matchargs_setSolverParam_SI(args):
      return Model._setSolverParam_SI(self,*args)
    else:
      argtypestr = "setSolverParam(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(2,"\tsetSolverParam(basestring,basestring)"),(2,"\tsetSolverParam(basestring,float)"),(2,"\tsetSolverParam(basestring,int)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getSolverIntInfo(self,*args):
    if   Model._matchargs_getSolverIntInfo_S(args):
      return Model._getSolverIntInfo_S(self,*args)
    else:
      argtypestr = "getSolverIntInfo(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetSolverIntInfo(basestring)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def variable(self,*args):
    if   Model._matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_SIIOmosek_fusion_PSDDomain_2(args):
      return Model._variable_SIIOmosek_fusion_PSDDomain_2(self,*args)
    elif Model._matchargs_variable_IOmosek_fusion_PSDDomain_2(args):
      return Model._variable_IOmosek_fusion_PSDDomain_2(self,*args)
    elif Model._matchargs_variable_IOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_IOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_IOmosek_fusion_RangeDomain_2(args):
      return Model._variable_IOmosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_variable_IIOmosek_fusion_PSDDomain_2(args):
      return Model._variable_IIOmosek_fusion_PSDDomain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_PSDDomain_2(args):
      return Model._variable_SOmosek_fusion_Set_2Omosek_fusion_PSDDomain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2(args):
      return Model._variable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_PSDDomain_2(args):
      return Model._variable_SOmosek_fusion_PSDDomain_2(self,*args)
    elif Model._matchargs_variable_IOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_IOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_SIOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_SIOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_SIOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_SIOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_SIOmosek_fusion_Domain_2(args):
      return Model._variable_SIOmosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2(args):
      return Model._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_RangeDomain_2(args):
      return Model._variable_SOmosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_Domain_2(args):
      return Model._variable_Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_SIOmosek_fusion_PSDDomain_2(args):
      return Model._variable_SIOmosek_fusion_PSDDomain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_PSDDomain_2(args):
      return Model._variable_Omosek_fusion_PSDDomain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_Domain_2(args):
      return Model._variable_SOmosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_RangeDomain_2(args):
      return Model._variable_Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2(args):
      return Model._variable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2(args):
      return Model._variable_Omosek_fusion_Set_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_variable_SIOmosek_fusion_RangeDomain_2(args):
      return Model._variable_SIOmosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_IOmosek_fusion_Domain_2(args):
      return Model._variable_IOmosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_variable_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._variable_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    else:
      argtypestr = "variable(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(4,"\tvariable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(4,"\tvariable(basestring,int,int,mosek.fusion.PSDDomain)"),(2,"\tvariable(int,mosek.fusion.PSDDomain)"),(3,"\tvariable(int,mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(2,"\tvariable(int,mosek.fusion.RangeDomain)"),(3,"\tvariable(int,int,mosek.fusion.PSDDomain)"),(3,"\tvariable(mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(2,"\tvariable(mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(3,"\tvariable(basestring,mosek.fusion.Set,mosek.fusion.PSDDomain)"),(3,"\tvariable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain)"),(2,"\tvariable(basestring,mosek.fusion.PSDDomain)"),(3,"\tvariable(int,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(4,"\tvariable(basestring,int,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(4,"\tvariable(basestring,int,mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(3,"\tvariable(mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(3,"\tvariable(basestring,int,mosek.fusion.Domain)"),(3,"\tvariable(basestring,mosek.fusion.Set,mosek.fusion.Domain)"),(2,"\tvariable(basestring,mosek.fusion.RangeDomain)"),(1,"\tvariable(mosek.fusion.Domain)"),(2,"\tvariable(mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(3,"\tvariable(basestring,int,mosek.fusion.PSDDomain)"),(1,"\tvariable(mosek.fusion.PSDDomain)"),(2,"\tvariable(basestring,mosek.fusion.Domain)"),(1,"\tvariable(mosek.fusion.RangeDomain)"),(2,"\tvariable(mosek.fusion.Set,mosek.fusion.RangeDomain)"),(2,"\tvariable(mosek.fusion.Set,mosek.fusion.Domain)"),(3,"\tvariable(basestring,int,mosek.fusion.RangeDomain)"),(3,"\tvariable(basestring,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(2,"\tvariable(int,mosek.fusion.Domain)"),(4,"\tvariable(basestring,mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(3,"\tvariable(basestring,mosek.fusion.Domain,mosek.fusion.IntegerDomain)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def setLogHandler(self,*args):
    if   Model._matchargs_setLogHandler_OStreamWriter_2(args):
      return Model._setLogHandler_OStreamWriter_2(self,*args)
    else:
      argtypestr = "setLogHandler(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tsetLogHandler(file)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def primalObjValue(self,*args):
    if   Model._matchargs_primalObjValue_(args):
      return Model._primalObjValue_(self,*args)
    else:
      argtypestr = "primalObjValue(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tprimalObjValue()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def sparseVariable(self,*args):
    if   Model._matchargs_sparseVariable_IOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_IOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_IOmosek_fusion_RangeDomain_2(args):
      return Model._sparseVariable_IOmosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2(args):
      return Model._sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_sparseVariable_SIOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_SIOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_Omosek_fusion_RangeDomain_2(args):
      return Model._sparseVariable_Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_SIOmosek_fusion_RangeDomain_2(args):
      return Model._sparseVariable_SIOmosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_SOmosek_fusion_Domain_2(args):
      return Model._sparseVariable_SOmosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_sparseVariable_Omosek_fusion_Set_2Omosek_fusion_Domain_2(args):
      return Model._sparseVariable_Omosek_fusion_Set_2Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_sparseVariable_Omosek_fusion_Domain_2(args):
      return Model._sparseVariable_Omosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_sparseVariable_SIOmosek_fusion_Domain_2(args):
      return Model._sparseVariable_SIOmosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_sparseVariable_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_SOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2(args):
      return Model._sparseVariable_SOmosek_fusion_Set_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_Omosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_Omosek_fusion_Set_2Omosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_IOmosek_fusion_Domain_2(args):
      return Model._sparseVariable_IOmosek_fusion_Domain_2(self,*args)
    elif Model._matchargs_sparseVariable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2(args):
      return Model._sparseVariable_Omosek_fusion_Set_2Omosek_fusion_RangeDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_SOmosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_IOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_IOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_SIOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_SIOmosek_fusion_Domain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(args):
      return Model._sparseVariable_Omosek_fusion_RangeDomain_2Omosek_fusion_IntegerDomain_2(self,*args)
    elif Model._matchargs_sparseVariable_SOmosek_fusion_RangeDomain_2(args):
      return Model._sparseVariable_SOmosek_fusion_RangeDomain_2(self,*args)
    else:
      argtypestr = "sparseVariable(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(3,"\tsparseVariable(int,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(4,"\tsparseVariable(basestring,mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(4,"\tsparseVariable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(2,"\tsparseVariable(mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(2,"\tsparseVariable(int,mosek.fusion.RangeDomain)"),(3,"\tsparseVariable(basestring,mosek.fusion.Set,mosek.fusion.Domain)"),(4,"\tsparseVariable(basestring,int,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(1,"\tsparseVariable(mosek.fusion.RangeDomain)"),(3,"\tsparseVariable(basestring,int,mosek.fusion.RangeDomain)"),(2,"\tsparseVariable(basestring,mosek.fusion.Domain)"),(2,"\tsparseVariable(mosek.fusion.Set,mosek.fusion.Domain)"),(1,"\tsparseVariable(mosek.fusion.Domain)"),(3,"\tsparseVariable(basestring,int,mosek.fusion.Domain)"),(3,"\tsparseVariable(basestring,mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(3,"\tsparseVariable(basestring,mosek.fusion.Set,mosek.fusion.RangeDomain)"),(3,"\tsparseVariable(mosek.fusion.Set,mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(2,"\tsparseVariable(int,mosek.fusion.Domain)"),(3,"\tsparseVariable(mosek.fusion.Set,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(2,"\tsparseVariable(mosek.fusion.Set,mosek.fusion.RangeDomain)"),(3,"\tsparseVariable(basestring,mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(3,"\tsparseVariable(int,mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(4,"\tsparseVariable(basestring,int,mosek.fusion.Domain,mosek.fusion.IntegerDomain)"),(2,"\tsparseVariable(mosek.fusion.RangeDomain,mosek.fusion.IntegerDomain)"),(2,"\tsparseVariable(basestring,mosek.fusion.RangeDomain)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def getVariable(self,*args):
    if   Model._matchargs_getVariable_S(args):
      return Model._getVariable_S(self,*args)
    else:
      argtypestr = "getVariable(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tgetVariable(basestring)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def objective(self,*args):
    if   Model._matchargs_objective_F(args):
      return Model._objective_F(self,*args)
    elif Model._matchargs_objective_SF(args):
      return Model._objective_SF(self,*args)
    elif Model._matchargs_objective_SOmosek_fusion_ObjectiveSense_2F(args):
      return Model._objective_SOmosek_fusion_ObjectiveSense_2F(self,*args)
    elif Model._matchargs_objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(args):
      return Model._objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(self,*args)
    elif Model._matchargs_objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(args):
      return Model._objective_SOmosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(self,*args)
    elif Model._matchargs_objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(args):
      return Model._objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Expression_2(self,*args)
    elif Model._matchargs_objective_Omosek_fusion_ObjectiveSense_2F(args):
      return Model._objective_Omosek_fusion_ObjectiveSense_2F(self,*args)
    elif Model._matchargs_objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(args):
      return Model._objective_Omosek_fusion_ObjectiveSense_2Omosek_fusion_Variable_2(self,*args)
    else:
      argtypestr = "objective(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\tobjective(float)"),(2,"\tobjective(basestring,float)"),(3,"\tobjective(basestring,mosek.fusion.ObjectiveSense,float)"),(3,"\tobjective(basestring,mosek.fusion.ObjectiveSense,mosek.fusion.Expression)"),(3,"\tobjective(basestring,mosek.fusion.ObjectiveSense,mosek.fusion.Variable)"),(2,"\tobjective(mosek.fusion.ObjectiveSense,mosek.fusion.Expression)"),(2,"\tobjective(mosek.fusion.ObjectiveSense,float)"),(2,"\tobjective(mosek.fusion.ObjectiveSense,mosek.fusion.Variable)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def solve(self,*args):
    if   Model._matchargs_solve_(args):
      return Model._solve_(self,*args)
    else:
      argtypestr = "solve(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tsolve()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def writeTask(self,*args):
    if   Model._matchargs_writeTask_S(args):
      return Model._writeTask_S(self,*args)
    else:
      argtypestr = "writeTask(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(1,"\twriteTask(basestring)")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  @_cliptrace
  def dualObjValue(self,*args):
    if   Model._matchargs_dualObjValue_(args):
      return Model._dualObjValue_(self,*args)
    else:
      argtypestr = "dualObjValue(%s)" % ",".join([_argtypestr(a) for a in args])
      prototypes = "\n".join([ v for (l,v) in [(0,"\tdualObjValue()")] if l == len(args)])
      if prototypes:
         raise ValueError("Invalid argument list for method. Got\n\t%s\nExpected:\n%s" % (argtypestr,prototypes))
      else:
         raise ValueError("Invalid argument list for method. Got\n\t%s" % (argtypestr))
  def __str__(self): return self.toString()
 
## origin: src/fusion/domain.mbi(896:5-899:5)
class IntegerDomain:
  @staticmethod
  def _matchargs_constructor_(args):
    if len(args) != 0:
      return False
    return True
  #@Utils.methodargs(Utils.arg_id) 
  #@Utils.demanglefuncname("__init__() @ src/fusion/domain.mbi(899:18-898:32)")
  def __constructor_(self):
    pass
  def __init__(self,*args):
    self.__constructor_(*args)
  def __str__(self): return self.toString()
 
## origin: src/fusion/Errors.mbi(221:5-228:5)
class UnimplementedError(Exception):
  @staticmethod
  def _matchargs_constructor_S(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],basestring): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(basestring) @ src/fusion/Errors.mbi(225:17-227:9)")
  def __constructor_S(self,msg):
    Exception.__init__(self,msg)
    pass
  def __init__(self,*args):
    self.__constructor_S(*args)
  def __str__(self): return self.toString()
 
## origin: src/fusion/domain.mbi(685:5-887:5)
class RangeDomain:
  @staticmethod
  def _matchargs_constructor__3F_3FB(args):
    if len(args) != 3:
      return False
    a = args[0]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    a = args[1]
    if not mosek.fusion.Utils.isArray(a): return False
    elif a is not None and len(a) > 0:
      a = a[0]
      if not Utils.is_float(a): return False
    if not isinstance(args[2],bool): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__([float],[float],bool) @ src/fusion/domain.mbi(714:18-730:7)")
  def __constructor__3F_3FB(self,lb_,ub_,scalable):
    if   scalable:
      self._shape = None
    else:
      self._shape = mosek.fusion.IntSet(int(len(lb_)))
    self.__idxmap_lb = None
    self.__idxmap_ub = None
    self.__ub = ub_
    self.__lb = lb_
  @staticmethod
  def _matchargs_constructor_FOmosek_fusion_Matrix_2FOmosek_fusion_Matrix_2(args):
    if len(args) != 4:
      return False
    if not isinstance(args[0],float): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Matrix): return False
    if not isinstance(args[2],float): return False
    if args[3] is not None and not isinstance(args[3],mosek.fusion.Matrix): return False
    return True
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("__init__(float,mosek.fusion.Matrix,float,mosek.fusion.Matrix) @ src/fusion/domain.mbi(733:18-799:7)")
  def __constructor_FOmosek_fusion_Matrix_2FOmosek_fusion_Matrix_2(self,lb_scalar,lb_matrix,ub_scalar,ub_matrix):
    self._shape = None
    if   (lb_matrix != None):
      bnd_ = lb_matrix

      self._shape = mosek.fusion.NDSet(bnd_._dimi,bnd_._dimj)
      _autovar_718 = bnd_
      if   isinstance(_autovar_718,mosek.fusion.DenseMatrix):
        m = _autovar_718
        self.__lb = m._data
        self.__idxmap_lb = None
      elif isinstance(_autovar_718,mosek.fusion.SparseMatrix):
        m = _autovar_718
        self.__lb = m._val
        self.__idxmap_lb = mosek.fusion.Utils.IntMap()
        # src/fusion/domain.mbi(753:13-754:72)
        for i in xrange(0,int(len(self.__lb))):
          ( self.__idxmap_lb._setItem_LI(( self._shape._linearidx_II(m._subi[i],m._subj[i]) ),i) )
      else:
        m = _autovar_718
        raise mosek.fusion.UnimplementedError("Unknown matrix type.")
    else:
      self.__lb = ( Utils.Tools._makevector_FI (lb_scalar,1) )
      self.__idxmap_lb = None
    if   (ub_matrix != None):
      bnd_ = ub_matrix

      if   (self._shape == None):
        self._shape = mosek.fusion.NDSet(bnd_._dimi,bnd_._dimj)
      _autovar_719 = bnd_
      if   isinstance(_autovar_719,mosek.fusion.DenseMatrix):
        m = _autovar_719
        self.__ub = m._data
        self.__idxmap_ub = None
      elif isinstance(_autovar_719,mosek.fusion.SparseMatrix):
        m = _autovar_719
        self.__ub = m._val
        self.__idxmap_ub = mosek.fusion.Utils.IntMap()
        # src/fusion/domain.mbi(784:13-787:13)
        i = 0

        while (i < int(len(self.__ub))):
          ( self.__idxmap_ub._setItem_LI(( self._shape._linearidx_II(m._subi[i],m._subj[i]) ),i) )
          i += 1
      else:
        m = _autovar_719
        raise mosek.fusion.UnimplementedError("Unknown matrix type.")
    else:
      self.__ub = ( Utils.Tools._makevector_FI (ub_scalar,1) )
      self.__idxmap_ub = None
  def __init__(self,*args):
    #self._protected_shape = None

    #self.__idxmap_lb = None

    #self.__idxmap_ub = None

    #self.__lb = None

    #self.__ub = None

    if   self._matchargs_constructor__3F_3FB(args):
      self.__constructor__3F_3FB(*args)
    elif self._matchargs_constructor_FOmosek_fusion_Matrix_2FOmosek_fusion_Matrix_2(args):
      self.__constructor_FOmosek_fusion_Matrix_2FOmosek_fusion_Matrix_2(*args)
    else:
      raise ValueError("Invalid argument list for constructor")
  @staticmethod
  def _matchargs_get_1lb_1item_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/domain.mbi(802:18-828:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get_lb_item(long)")
  def _get_1lb_1item_L(self,index):
    if   (self.__idxmap_lb != None):
      if   (self.__lb == None):
        return 0.0
      elif ( self.__idxmap_lb._hasItem_L(index) ):
        return self.__lb[( self.__idxmap_lb._getItem_L(index) )]
      else:
        return 0.0
    else:
      if   (int(len(self.__lb)) == 1):
        return self.__lb[0]
      elif (self.__lb != None):
        return self.__lb[index]
      else:
        return 0.0
  @staticmethod
  def _matchargs_get_1ub_1item_L(args):
    if len(args) != 1:
      return False
    if not isinstance(args[0],long): return False
    return True
  # origin: src/fusion/domain.mbi(831:18-857:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("get_ub_item(long)")
  def _get_1ub_1item_L(self,index):
    if   (self.__idxmap_ub != None):
      if   (self.__ub == None):
        return 0.0
      else:
        if   ( self.__idxmap_ub._hasItem_L(index) ):
          return self.__ub[( self.__idxmap_ub._getItem_L(index) )]
        else:
          return 0.0
    else:
      if   (int(len(self.__ub)) == 1):
        return self.__ub[0]
      elif (self.__ub != None):
        return self.__ub[index]
      else:
        return 0.0
  @staticmethod
  def _matchargs_match_1shape_Omosek_fusion_Set_2(args):
    if len(args) != 1:
      return False
    if args[0] is not None and not isinstance(args[0],mosek.fusion.Set): return False
    return True
  # origin: src/fusion/domain.mbi(860:18-880:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("match_shape(mosek.fusion.Set)")
  def _match_1shape_Omosek_fusion_Set_2(self,shp):
    if   (self._shape == None):
      return True
    elif (self._shape.nd == shp.nd):
      # src/fusion/domain.mbi(867:11-873:11)
      i = 0

      while (i < self._shape.nd):
        if   (( shp._dim_I(i) ) != ( self._shape._dim_I(i) )):
          return False
        i += 1
      return True
    else:
      return False
  @staticmethod
  def _matchargs_domainToString_LOmosek_fusion_Utils_StringBuffer_2(args):
    if len(args) != 2:
      return False
    if not isinstance(args[0],long): return False
    if args[1] is not None and not isinstance(args[1],mosek.fusion.Utils.StringBuffer): return False
    return True
  # origin: src/fusion/domain.mbi(884:18-886:7)
  #@Utils.methodargs(Utils.arg_id,Utils.arg_id,Utils.arg_id) 
  #@Utils.demanglefuncname("domainToString(long,mosek.fusion.Utils.StringBuffer)")
  def _domainToString_LOmosek_fusion_Utils_StringBuffer_2(self,i,sb):
    return ( ( ( ( ( sb._a_S(" : in range [ ") )._a_F(( self._get_1lb_1item_L(i) )) )._a_S(",") )._a_F(( self._get_1ub_1item_L(i) )) )._toString_() )
  def __str__(self): return self.toString()
 
import mosek.fusion.Utils
import mosek.fusion

